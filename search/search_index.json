{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RxJS Angular interview guide","text":"<p>Ready to take your Angular skills to the next level? Welcome to the ultimate RxJS interview guide designed for Angular developers like you! Whether you're preparing for your next job interview or simply want to deepen your understanding of reactive programming in Angular, this guide has you covered. Explore real-world RxJS examples, clear explanations, and detailed interview questions and answers that will give you the edge over other candidates.</p> <p>Learn how to use RxJS operators effectively in Angular applications, understand best practices, and discover expert tips that will help you tackle even the toughest interview challenges. With this guide, you\u2019ll not only master the intricacies of RxJS but also develop a deeper understanding of how to apply these concepts to real-world scenarios.</p> <p>Are you ready to crack your next Angular interview and become a true expert in reactive programming? Let\u2019s dive in!</p>"},{"location":"async-pipe/","title":"Async pipe","text":"<p>Think of the <code>async</code> pipe as a smart assistant for handling asynchronous data right where you display it (in the HTML template). It does several important things automatically:</p> <ol> <li>Subscribes: When the component loads, the <code>async</code> pipe automatically subscribes to the Observable (or Promise) you provide it.</li> <li>Unwraps Values: When the Observable emits a new value, the <code>async</code> pipe \"unwraps\" that value and makes it available for binding in your template.</li> <li>Triggers Change Detection: It automatically tells Angular to check the component for changes whenever a new value arrives, ensuring your view updates.</li> <li>Unsubscribes Automatically: This is a huge benefit! When the component is destroyed, the <code>async</code> pipe automatically unsubscribes from the Observable, preventing potential memory leaks. You don't need manual unsubscription logic (like <code>takeUntilDestroyed</code> or <code>.unsubscribe()</code>) for the subscription managed by the pipe itself.</li> <li>Handles Null/Undefined Initially: Before the Observable emits its first value, the <code>async</code> pipe typically returns <code>null</code>, which you can handle gracefully in your template (often using <code>@if</code> or <code>*ngIf</code>).</li> </ol>"},{"location":"async-pipe/#why-use-the-async-pipe","title":"Why Use the <code>async</code> Pipe?","text":"<ul> <li>Less Boilerplate Code: Significantly reduces the amount of code you need to write in your component's TypeScript file. You often don't need to manually subscribe, store the emitted value in a component property/signal, or handle unsubscription just for displaying the data.</li> <li>Automatic Memory Management: The automatic unsubscription is the killer feature, making your components cleaner and less prone to memory leaks.</li> <li>Improved Readability: Keeps the template declarative. The template shows what data stream it's bound to, and the pipe handles the how.</li> </ul>"},{"location":"async-pipe/#real-world-example-displaying-user-data-fetched-via-httpclient","title":"Real-World Example: Displaying User Data Fetched via HttpClient","text":"<p>Fetching data from an API is a prime use case. Let's fetch user data and display it using the <code>async</code> pipe, avoiding manual subscription in the component for display purposes.</p> <p>Code Snippet:</p> <p>1. User Service</p> <pre><code>import { Injectable, inject } from \"@angular/core\";\nimport { HttpClient } from \"@angular/common/http\";\nimport { Observable } from \"rxjs\";\nimport { shareReplay, tap } from \"rxjs/operators\";\n\nexport interface UserProfile {\n  id: number;\n  name: string;\n  username: string;\n  email: string;\n}\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class UserService {\n  private http = inject(HttpClient);\n  private userUrl = \"https://jsonplaceholder.typicode.com/users/\";\n\n  // Cache for user profiles to avoid repeated requests for the same ID\n  private userCache: { [key: number]: Observable&lt;UserProfile&gt; } = {};\n\n  getUser(id: number): Observable&lt;UserProfile&gt; {\n    // Check cache first\n    if (!this.userCache[id]) {\n      console.log(`UserService: Fetching user ${id} from API...`);\n      this.userCache[id] = this.http\n        .get&lt;UserProfile&gt;(`${this.userUrl}${id}`)\n        .pipe(\n          tap(() =&gt;\n            console.log(`UserService: API call for user ${id} completed.`)\n          ),\n          // Share &amp; replay the single result, keep active while subscribed\n          shareReplay({ bufferSize: 1, refCount: true })\n        );\n    } else {\n      console.log(`UserService: Returning cached observable for user ${id}.`);\n    }\n    return this.userCache[id];\n  }\n}\n</code></pre> <p>2. User Display Component</p> <pre><code>import {\n  Component,\n  inject,\n  signal,\n  ChangeDetectionStrategy,\n  Input,\n  OnInit,\n} from \"@angular/core\";\nimport { CommonModule } from \"@angular/common\"; // Needed for async pipe, @if, json pipe\nimport { UserService, UserProfile } from \"./user.service\"; // Adjust path\nimport { Observable, EMPTY } from \"rxjs\"; // Import Observable and EMPTY\n\n@Component({\n  selector: \"app-user-display\",\n  standalone: true,\n  imports: [CommonModule], // Make sure CommonModule is imported\n  template: `\n    &lt;div class=\"user-card\"&gt;\n      &lt;h4&gt;User Profile (ID: {{ userId }})&lt;/h4&gt;\n\n      &lt;!-- Use the async pipe here --&gt;\n      @if (user$ | async; as user) {\n      &lt;!-- 'user' now holds the emitted UserProfile object --&gt;\n      &lt;div&gt;\n        &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt; {{ user.name }}&lt;/p&gt;\n        &lt;p&gt;&lt;strong&gt;Username:&lt;/strong&gt; {{ user.username }}&lt;/p&gt;\n        &lt;p&gt;&lt;strong&gt;Email:&lt;/strong&gt; {{ user.email }}&lt;/p&gt;\n      &lt;/div&gt;\n      &lt;!-- Optional: Show raw data --&gt;\n      &lt;!-- &lt;details&gt;\n          &lt;summary&gt;Raw Data&lt;/summary&gt;\n          &lt;pre&gt;{{ user | json }}&lt;/pre&gt;\n        &lt;/details&gt; --&gt;\n      } @else {\n      &lt;!-- This shows before the observable emits --&gt;\n      &lt;p&gt;Loading user data...&lt;/p&gt;\n      }\n      &lt;!-- Note: Error handling needs separate logic or wrapping the source --&gt;\n    &lt;/div&gt;\n  `,\n  // No 'styles' section\n  changeDetection: ChangeDetectionStrategy.OnPush, // Good practice with async pipe/observables\n})\nexport class UserDisplayComponent implements OnInit {\n  private userService = inject(UserService);\n\n  @Input({ required: true }) userId!: number; // Get user ID from parent\n\n  // Expose the Observable directly to the template\n  user$: Observable&lt;UserProfile&gt; = EMPTY; // Initialize with EMPTY or handle null later\n\n  ngOnInit() {\n    // Assign the observable in ngOnInit (or wherever appropriate)\n    // NO .subscribe() here for the template binding!\n    this.user$ = this.userService.getUser(this.userId);\n    console.log(\n      `UserDisplayComponent (ID: ${this.userId}): Assigned observable to user$`\n    );\n  }\n\n  // --- Compare with manual subscription (for illustration) ---\n  // // Manual Approach (requires more code + manual unsubscription handling):\n  // private destroyRef = inject(DestroyRef);\n  // userSignal = signal&lt;UserProfile | null&gt;(null);\n  // loading = signal&lt;boolean&gt;(false);\n\n  // ngOnInitManual() {\n  //   this.loading.set(true);\n  //   this.userService.getUser(this.userId)\n  //     .pipe(\n  //       takeUntilDestroyed(this.destroyRef) // Need manual unsubscribe handling\n  //     )\n  //     .subscribe({\n  //       next: (user) =&gt; {\n  //         this.userSignal.set(user); // Store in component state\n  //         this.loading.set(false);\n  //       },\n  //       error: (err) =&gt; {\n  //         console.error(err);\n  //         this.loading.set(false);\n  //         // Handle error state...\n  //       }\n  //     });\n  // }\n  // // Then in template you'd bind to userSignal() and loading()\n}\n</code></pre> <p>3. Parent Component (Using the User Display Component)</p> <pre><code>import { Component } from \"@angular/core\";\nimport { UserDisplayComponent } from \"./user-display.component\"; // Adjust path\n\n@Component({\n  selector: \"app-root\",\n  standalone: true,\n  imports: [UserDisplayComponent],\n  template: `\n    &lt;h1&gt;Async Pipe Demo&lt;/h1&gt;\n    &lt;app-user-display [userId]=\"1\"&gt;&lt;/app-user-display&gt;\n    &lt;hr /&gt;\n    &lt;app-user-display [userId]=\"2\"&gt;&lt;/app-user-display&gt;\n    &lt;hr /&gt;\n    &lt;!-- This will use the cached observable --&gt;\n    &lt;app-user-display [userId]=\"1\"&gt;&lt;/app-user-display&gt;\n  `,\n})\nexport class AppComponent {}\n</code></pre> <p>Explanation:</p> <ol> <li><code>UserService</code> provides a <code>getUser(id)</code> method that returns an <code>Observable&lt;UserProfile&gt;</code>. It includes caching and <code>shareReplay</code> for efficiency.</li> <li><code>UserDisplayComponent</code> gets a <code>userId</code> via <code>@Input</code>.</li> <li>In <code>ngOnInit</code>, it calls <code>userService.getUser(this.userId)</code> and assigns the returned Observable directly to the public component property <code>user$</code>. Crucially, there is no <code>.subscribe()</code> call here.</li> <li>In the template:<ul> <li><code>@if (user$ | async; as user)</code>: This is the core line.</li> <li><code>user$ | async</code>: The <code>async</code> pipe subscribes to the <code>user$</code> observable. Initially, it returns <code>null</code>.</li> <li><code>as user</code>: If/when the <code>user$</code> observable emits a value, that value (the <code>UserProfile</code> object) is assigned to a local template variable named <code>user</code>.</li> <li>The <code>@if</code> block only renders its content when <code>user$ | async</code> produces a \"truthy\" value (i.e., after the user profile has been emitted).</li> <li>Inside the <code>@if</code> block, we can directly access properties of the resolved <code>user</code> object (e.g., <code>user.name</code>, <code>user.email</code>).</li> <li>The <code>@else</code> block handles the initial state, showing \"Loading user data...\" until the <code>async</code> pipe receives the first emission.</li> </ul> </li> <li>When the <code>UserDisplayComponent</code> is destroyed (e.g., navigated away from), the <code>async</code> pipe automatically cleans up its subscription to <code>user$</code>.</li> </ol> <p>Compare this component's TypeScript code to the commented-out <code>ngOnInitManual</code> example. The <code>async</code> pipe version is much cleaner and less error-prone for simply displaying the data.</p>"},{"location":"async-pipe/#error-handling","title":"Error Handling","text":"<p>The basic <code>async</code> pipe doesn't inherently handle errors from the Observable. If the <code>getUser</code> observable throws an error, the <code>async</code> pipe subscription will break. Proper error handling often involves using <code>catchError</code> within the Observable pipe before it reaches the <code>async</code> pipe (e.g., catching the error and returning <code>of(null)</code> or <code>EMPTY</code>) or wrapping the component in an Error Boundary mechanism if appropriate.</p>"},{"location":"cold-observables/","title":"Cold Observables","text":"<p>A Cold Observable is one where the data producer (the logic inside the Observable) doesn't start running or emitting values until you subscribe to it.</p> <p>Crucially, each time you subscribe to a cold Observable, it starts its work from the very beginning and generates a fresh, independent sequence of values just for that subscriber.</p>"},{"location":"cold-observables/#key-characteristics","title":"Key Characteristics","text":"<ol> <li>Lazy Execution: The code that produces values only runs when <code>subscribe()</code> is called. No subscription = no execution.</li> <li>Independent Execution per Subscriber: Every subscriber gets their own private stream of data. What happens in one subscription doesn't affect another.</li> </ol>"},{"location":"cold-observables/#real-world-analogy","title":"Real-World Analogy","text":"<ol> <li> <p>Watching a YouTube Video (On-Demand):</p> <ul> <li>When you click \"Play\" on a video (you subscribe), the video stream starts playing from the beginning just for you.</li> <li>If your friend clicks \"Play\" on the same video later (another subscription), they also get the video starting from the beginning, completely independent of your playback.</li> <li>The YouTube server (the Observable) delivers a separate, unique stream to each viewer (each subscriber).</li> </ul> </li> <li> <p>Playing a DVD or Blu-ray:</p> <ul> <li>Putting the disc in the player and pressing play (subscribing) starts the movie from the beginning.</li> <li>Every time someone does this with their own player (another subscription), the movie starts fresh for them.</li> </ul> </li> </ol>"},{"location":"cold-observables/#examples-in-angularrxjs","title":"Examples in Angular/RxJS","text":"<ol> <li> <p><code>HttpClient</code> (Very Common):</p> <ul> <li>Observables returned by Angular's <code>HttpClient</code> (e.g., <code>http.get()</code>, <code>http.post()</code>) are cold.</li> <li>Every time you <code>subscribe()</code> to <code>dataService.getItems()</code>, Angular makes a new HTTP request to the server.</li> <li>If Component A subscribes and Component B subscribes to the same service call, two separate network requests will be made.</li> </ul> <pre><code>// In some component:\nngOnInit() {\n  console.log(\"Subscribing first time to getItems...\");\n  this.dataService.getItems().subscribe(data =&gt; {\n    console.log(\"First subscription received data.\");\n  });\n\n  // Some time later, maybe in response to a user action\n  console.log(\"Subscribing second time to getItems...\");\n  this.dataService.getItems().subscribe(data =&gt; {\n    console.log(\"Second subscription received data.\"); // This triggers a NEW HTTP request\n  });\n}\n</code></pre> </li> <li> <p>Basic Creation Functions: Many RxJS creation functions like <code>of()</code>, <code>from()</code>, <code>range()</code>, <code>timer()</code>, <code>interval()</code> typically create cold Observables.</p> <pre><code>import { interval } from \"rxjs\";\n\n// interval(1000) emits 0, 1, 2... every second\nconst coldInterval = interval(1000);\n\nconsole.log(\"Subscribing A\");\nconst subA = coldInterval.subscribe((val) =&gt; console.log(`Sub A: ${val}`)); // Starts a timer for A\n\nsetTimeout(() =&gt; {\n  console.log(\"Subscribing B\");\n  const subB = coldInterval.subscribe((val) =&gt;\n    console.log(`Sub B: ${val}`)\n  ); // Starts a NEW timer for B\n}, 3000);\n\n// Output will show:\n// Subscribing A\n// Sub A: 0 (at 1s)\n// Sub A: 1 (at 2s)\n// Sub A: 2 (at 3s)\n// Subscribing B\n// Sub B: 0 (at 4s, because B's timer started at 3s)\n// Sub A: 3 (at 4s)\n// Sub B: 1 (at 5s)\n// Sub A: 4 (at 5s)\n// ... and so on. A and B have independent timers.\n</code></pre> </li> </ol>"},{"location":"cold-observables/#summary","title":"Summary","text":"<p>Think of Cold Observables as blueprints or recipes for generating data streams. Each time you ask for the stream (by subscribing), the recipe is followed from the start, creating a unique instance just for you. Most Observables you deal with for one-off tasks like API calls are cold.</p>"},{"location":"hot-observables/","title":"Hot Observables","text":"<p>A Hot Observable is one that produces values even if no one is subscribed to it. It's like a live broadcast \u2013 it's happening whether you tune in or not.</p> <p>When you subscribe to a hot Observable, you start receiving values from that point forward. You miss any values that were emitted before you subscribed.</p>"},{"location":"hot-observables/#key-characteristics","title":"Key Characteristics:","text":"<ol> <li>Eager Execution (Potentially): The source of values might start producing immediately (like UI events) or based on some external trigger, not necessarily tied to the first subscription.</li> <li>Shared Execution: All subscribers listen to the same stream of values. When the Observable emits a value, all current subscribers receive that same value simultaneously.</li> </ol>"},{"location":"hot-observables/#real-world-analogy","title":"Real-World Analogy:","text":"<ul> <li> <p>Live Radio Broadcast:</p> <ul> <li> <p>The radio station is broadcasting music or talk shows continuously (producing values).</p> </li> <li> <p>When you tune your radio to that station (subscribe), you start hearing whatever is being broadcast at that moment. You don't get to hear the beginning of the song or show that started before you tuned in.</p> </li> <li> <p>Everyone else listening to the same station at the same time hears the exact same broadcast (shared execution).</p> </li> </ul> </li> <li> <p>Mouse Clicks on a Web Page:</p> <ul> <li> <p>The browser generates mouse click events whenever and wherever the user clicks, regardless of whether your specific code is listening for them yet.</p> </li> <li> <p>If you attach an event listener (subscribe) to a button at some point, you will only capture the clicks that happen after your listener is active. Clicks that happened before are lost (to your listener).</p> </li> </ul> </li> </ul>"},{"location":"hot-observables/#contrast-with-cold-observables","title":"Contrast with Cold Observables:","text":"<p>Remember, Cold Observables only start when you subscribe, and each subscription gets its own independent run from the beginning (like watching a recorded YouTube video). Hot Observables are live and shared.</p>"},{"location":"hot-observables/#examples-in-angularrxjs","title":"Examples in Angular/RxJS:","text":"<ol> <li> <p>DOM Events using <code>fromEvent</code>: Observables created from browser events are inherently hot.</p> <pre><code>import { Component, ViewChild, ElementRef, inject } from \"@angular/core\";\nimport { fromEvent } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\n\n@Component({\n  selector: \"app-hot-example\",\n  template: `\n    &lt;button #myButton&gt;Click Me&lt;/button&gt;\n    &lt;p&gt;Check console log.&lt;/p&gt;\n  `,\n})\nexport class HotExampleComponent {\n  @ViewChild(\"myButton\", { static: true }) myButton!: ElementRef;\n\n  constructor() {\n    const destroyRef = inject(takeUntilDestroyed);\n\n    // Create a HOT observable from click events\n    const buttonClicks$ = fromEvent(\n      this.myButton.nativeElement,\n      \"click\"\n    ).pipe(map(() =&gt; `Clicked at ${new Date().toLocaleTimeString()}`));\n\n    console.log(\n      \"Component initialized. Try clicking the button now - nothing logged yet.\"\n    );\n    console.log(\"Subscribing to clicks in 5 seconds...\");\n\n    setTimeout(() =&gt; {\n      console.log(\"Subscribing now!\");\n      buttonClicks$\n        .pipe(destroyRef())\n        .subscribe((message) =&gt; console.log(message));\n    }, 5000);\n  }\n}\n\n// If you click the button in the first 5 seconds, the clicks happen,\n// but the console.log inside the subscribe won't show anything\n// because the subscription isn't active yet. Clicks after 5 seconds will be logged.\n</code></pre> </li> <li> <p>Subjects: RxJS <code>Subject</code> and its variations (<code>BehaviorSubject</code>, <code>ReplaySubject</code>) are used to create hot, multicast Observables. They are often used for state management or communication between different parts of an Angular application.</p> </li> <li> <p>Making Cold Observables Hot (<code>share</code>, <code>shareReplay</code>): Sometimes you have a cold Observable (like <code>HttpClient</code>) but want to share its single execution among multiple subscribers. Operators like <code>shareReplay()</code> make the source Observable hot.</p> <ul> <li>Use Case: Imagine multiple parts of your UI need the same user profile data. You only want to fetch it via HTTP once.</li> </ul> <pre><code>import { Injectable, inject } from \"@angular/core\";\nimport { HttpClient } from \"@angular/common/http\";\nimport { Observable } from \"rxjs\";\nimport { shareReplay } from \"rxjs/operators\";\n\n@Injectable({ providedIn: \"root\" })\nexport class UserService {\n  private readonly http = inject(HttpClient);\n\n  // Shared observable for user profile.\n  // HTTP call is made once, result is cached and replayed to all subscribers.\n  private readonly userProfile$: Observable&lt;any&gt;;\n\n  constructor() {\n    console.log(\"UserService: Setting up shared user profile fetch.\");\n    this.userProfile$ = this.http.get(\"/api/user/profile\").pipe(\n      shareReplay(1) // Cache the latest value and share across subscribers\n    );\n  }\n\n  // Expose the shared observable so components get the cached result\n  getUserProfile(): Observable&lt;any&gt; {\n    console.log(\n      \"UserService: getUserProfile called, returning shared observable.\"\n    );\n    return this.userProfile$;\n  }\n}\n\n// Component A calls getUserProfile().subscribe() -&gt; Triggers HTTP request.\n// Component B calls getUserProfile().subscribe() -&gt; Does NOT trigger HTTP, gets the same result (or waits for the ongoing one).\n</code></pre> </li> </ol>"},{"location":"hot-observables/#summary","title":"Summary","text":"<p>Think of Hot Observables as live, shared streams. They are active regardless of listeners, and subscribers tune in to the ongoing broadcast, potentially missing past events. They are common for UI events, real-time data, and scenarios where you explicitly want to share a single data source execution among multiple consumers using subjects or operators like <code>shareReplay</code>.</p>"},{"location":"observable/","title":"Observable","text":"<p>Think of an Observable as a stream of data or events that happens over time. It's like subscribing to a newsletter or a YouTube channel. Once you subscribe, you start receiving updates (emails, new videos) whenever they are published. You can receive zero, one, or many updates over the lifetime of that subscription.</p>"},{"location":"observable/#key-ideas","title":"Key Ideas:","text":"<ol> <li>Stream of Values: Unlike a function that returns a single value, or a Promise that resolves with a single value (or rejects), an Observable can emit multiple values over time.</li> <li>Lazy: Observables are \"lazy.\" They don't start emitting values until someone actually subscribes to them. If nobody subscribes, the code that produces the values won't even run.</li> <li>Asynchronous (or Synchronous): They are often used for asynchronous operations (like fetching data from a server), but they can also emit values synchronously.</li> <li>Cancellation: You can \"unsubscribe\" from an Observable, meaning you stop listening to the stream. This is important for cleaning up resources and preventing memory leaks.</li> </ol>"},{"location":"observable/#real-world-analogy","title":"Real-World Analogy:","text":"<p>Imagine you've ordered food online.</p> <ul> <li>You place the order (this is like creating the Observable).</li> <li>The system doesn't start processing your order until you actually confirm it (like subscribing).</li> <li>Then, you get updates over time:</li> <li>\"Order received\" (first value)</li> <li>\"Restaurant is preparing your food\" (second value)</li> <li>\"Delivery partner assigned\" (third value)</li> <li>\"Food is on the way\" (fourth value)</li> <li>\"Delivered\" (fifth value, and maybe the stream *completes here*)</li> <li>If something goes wrong (e.g., restaurant cancels), you get an error notification (error).</li> <li>You can choose to stop receiving notifications if you want (unsubscribe).</li> </ul>"},{"location":"observable/#how-its-used-in-angular-examples","title":"How it's used in Angular (Examples):","text":"<ol> <li> <p>Fetching Data with <code>HttpClient</code>: This is the most common use case. When you make an HTTP request using Angular's <code>HttpClient</code>, it returns an Observable. You subscribe to this Observable to get the response from the server.</p> </li> <li> <p>Reactive Forms: Listening to changes in form input values (<code>valueChanges</code>) or status (<code>statusChanges</code>).</p> </li> <li>Router Events: Subscribing to events from the Angular Router to know when navigation starts, ends, or fails.</li> </ol> <p>In simple terms, an Observable is a powerful way to handle sequences of events or data over time in a manageable way. You subscribe to listen, receive values/errors, and can unsubscribe when you're done.</p>"},{"location":"observable/#service-dataservicets","title":"Service (<code>data.service.ts</code>):","text":"<pre><code>import { Injectable, inject } from \"@angular/core\";\nimport { HttpClient } from \"@angular/common/http\";\nimport { Observable } from \"rxjs\";\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class DataService {\n  private readonly http = inject(HttpClient);\n  private readonly apiUrl = \"https://api.example.com/items\";\n\n  getItems(): Observable&lt;any[]&gt; {\n    return this.http.get&lt;any[]&gt;(this.apiUrl);\n  }\n}\n</code></pre>"},{"location":"observable/#component-my-componentcomponentts","title":"Component (<code>my-component.component.ts</code>):","text":"<pre><code>import { Component, inject, effect } from \"@angular/core\";\nimport { DataService } from \"./data.service\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\n\n@Component({\n  selector: \"app-my-component\",\n  template: `\n    &lt;ul&gt;\n      &lt;li *ngFor=\"let item of items\"&gt;{{ item.name }}&lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;div *ngIf=\"errorMsg\"&gt;{{ errorMsg }}&lt;/div&gt;\n  `,\n})\nexport class MyComponentComponent {\n  private readonly dataService = inject(DataService);\n  items: any[] = [];\n  errorMsg = \"\";\n\n  constructor() {\n    this.dataService\n      .getItems()\n      .pipe(takeUntilDestroyed())\n      .subscribe({\n        next: (data) =&gt; {\n          this.items = data;\n          console.log(\"Data received:\", data);\n        },\n        error: (error) =&gt; {\n          this.errorMsg = \"Failed to load items.\";\n          console.error(\"Error fetching items:\", error);\n        },\n        complete: () =&gt; {\n          console.log(\"Finished fetching items.\");\n        },\n      });\n  }\n}\n</code></pre>"},{"location":"observer/","title":"Observer","text":"<p>An Observer is the consumer of the values delivered by an Observable. It's the \"thing\" that listens to the stream and knows what to do when a new value, an error, or a completion signal arrives.</p> <p>Think of it like this:</p> <ul> <li>Observable: The radio station broadcasting music (the stream).</li> <li>Observer: Your radio receiver at home, which listens to the broadcast and plays the music through its speakers (consumes the stream).</li> </ul>"},{"location":"observer/#structure-of-an-observer","title":"Structure of an Observer:","text":"<p>An Observer is typically an object literal (a plain JavaScript object) that can have up to three methods (or \"callbacks\"):</p> <ol> <li><code>next(value)</code>: This method is called whenever the Observable emits a new value. This is where you put the code to handle the actual data you receive. You might update a variable, display something on the screen, etc. This can be called zero, one, or multiple times.</li> <li><code>error(err)</code>: This method is called if the Observable fails or encounters an error. The error object is passed as an argument. Once <code>error()</code> is called, the Observable stops, and neither <code>next()</code> nor <code>complete()</code> will be called anymore. This is where you'd handle error conditions, maybe show an error message to the user.</li> <li><code>complete()</code>: This method is called when the Observable successfully finishes emitting all its values and won't emit anything further. After <code>complete()</code> is called, <code>next()</code> and <code>error()</code> will not be called. This is useful for knowing when a stream has finished gracefully (e.g., after an HTTP request successfully returns its response).</li> </ol> <p>How it connects to Observables:</p> <p>You connect an Observer to an Observable using the Observable's <code>.subscribe()</code> method. You pass the Observer object to <code>.subscribe()</code>.</p> <p>Real-World Analogy (Continuing the food delivery):</p> <p>You are the Observer watching the delivery app.</p> <ul> <li><code>next(update)</code>: Your action when you see a status update like \"Preparing\" or \"Out for delivery\". You might just read it (<code>console.log(update)</code>), or maybe you feel relieved (<code>this.status = update</code>).</li> <li><code>error(problem)</code>: Your action when you see \"Order Cancelled by Restaurant\". You might feel annoyed (<code>console.error(problem)</code>) and decide to order from somewhere else (<code>this.showError('Order failed: ' + problem)</code>).</li> <li><code>complete()</code>: Your action when you see \"Delivered\". You might think, \"Great, food's here!\" (<code>console.log('Food has arrived!')</code>).</li> </ul>"},{"location":"observer/#code-example-using-the-previous-httpclient-example","title":"Code Example (using the previous <code>HttpClient</code> example):","text":"<p>In the <code>MyComponentComponent</code> example from before, the object we passed to <code>this.dataSubscription = this.dataService.getItems().subscribe(...)</code> is the Observer:</p> <pre><code>// ... inside ngOnInit() of MyComponentComponent ...\n\nthis.dataSubscription = this.dataService.getItems().subscribe(\n  // This object is the Observer\n  {\n    // Handler for new data values\n    next: (data) =&gt; {\n      this.items = data;\n      console.log(\"Data received:\", data);\n    },\n    // Handler for errors\n    error: (error) =&gt; {\n      this.errorMsg = \"Failed to load items.\";\n      console.error(\"Error fetching items:\", error);\n    },\n    // Handler for completion\n    complete: () =&gt; {\n      console.log(\"Finished fetching items.\");\n    },\n  }\n);\n</code></pre> <p>Simplified Syntax:</p> <p>You don't always need to provide all three methods. RxJS allows you to pass callback functions directly to <code>subscribe()</code>:</p> <ul> <li>Just <code>next</code>: <pre><code>myObservable.subscribe((data) =&gt; console.log(data));\n</code></pre></li> <li><code>next</code> and <code>error</code>: <pre><code>myObservable.subscribe(\n  (data) =&gt; console.log(data), // next handler\n  (err) =&gt; console.error(err) // error handler\n);\n</code></pre></li> <li><code>next</code>, <code>error</code>, and <code>complete</code>: <pre><code>myObservable.subscribe(\n  (data) =&gt; console.log(data), // next handler\n  (err) =&gt; console.error(err), // error handler\n  () =&gt; console.log(\"Done!\") // complete handler\n);\n</code></pre></li> </ul> <p>So, in short: The Observer is the set of callbacks (next, error, complete) that you provide to the <code>subscribe()</code> method to react to the values and notifications emitted by an Observable.</p>"},{"location":"promise-vs-observable/","title":"Promise Vs Observable","text":"<p>Let's break down the key differences between Observables (from RxJS) and Promises (native JavaScript). While both deal with asynchronous operations, they have fundamental differences in how they work and what they're capable of.</p> <p>Here's a comparison table and explanations:</p> Feature Promise Observable Values Emitted One value (or one rejection) Multiple values over time (or error/complete) Execution Eager: Starts immediately upon creation Lazy: Starts only when subscribed to Cancellable? No (standard Promises aren't cancellable) Yes (via Unsubscription) Operators Limited (<code>.then()</code>, <code>.catch()</code>, <code>.finally()</code>) Rich set of operators (map, filter, retry, etc.) Use Cases Single async events (HTTP requests, timers) Streams of events, complex async flows, state Primary Library Native JavaScript ES6+ RxJS library (often used with Angular)"},{"location":"promise-vs-observable/#explanation-of-differences","title":"Explanation of Differences","text":"<ol> <li> <p>Single vs. Multiple Values:</p> <ul> <li>Promise: Designed to handle a single asynchronous event that will eventually succeed (resolve with a value) or fail (reject with an error). Once a Promise settles (resolves or rejects), it's done. It will never emit another value.</li> <li>Analogy: Ordering a specific package online. You wait, and eventually, you get that one package (resolve) or a notification it couldn't be delivered (reject). The transaction is then over.</li> <li>Observable: Represents a stream or sequence of values arriving over time. It can emit zero, one, or multiple values. It can also signal an error or completion.</li> <li>Analogy: Subscribing to a newsletter or a YouTube channel. You might receive multiple emails/videos over days or weeks (multiple <code>next</code> emissions). You could also get an error notification, or the channel might eventually stop publishing (complete).</li> </ul> </li> <li> <p>Eager vs. Lazy Execution:</p> <ul> <li>Promise: A Promise starts executing its asynchronous operation the moment it is created. Calling <code>.then()</code> doesn't trigger the operation; it just registers what to do when the already-running operation finishes.</li> <li>Example: <code>const myPromise = new Promise(/* executor starts now */);</code></li> <li>Observable: An Observable is lazy. The code inside it (e.g., the function making an HTTP call) doesn't run until someone actually subscribes to it using <code>.subscribe()</code>. Each subscription typically triggers a new, independent execution. (Operators like <code>shareReplay</code> modify this to share executions).</li> <li>Example: <code>const myObservable = new Observable(/* code here runs only on subscribe */); myObservable.subscribe(); // Execution starts now.</code></li> </ul> </li> <li> <p>Cancellable:</p> <ul> <li>Promise: Standard Promises don't have a built-in <code>.cancel()</code> method. Once you create a Promise and its operation starts, there's no standard way to tell it, \"Stop what you're doing, I don't need the result anymore.\" (Though browser APIs like <code>AbortController</code> can sometimes be used to cancel the underlying operation, like an <code>fetch</code> request, which then causes the Promise to reject).</li> <li>Observable: Observables are cancellable via their <code>Subscription</code> object. When you <code>subscribe()</code>, you get back a <code>Subscription</code>. Calling <code>subscription.unsubscribe()</code> signals to the Observable that the subscriber is no longer interested. This often triggers cleanup logic within the Observable (like clearing intervals or cancelling HTTP requests via <code>takeUntilDestroyed</code> or similar mechanisms) and stops further emissions to that subscriber.</li> </ul> </li> <li> <p>Operators:</p> <ul> <li>Promise: Has basic chaining with <code>.then()</code> (for success), <code>.catch()</code> (for error), and <code>.finally()</code> (for cleanup). You can also use <code>Promise.all()</code>, <code>Promise.race()</code>, etc., for combining promises.</li> <li>Observable: Comes with the vast RxJS library of operators (<code>map</code>, <code>filter</code>, <code>reduce</code>, <code>retry</code>, <code>retryWhen</code>, <code>debounceTime</code>, <code>switchMap</code>, <code>mergeMap</code>, <code>combineLatest</code>, <code>withLatestFrom</code>, <code>shareReplay</code>, <code>timeout</code>, <code>find</code>, <code>delay</code>, <code>tap</code>, etc.). These operators allow for powerful manipulation, combination, and control of asynchronous data streams in a declarative way.</li> </ul> </li> </ol>"},{"location":"promise-vs-observable/#when-to-use-which-general-guidelines","title":"When to Use Which (General Guidelines)","text":"<p>Use Promises when:</p> <ul> <li>You're dealing with a single, one-off asynchronous operation (like a typical HTTP GET or POST request where you expect one response).</li> <li>You're working with native browser APIs or libraries that return Promises.</li> <li>The complexity doesn't warrant pulling in the full RxJS library.</li> </ul> <p>Use Observables when:</p> <ul> <li>You need to handle streams of data arriving over time (WebSocket messages, user input events like keystrokes or mouse movements, repeated interval emissions).</li> <li>You need the advanced transformation, combination, or control capabilities provided by RxJS operators (retrying, debouncing, throttling, complex filtering/mapping, etc.).</li> <li>You need the ability to cancel asynchronous operations cleanly.</li> <li>You are working heavily within the Angular framework, which uses Observables extensively (e.g., <code>HttpClient</code>, <code>Router</code> events, <code>EventEmitter</code>).</li> </ul> <p>In modern Angular, while you can use Promises, Observables are generally preferred for asynchronous operations, especially when dealing with framework features or requiring more complex stream manipulation, due to their power, flexibility, and cancellable nature.</p>"},{"location":"Operators/RxJS-operators/","title":"RxJS operators","text":"<p>RxJS operators are functions that enable you to manipulate, combine, filter, and transform the data streams (Observables) in powerful ways. They take an Observable as input and return a new Observable.</p> <p>Think of operators as tools in a workshop for working with your asynchronous data streams. Instead of listing every single operator (there are many!), it's helpful to understand the general categories they fall into, based on what they do:</p>"},{"location":"Operators/RxJS-operators/#creation-operators","title":"Creation Operators","text":"<ul> <li>Purpose: To create new Observables from scratch or from existing data sources.</li> <li> <p>Examples:</p> <ul> <li><code>of</code>: Creates an Observable that emits the provided values sequentially and then completes.</li> <li><code>from</code>: Converts arrays, promises, iterables, or strings into Observables.</li> <li><code>fromEvent</code>: Creates an Observable from DOM events. (Hot Observable)</li> <li><code>interval</code>: Emits sequential numbers every specified interval (in milliseconds).</li> <li><code>timer</code>: Emits one value after an initial delay, then optionally emits subsequent values at a regular interval.</li> <li><code>throwError(() =&gt; new Error('Oops!'))</code>: Creates an Observable that immediately emits an error.</li> <li><code>EMPTY</code>: Creates an Observable that emits no items and immediately completes.</li> <li><code>NEVER</code>: Creates an Observable that never emits any items and never completes.</li> </ul> </li> </ul>"},{"location":"Operators/RxJS-operators/#transformation-operators","title":"Transformation Operators","text":"<ul> <li>Purpose: To change the format, type, or value of items emitted by an Observable.</li> <li> <p>Examples:</p> <ul> <li><code>map</code>: Applies a function to each emitted value.</li> <li><code>pluck('propertyName')</code>: Selects a nested property from each emitted object.</li> <li><code>scan((acc, value) =&gt; acc + value, 0)</code>: Accumulates values over time, like <code>Array.reduce</code>.</li> <li><code>mergeMap</code>: Projects each source value to an Observable and merges their emissions into a single stream. Good for handling multiple inner observables concurrently.</li> <li><code>switchMap</code>: Projects each source value to an Observable, but cancels the previous inner Observable when a new source value arrives. Ideal for scenarios like type-ahead searches where you only care about the latest request.</li> <li><code>concatMap</code>: Projects each source value to an Observable, but waits for the previous inner Observable to    complete before subscribing to the next one. Ensures order.</li> <li><code>bufferTime(1000)</code>: Collects emitted values into arrays over a specified time period.</li> <li><code>groupBy(item =&gt; item.category)</code>: Groups items emitted by the source Observable based on a key.</li> </ul> </li> </ul>"},{"location":"Operators/RxJS-operators/#filtering-operators","title":"Filtering Operators","text":"<ul> <li>Purpose: To selectively emit values from a source Observable based on certain criteria.</li> <li> <p>Examples:</p> <ul> <li><code>filter</code>: Emits only the values that satisfy a condition.</li> <li><code>first</code>: Emits only the first value (or the first value satisfying a condition) and then completes.</li> <li><code>last</code>: Emits only the last value (or the last value satisfying a condition) when the source completes.</li> <li><code>take</code>: Emits the first N values and then completes.</li> <li><code>takeUntil</code>: Emits values until a second <code>notifier$</code> Observable emits. Very useful for unsubscribing/completing streams    (e.g., when a component is destroyed).</li> <li><code>skip</code>: Skips the first N values.</li> <li><code>debounceTime</code>: Emits a value only after a specified time has passed without another source emission. Useful for rate-limiting     input events (like search inputs).</li> <li><code>distinctUntilChanged</code>: Emits only when the current value is different from the previous one.</li> </ul> </li> </ul>"},{"location":"Operators/RxJS-operators/#combination-operators","title":"Combination Operators","text":"<ul> <li>Purpose: To combine multiple source Observables into a single Observable.</li> <li> <p>Examples:</p> <ul> <li><code>combineLatest</code>: When any source Observable emits, it combines the latest values from all sources and emits     the combined result (usually as an array). Requires all sources to have emitted at least once.</li> <li><code>zip</code>: Combines values from source Observables pairwise. Waits for each source to emit a value at the corresponding     index before emitting the combined pair.</li> <li><code>forkJoin</code>: Waits for all source Observables to complete and then emits an array containing the last value    emitted by each source. Good for running parallel asynchronous operations and getting all results at the end.</li> <li><code>merge(obs1$, obs2$)</code>: Subscribes to all source Observables and simply passes through any value emitted by any of them as soon as     it arrives. Order depends on timing.</li> <li><code>concat(obs1$, obs2$)</code>: Subscribes to the first Observable, emits all its values, and only then subscribes to the second    Observable, emits its values, and so on. Preserves order strictly.</li> <li><code>race(obs1$, obs2$)</code>: Mirrors the first Observable (either <code>obs1$</code> or <code>obs2$</code>) to emit a value. Ignores the other(s).</li> </ul> </li> </ul>"},{"location":"Operators/RxJS-operators/#error-handling-operators","title":"Error Handling Operators","text":"<ul> <li>Purpose: To gracefully handle errors that might occur in an Observable sequence.</li> <li> <p>Examples:</p> <ul> <li><code>catchError</code>: Catches errors from the source Observable and either returns a replacement Observable (e.g., emitting a default value) or re-throws the error (or a new one).</li> <li><code>retry</code>: Re-subscribes to the source Observable up to N times if it encounters an error.</li> <li><code>retryWhen</code>: Re-subscribes based on logic defined in a notifier Observable (e.g., retry after a delay).</li> </ul> </li> </ul>"},{"location":"Operators/RxJS-operators/#utility-operators","title":"Utility Operators","text":"<ul> <li>Purpose: Miscellaneous operators useful for debugging, controlling timing, or other side effects.</li> <li> <p>Examples:</p> <ul> <li><code>tap</code>: Perform side effects (like logging) for each emission without modifying the stream itself. (Formerly known as <code>do</code>).</li> <li><code>delay</code>: Delays the emission of each item by a specified time.</li> <li><code>timeout</code>: Emits an error if the source Observable doesn't emit a value within a specified time.</li> <li><code>finalize</code>: Executes a callback function when the source Observable completes or errors. Good for cleanup logic.</li> <li><code>toArray()</code>: Collects all source emissions into a single array and emits that array when the source completes.</li> </ul> </li> </ul>"},{"location":"Operators/RxJS-operators/#multicasting-operators","title":"Multicasting Operators","text":"<ul> <li>Purpose: To share a single subscription to an underlying Observable among multiple subscribers. This is key for turning Cold Observables Hot or optimizing shared resources.</li> <li> <p>Examples:</p> <ul> <li><code>share</code>: Shares a single subscription but doesn't necessarily replay past values. Subscription starts with the first subscriber and stops when the last one unsubscribes.</li> <li><code>shareReplay</code>: Shares a single subscription and replays the last <code>bufferSize</code> emissions to new subscribers. Often used with <code>bufferSize: 1</code> to share API calls. The underlying subscription might stay active even after subscribers leave, depending on configuration.</li> <li><code>publish()</code>, <code>multicast()</code>: Lower-level operators for more complex multicasting scenarios, often used with Subjects.</li> </ul> </li> </ul>"},{"location":"Operators/RxJS-operators/#conditional-and-boolean-operators","title":"Conditional and Boolean Operators","text":"<ul> <li>Purpose: To evaluate conditions across sequences or emit boolean values.</li> <li> <p>Examples:</p> <ul> <li><code>every(x =&gt; x &gt; 0)</code>: Emits <code>true</code> if all values satisfy the predicate, <code>false</code> otherwise, then completes.</li> <li><code>find(x =&gt; x === 5)</code>: Emits the first value that satisfies the predicate, then completes.</li> <li><code>isEmpty()</code>: Emits <code>true</code> if the source completes without emitting any values, <code>false</code> otherwise.</li> <li><code>defaultIfEmpty('default')</code>: Emits a default value if the source completes without emitting anything.</li> </ul> </li> </ul> <p>Understanding these categories helps you navigate the RxJS library and choose the right tool for transforming, filtering, combining, or managing your asynchronous data streams effectively in Angular applications.</p>"},{"location":"Operators/Combination/combineLatest/","title":"combineLatest","text":"<p>The <code>combineLatest()</code> operator is used when you have multiple streams of data (Observables) and you want to combine their latest values into a single stream.</p> <p>Think of it like this: You're waiting for several pieces of information to arrive. <code>combineLatest()</code> waits until it has received at least one piece of information from every source it's watching. Once it has that initial set, it gives you an array containing the latest value from each source.</p> <p>After that initial combination, any time any one of the sources sends out a new piece of information, <code>combineLatest()</code> immediately sends out a new array containing that new value along with the most recent values it remembers from all the other sources.</p>"},{"location":"Operators/Combination/combineLatest/#key-characteristics","title":"Key Characteristics","text":"<ol> <li>Waits for Initial Values: It won't emit anything until all input Observables have emitted at least one value.</li> <li>Emits Latest Combination: Once initialized, it emits an array containing the most recent value from each input Observable.</li> <li>Reacts to Any Input: As soon as any of the input Observables emits a new value, <code>combineLatest</code> emits a new array with the updated combination.</li> </ol>"},{"location":"Operators/Combination/combineLatest/#real-world-analogy","title":"Real-World Analogy","text":"<p>Imagine a dashboard displaying:</p> <ul> <li>The current stock price for \"Company A\".</li> <li>The current user's selected currency (e.g., USD, EUR, INR).</li> </ul> <p>You need both the latest price and the selected currency to display the price correctly formatted.</p> <ul> <li><code>combineLatest()</code> would wait until it receives the first stock price update AND the first currency selection.</li> <li>Once it has both, it emits <code>[latestPrice, latestCurrency]</code>.</li> <li>If the stock price updates, it immediately emits <code>[newPrice, latestCurrency]</code>.</li> <li>If the user changes the currency, it immediately emits <code>[latestPrice, newCurrency]</code>.</li> </ul>"},{"location":"Operators/Combination/combineLatest/#angular-example-combining-route-parameter-and-user-settings","title":"Angular Example: Combining Route Parameter and User Settings","text":"<p>Let's say you have a component that displays product details. The product ID comes from the route URL, and you also have a user setting for whether to show prices in bold.</p> <pre><code>import { Component, OnInit, inject } from \"@angular/core\";\nimport { ActivatedRoute } from \"@angular/router\";\nimport { combineLatest, Observable, timer } from \"rxjs\";\nimport {\n  map,\n  switchMap,\n  distinctUntilChanged,\n  filter,\n  delay,\n} from \"rxjs/operators\";\nimport { Injectable } from \"@angular/core\";\nimport { of } from \"rxjs\";\n\n@Injectable({ providedIn: \"root\" })\nexport class ProductService {\n  getProduct(id: string): Observable&lt;any&gt; {\n    console.log(`API: Fetching product ${id}`);\n    return of({\n      id: id,\n      name: `Product ${id}`,\n      price: Math.random() * 100,\n    }).pipe(delay(300));\n  }\n}\n\n@Injectable({ providedIn: \"root\" })\nexport class UserSettingsService {\n  getSettings(): Observable&lt;{ boldPrice: boolean }&gt; {\n    return timer(0, 5000).pipe(map((i) =&gt; ({ boldPrice: i % 2 === 0 })));\n  }\n}\n\n@Component({\n  selector: \"app-product-detail\",\n  template: `\n    &lt;div *ngIf=\"data$ | async as data\"&gt;\n      &lt;h2&gt;{{ data.product.name }}&lt;/h2&gt;\n      &lt;p [style.fontWeight]=\"data.settings.boldPrice ? 'bold' : 'normal'\"&gt;\n        Price: {{ data.product.price | currency }}\n      &lt;/p&gt;\n    &lt;/div&gt;\n    &lt;p *ngIf=\"!(data$ | async)\"&gt;Loading product details...&lt;/p&gt;\n  `,\n})\nexport class ProductDetailComponent implements OnInit {\n  private route = inject(ActivatedRoute);\n  private productService = inject(ProductService);\n  private userSettingsService = inject(UserSettingsService);\n\n  data$!: Observable&lt;{ product: any; settings: { boldPrice: boolean } }&gt;;\n\n  ngOnInit() {\n    const productId$ = this.route.paramMap.pipe(\n      map((params) =&gt; params.get(\"productId\")),\n      filter((id): id is string =&gt; !!id),\n      distinctUntilChanged()\n    );\n\n    const settings$ = this.userSettingsService.getSettings();\n\n    this.data$ = combineLatest([productId$, settings$]).pipe(\n      switchMap(([id, settings]) =&gt;\n        this.productService\n          .getProduct(id)\n          .pipe(map((product) =&gt; ({ product, settings })))\n      )\n    );\n  }\n}\n</code></pre> <p>In this example:</p> <ol> <li>We get the <code>productId</code> from the route parameters. <code>distinctUntilChanged</code> prevents unnecessary work if the route emits the same ID multiple times.</li> <li>We get the <code>settings</code> from a service.</li> <li><code>combineLatest</code> waits for both the first valid <code>productId</code> and the first <code>settings</code> emission.</li> <li>When both are available, or when either the <code>productId</code> changes or the <code>settings</code> update, <code>combineLatest</code> emits <code>[latestId, latestSettings]</code>.</li> <li><code>switchMap</code> takes this latest combination. It uses the <code>latestId</code> to fetch the corresponding product data. If the <code>productId</code> changes while a previous product fetch is still in progress, <code>switchMap</code> cancels the old fetch and starts a new one for the new ID.</li> <li>Finally, we <code>map</code> the result to create an object <code>{ product, settings }</code> that's easy to use in the template with the <code>async</code> pipe. The template automatically updates whenever <code>data$</code> emits a new object, whether due to a product change or a setting change.</li> </ol>"},{"location":"Operators/Combination/combineLatest/#summary","title":"Summary","text":"<p>use <code>combineLatest()</code> when you need to react to changes from multiple independent sources and always need the most recent value from each of them to perform a calculation or update the UI.</p>"},{"location":"Operators/Combination/forkJoin/","title":"forkJoin","text":"<p><code>forkJoin()</code> is used when you have a group of Observables (often representing asynchronous operations like API calls) and you want to wait until all of them have completed before you get the results.</p> <p>Think of it like starting several independent tasks (e.g., downloading multiple files, making several API requests). <code>forkJoin</code> waits patiently until every single one of those tasks signals \"I'm finished!\". Once the last task completes, <code>forkJoin</code> emits a single value, which is an array containing the very last value emitted by each of the input Observables, in the same order you provided them.</p>"},{"location":"Operators/Combination/forkJoin/#key-characteristics","title":"Key Characteristics","text":"<ol> <li>Waits for Completion: It doesn't emit anything until every input Observable finishes (completes).</li> <li>Parallel Execution: It subscribes to all input Observables immediately, allowing them to run in parallel.</li> <li>Single Emission: It emits only one value (or an error).</li> <li>Array of Last Values: The emitted value is an array containing the last value from each input Observable.</li> <li>Error Behavior: If any of the input Observables error out, <code>forkJoin</code> immediately errors out as well. It will not wait for the other Observables to complete and will not emit the array of results.</li> </ol>"},{"location":"Operators/Combination/forkJoin/#real-world-analogy","title":"Real-World Analogy","text":"<p>Imagine you're ordering dinner from three different places via delivery apps:</p> <ul> <li>App 1: Pizza</li> <li>App 2: Salad</li> <li>App 3: Drinks</li> </ul> <p>You want to start eating only when everything has arrived. <code>forkJoin</code> is like waiting by the door. It doesn't matter if the pizza arrives first, or the drinks. You only care about the moment the last delivery person arrives. At that exact moment, <code>forkJoin</code> gives you the complete meal: <code>[Pizza, Salad, Drinks]</code>.</p> <p>However, if any single order fails (e.g., the pizza place cancels), <code>forkJoin</code> immediately tells you there's a problem (\"Error: Pizza order cancelled!\") and you don't get the combined results.</p> <p>Handling Errors within <code>forkJoin</code>:</p> <p>Because <code>forkJoin</code> fails completely if any input stream errors, you often want to handle potential errors within each input stream before they reach <code>forkJoin</code>. You can use the <code>catchError</code> operator for this, typically returning a fallback value (like <code>null</code>, <code>undefined</code>, or an empty object/array) so that the stream still completes successfully.</p> <pre><code>import { forkJoin, of, timer, throwError } from \"rxjs\";\nimport { delay, catchError } from \"rxjs/operators\";\n\nconst successful$ = of(\"Success Data\").pipe(delay(500));\n\n// Simulate an API call that fails\nconst failing$ = timer(1500).pipe(\n  delay(100), // Add small delay just for simulation\n  map(() =&gt; {\n    throw new Error(\"Network Error\");\n  }) // Simulate error\n);\n\n// --- Without error handling inside ---\n// forkJoin([successful$, failing$]).subscribe({\n//   next: results =&gt; console.log('This will not run'),\n//   error: err =&gt; console.error('forkJoin failed because one stream errored:', err.message) // This will run\n// });\n\n// --- With error handling inside the failing stream ---\nconsole.log(\"\\nStarting forkJoin with internal error handling...\");\nconst failingHandled$ = failing$.pipe(\n  catchError((error) =&gt; {\n    console.warn(`Caught error in stream: ${error.message}. Returning null.`);\n    // Return an Observable that emits a fallback value and COMPLETES\n    return of(null);\n  })\n);\n\nforkJoin([successful$, failingHandled$]).subscribe({\n  next: (results) =&gt; {\n    // This will run after ~1.6 seconds\n    console.log(\"forkJoin completed with results:\", results); // results: ['Success Data', null]\n  },\n  error: (err) =&gt; {\n    console.error(\"This should not run if errors are handled internally:\", err);\n  },\n});\n\n/*\nExpected Output:\nStarting forkJoin with internal error handling...\n(after ~1.6 seconds)\nCaught error in stream: Network Error. Returning null.\nforkJoin completed with results: [ 'Success Data', null ]\n*/\n</code></pre>"},{"location":"Operators/Combination/forkJoin/#angular-example-loading-initial-page-data","title":"Angular Example: Loading Initial Page Data","text":"<p><code>forkJoin</code> is perfect for loading all the essential data a component needs before displaying anything.</p> <pre><code>import { Component, OnInit } from \"@angular/core\";\nimport { HttpClient } from \"@angular/common/http\";\nimport { forkJoin, of } from \"rxjs\";\nimport { catchError } from \"rxjs/operators\";\n\ninterface UserProfile {\n  name: string;\n  email: string;\n}\ninterface UserPreferences {\n  theme: string;\n  language: string;\n}\ninterface InitialNotifications {\n  count: number;\n  messages: string[];\n}\n\n@Component({\n  selector: \"app-profile-page\",\n  template: `\n    &lt;div *ngIf=\"!isLoading &amp;&amp; !errorMsg\"&gt;\n      &lt;h2&gt;Profile: {{ profile?.name }}&lt;/h2&gt;\n      &lt;p&gt;Email: {{ profile?.email }}&lt;/p&gt;\n      &lt;p&gt;Theme: {{ preferences?.theme }}&lt;/p&gt;\n      &lt;p&gt;Notifications: {{ notifications?.count }}&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div *ngIf=\"isLoading\"&gt;Loading profile data...&lt;/div&gt;\n    &lt;div *ngIf=\"errorMsg\" style=\"color: red;\"&gt;{{ errorMsg }}&lt;/div&gt;\n  `,\n})\nexport class ProfilePageComponent implements OnInit {\n  isLoading = true;\n  errorMsg: string | null = null;\n\n  profile: UserProfile | null = null;\n  preferences: UserPreferences | null = null;\n  notifications: InitialNotifications | null = null;\n\n  constructor(private http: HttpClient) {}\n\n  ngOnInit() {\n    this.loadData();\n  }\n\n  loadData() {\n    this.isLoading = true;\n    this.errorMsg = null;\n\n    // Define the API calls - HttpClient observables complete automatically\n    const profile$ = this.http.get&lt;UserProfile&gt;(\"/api/profile\").pipe(\n      catchError((err) =&gt; {\n        console.error(\"Failed to load Profile\", err);\n        // Return fallback and let forkJoin continue\n        return of(null);\n      })\n    );\n\n    const preferences$ = this.http\n      .get&lt;UserPreferences&gt;(\"/api/preferences\")\n      .pipe(\n        catchError((err) =&gt; {\n          console.error(\"Failed to load Preferences\", err);\n          // Return fallback and let forkJoin continue\n          return of(null);\n        })\n      );\n\n    const notifications$ = this.http\n      .get&lt;InitialNotifications&gt;(\"/api/notifications\")\n      .pipe(\n        catchError((err) =&gt; {\n          console.error(\"Failed to load Notifications\", err);\n          // Return fallback and let forkJoin continue\n          return of({ count: 0, messages: [] }); // Example fallback\n        })\n      );\n\n    // Use forkJoin to wait for all requests\n    forkJoin([profile$, preferences$, notifications$]).subscribe(\n      ([profileResult, preferencesResult, notificationsResult]) =&gt; {\n        // This block runs when all API calls have completed (successfully or with handled errors)\n        console.log(\"All data received:\", {\n          profileResult,\n          preferencesResult,\n          notificationsResult,\n        });\n\n        // Check if essential data is missing\n        if (!profileResult || !preferencesResult) {\n          this.errorMsg =\n            \"Could not load essential profile data. Please try again later.\";\n        } else {\n          this.profile = profileResult;\n          this.preferences = preferencesResult;\n          this.notifications = notificationsResult; // Notifications might be optional or have a fallback\n        }\n\n        this.isLoading = false;\n      },\n      (err) =&gt; {\n        // This error handler is less likely to be hit if catchError is used inside,\n        // but good practice to have for unexpected issues.\n        console.error(\"Unexpected error in forkJoin:\", err);\n        this.errorMsg = \"An unexpected error occurred while loading data.\";\n        this.isLoading = false;\n      }\n    );\n  }\n}\n</code></pre> <p>In this example, the component makes three API calls. The <code>forkJoin</code> ensures that the loading indicator stays active until all three requests are finished. By using <code>catchError</code> inside each request, we prevent one failed request from stopping the others, and we can handle missing data appropriately in the <code>next</code> callback of <code>forkJoin</code>.</p>"},{"location":"Operators/Combination/forkJoin/#summary","title":"Summary","text":"<p>use <code>forkJoin</code> when you need to run several asynchronous operations (that eventually complete) in parallel and only want to proceed once you have the final result from all of them. Remember its strict error handling behavior and use <code>catchError</code> internally if necessary.</p>"},{"location":"Operators/Combination/withLatestFrom/","title":"withLatestFrom","text":"<p>Think of <code>withLatestFrom()</code> as an operator that lets one stream (the \"source\") peek at the most recent value from one or more other streams whenever the source stream emits something.</p> <ul> <li>Source Stream: This is the main Observable you attach <code>withLatestFrom()</code> to.</li> <li>Other Streams: These are the Observables you pass into <code>withLatestFrom()</code>.</li> <li>How it works: When the source stream emits a value, <code>withLatestFrom()</code> looks at the other streams and grabs their latest emitted value. It then combines the value from the source stream and the latest values from the other streams into an array.</li> <li>Important: It only emits when the source stream emits. If the other streams emit values but the source stream hasn't emitted since, <code>withLatestFrom()</code> does nothing. Also, it won't emit anything until all the provided streams (source and others) have emitted at least one value.</li> </ul>"},{"location":"Operators/Combination/withLatestFrom/#real-world-example-search-with-filters","title":"Real-World Example: Search with Filters","text":"<p>Imagine you have a search page for products. There's:</p> <ol> <li>A search input field where the user types their query.</li> <li>A dropdown menu to select a category filter (e.g., \"Electronics\", \"Clothing\", \"Home Goods\").</li> </ol> <p>You want to make an API call to fetch products whenever the user types in the search box (after a little pause, using <code>debounceTime</code>), but you need both the search term and the currently selected category filter to make the correct API request.</p> <ul> <li>The search term changes frequently. This will be our source stream (after debouncing).</li> <li>The category filter changes less often, maybe only when the user explicitly selects a new option. This will be our other stream.</li> </ul> <p>We want to trigger the search using the latest filter value at the moment the (debounced) search term is ready. <code>withLatestFrom()</code> is perfect for this.</p>"},{"location":"Operators/Combination/withLatestFrom/#code-snippet","title":"Code Snippet","text":"<p>Let's see how this looks in an Angular component:</p> <pre><code>import { Component, inject, DestroyRef, OnInit } from \"@angular/core\";\nimport { CommonModule } from \"@angular/common\";\nimport { ReactiveFormsModule, FormControl } from \"@angular/forms\";\nimport {\n  Subject,\n  debounceTime,\n  distinctUntilChanged,\n  withLatestFrom,\n  takeUntilDestroyed,\n  startWith,\n} from \"rxjs\";\n\n@Component({\n  selector: \"app-product-search\",\n  standalone: true,\n  imports: [CommonModule, ReactiveFormsModule],\n  template: `\n    &lt;div&gt;\n      &lt;label for=\"search\"&gt;Search:&lt;/label&gt;\n      &lt;input id=\"search\" type=\"text\" [formControl]=\"searchTermControl\" /&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;label for=\"category\"&gt;Category:&lt;/label&gt;\n      &lt;select id=\"category\" [formControl]=\"categoryFilterControl\"&gt;\n        &lt;option value=\"all\"&gt;All&lt;/option&gt;\n        &lt;option value=\"electronics\"&gt;Electronics&lt;/option&gt;\n        &lt;option value=\"clothing\"&gt;Clothing&lt;/option&gt;\n        &lt;option value=\"home\"&gt;Home Goods&lt;/option&gt;\n      &lt;/select&gt;\n    &lt;/div&gt;\n\n    &lt;div *ngIf=\"searchResults\"&gt;\n      Searching for: \"{{ searchResults.term }}\" in category: \"{{\n        searchResults.category\n      }}\"\n    &lt;/div&gt;\n  `,\n})\nexport class ProductSearchComponent implements OnInit {\n  // --- Dependencies ---\n  private destroyRef = inject(DestroyRef); // For automatic unsubscription\n\n  // --- Form Controls ---\n  searchTermControl = new FormControl(\"\");\n  categoryFilterControl = new FormControl(\"all\"); // Default category\n\n  // --- Component State ---\n  searchResults: { term: string; category: string } | null = null;\n\n  ngOnInit(): void {\n    // --- Observables ---\n    // Source: Search term, debounced\n    const searchTerm$ = this.searchTermControl.valueChanges.pipe(\n      debounceTime(400), // Wait for 400ms pause in typing\n      distinctUntilChanged(), // Only emit if the value actually changed\n      startWith(this.searchTermControl.value || \"\") // Emit initial value immediately\n    );\n\n    // Other: Category filter\n    const categoryFilter$ = this.categoryFilterControl.valueChanges.pipe(\n      startWith(this.categoryFilterControl.value || \"all\") // Emit initial value immediately\n    );\n\n    // --- Combining with withLatestFrom ---\n    searchTerm$\n      .pipe(\n        withLatestFrom(categoryFilter$), // Combine search term with the LATEST category\n        takeUntilDestroyed(this.destroyRef) // Auto-unsubscribe when component is destroyed\n      )\n      .subscribe(([term, category]) =&gt; {\n        // This block runs ONLY when searchTerm$ emits (after debounce)\n        // It gets the emitted 'term' and the 'latest' value from categoryFilter$\n\n        // Ensure we have non-null values (FormControl can emit null)\n        const validTerm = term ?? \"\";\n        const validCategory = category ?? \"all\";\n\n        console.log(\n          `API Call Needed: Search for \"${validTerm}\" with filter \"${validCategory}\"`\n        );\n\n        // In a real app, you'd call your API service here:\n        // this.productService.search(validTerm, validCategory).subscribe(...)\n\n        // Update component state for display (example)\n        this.searchResults = { term: validTerm, category: validCategory };\n      });\n  }\n}\n</code></pre> <p>Explanation of the Code:</p> <ol> <li><code>searchTermControl</code> / <code>categoryFilterControl</code>: We use Angular's <code>FormControl</code> to manage the input and select elements.</li> <li><code>searchTerm$</code>: We get an Observable of the search term's changes using <code>valueChanges</code>. We apply:<ul> <li><code>debounceTime(400)</code>: To wait until the user stops typing for 400ms before considering the term stable.</li> <li><code>distinctUntilChanged()</code>: To avoid triggering searches if the debounced term is the same as the last one.</li> <li><code>startWith()</code>: To ensure the stream has an initial value so <code>withLatestFrom</code> can emit right away if the category also has a value. This makes the initial state work correctly.</li> </ul> </li> <li><code>categoryFilter$</code>: We get an Observable of the category changes using <code>valueChanges</code>. We also use <code>startWith()</code> here for the initial value.</li> <li><code>withLatestFrom(categoryFilter$)</code>: We pipe the <code>searchTerm$</code> (our source). When <code>searchTerm$</code> emits a value (after debouncing), <code>withLatestFrom</code> looks at <code>categoryFilter$</code> and gets its most recently emitted value.</li> <li><code>subscribe(([term, category]) =&gt; ...)</code>: The result is an array <code>[sourceValue, latestOtherValue]</code>. We destructure this into <code>term</code> and <code>category</code>. This callback function is executed only when the debounced search term changes. Inside, we have exactly what we need: the current search term and the latest selected category at that moment.</li> <li><code>takeUntilDestroyed(this.destroyRef)</code>: This is the modern Angular way to handle unsubscriptions. When the <code>ProductSearchComponent</code> is destroyed, this operator automatically completes the Observable stream, preventing memory leaks without manual cleanup.</li> </ol> <p>So, <code>withLatestFrom()</code> is incredibly useful when an action (like searching) depends on the latest state of other configuration or filter inputs at the exact moment the action is triggered.</p>"},{"location":"Operators/Combination/zip/","title":"zip","text":"<p>The <code>zip()</code> operator in RxJS is a combination operator. Its job is to combine multiple source Observables by waiting for each observable to emit a value at the same index, and then it emits an array containing those values paired together.</p>"},{"location":"Operators/Combination/zip/#analogy-the-zipper","title":"Analogy: The Zipper","text":"<p>Think of a clothing zipper. It has two sides (or more, if you imagine a multi-way zipper!). To close the zipper, teeth from both sides must align at the same position. <code>zip()</code> works the same way:</p> <ol> <li>It subscribes to all the source Observables you provide.</li> <li>It waits until the first value arrives from every source. It then emits these first values together in an array: <code>[firstValueA, firstValueB, ...]</code>.</li> <li>Then, it waits until the second value arrives from every source. It emits these second values together: <code>[secondValueA, secondValueB, ...]</code>.</li> <li>It continues this process, index by index (0, 1, 2,...).</li> <li>Crucially: If one source Observable completes before another, <code>zip()</code> will stop emitting new pairs as soon as it runs out of values from the shorter source to pair with. It needs a value from all sources for a given index to emit.</li> </ol>"},{"location":"Operators/Combination/zip/#why-use-zip","title":"Why Use <code>zip()</code>?","text":"<p>You use <code>zip()</code> when you have multiple streams and you need to combine their values based on their emission order or index. You specifically want the 1st item from stream A paired with the 1st from stream B, the 2nd with the 2nd, and so on.</p>"},{"location":"Operators/Combination/zip/#real-world-example-pairing-related-sequential-data","title":"Real-World Example: Pairing Related Sequential Data","text":"<p>Imagine you have two real-time data feeds:</p> <ol> <li><code>sensorA$</code> emits temperature readings every second.</li> <li><code>sensorB$</code> emits humidity readings every second, perfectly synchronized with sensor A.</li> </ol> <p>You want to process these readings as pairs (temperature and humidity for the same timestamp/interval). <code>zip</code> is perfect for this.</p> <p>Another scenario (less common for APIs, more for UI events or other streams): Suppose you want to pair every user click with a corresponding item from another list that gets populated sequentially. The first click pairs with the first item, the second click with the second, etc.</p>"},{"location":"Operators/Combination/zip/#code-snippet-example","title":"Code Snippet Example","text":"<p>Let's create a simple Angular component example using <code>zip</code>. We'll zip together values from two simple streams: one emitting letters ('A', 'B', 'C') quickly, and another emitting numbers (10, 20, 30, 40) more slowly.</p> <pre><code>import { Component, DestroyRef, inject, OnInit, signal } from \"@angular/core\";\nimport { zip, interval, of } from \"rxjs\";\nimport { map, take } from \"rxjs/operators\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\n\n@Component({\n  selector: \"app-zip-example\",\n  standalone: true,\n  template: `\n    &lt;h2&gt;RxJS zip() Example&lt;/h2&gt;\n    &lt;p&gt;Combining letters and numbers based on index:&lt;/p&gt;\n    &lt;ul&gt;\n      &lt;li *ngFor=\"let pair of zippedResult()\"&gt;{{ pair | json }}&lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;p&gt;\n      Note: The number stream had '40', but the letter stream completed after\n      'C', so zip stopped.\n    &lt;/p&gt;\n  `,\n  styles: [\n    `\n      li {\n        font-family: monospace;\n      }\n    `,\n  ],\n})\nexport class ZipExampleComponent implements OnInit {\n  private destroyRef = inject(DestroyRef);\n\n  zippedResult = signal&lt;Array&lt;[string, number]&gt;&gt;([]); // Signal to hold the result\n\n  ngOnInit() {\n    // Source 1: Emits 'A', 'B', 'C' one after another immediately\n    const letters$ = of(\"A\", \"B\", \"C\");\n\n    // Source 2: Emits 10, 20, 30, 40 every 500ms\n    const numbers$ = interval(500).pipe(\n      map((i) =&gt; (i + 1) * 10), // Map index 0, 1, 2, 3 to 10, 20, 30, 40\n      take(4) // Only take the first 4 values\n    );\n\n    // Zip them together\n    zip(letters$, numbers$)\n      .pipe(\n        // zip emits arrays like [string, number]\n        takeUntilDestroyed(this.destroyRef) // Auto-unsubscribe\n      )\n      .subscribe({\n        next: (value) =&gt; {\n          // Update the signal with the latest pair\n          // NOTE: For signals, it's often better to collect all results\n          // if the stream completes quickly, or update progressively.\n          // Here we'll just append for demonstration.\n          this.zippedResult.update((current) =&gt; [...current, value]);\n          console.log(\"Zipped value:\", value);\n        },\n        complete: () =&gt; {\n          console.log(\"Zip completed because the letters$ stream finished.\");\n        },\n        error: (err) =&gt; {\n          console.error(\"Zip error:\", err);\n        },\n      });\n  }\n}\n</code></pre> <p>Explanation of the Code:</p> <ol> <li><code>letters$</code> emits 'A', 'B', 'C' and then completes.</li> <li><code>numbers$</code> starts emitting 10 (at 500ms), 20 (at 1000ms), 30 (at 1500ms), 40 (at 2000ms).</li> <li><code>zip</code> waits:<ul> <li>It gets 'A' immediately, but waits for <code>numbers$</code> to emit.</li> <li>At 500ms, <code>numbers$</code> emits 10. <code>zip</code> now has the first value from both ('A', 10) -&gt; Emits <code>['A', 10]</code>.</li> <li>It gets 'B' immediately, waits for <code>numbers$</code>.</li> <li>At 1000ms, <code>numbers$</code> emits 20. <code>zip</code> has the second value from both ('B', 20) -&gt; Emits <code>['B', 20]</code>.</li> <li>It gets 'C' immediately, waits for <code>numbers$</code>.</li> <li>At 1500ms, <code>numbers$</code> emits 30. <code>zip</code> has the third value from both ('C', 30) -&gt; Emits <code>['C', 30]</code>.</li> </ul> </li> <li><code>letters$</code> has now completed. Even though <code>numbers$</code> emits 40 at 2000ms, <code>zip</code> cannot find a corresponding 4th value from <code>letters$</code>, so it stops and completes.</li> </ol>"},{"location":"Operators/Combination/zip/#zip-vs-other-combination-operators","title":"<code>zip()</code> vs. Other Combination Operators","text":"<ul> <li><code>combineLatest</code>: Emits an array of the latest values from each source whenever any source emits. Doesn't care about index, just the most recent value from all participants.</li> <li><code>forkJoin</code>: Waits for all source observables to complete, then emits a single array containing the last value emitted by each source. Useful for running parallel one-off tasks (like multiple HTTP requests) and getting all results together at the end.</li> </ul> <p>Use <code>zip()</code> specifically when the order and pairing by index (1st with 1st, 2nd with 2nd, etc.) is what you need.</p>"},{"location":"Operators/Creation/empty-never/","title":"Empty Vs Never","text":"<p>Let's clarify the difference between the RxJS constants <code>EMPTY</code> and <code>NEVER</code>. Both are simple, pre-defined Observable constants, but they represent very different stream behaviors, primarily concerning completion.</p> <p>Think of it like this: Both represent a stream that will never give you any data (no <code>next</code> emissions). The difference lies in whether they tell you they are finished or just stay silent forever.</p> <ol> <li> <p><code>EMPTY</code></p> <ul> <li>What it does: Represents an Observable that emits zero items.</li> <li>Key Behavior: As soon as you subscribe to it, it immediately sends a <code>complete</code> notification.</li> <li>Analogy: It's like a function that returns immediately without doing anything (<code>return;</code>), or reading an empty file. It quickly signals \"I have nothing to give you, and I'm done.\"</li> <li>Use Case: Useful when you need an Observable that does nothing but signal successful completion right away. This is often helpful in conditional logic within higher-order mapping operators (like <code>switchMap</code>, <code>mergeMap</code>, <code>concatMap</code>). For example, if a condition isn't met, you might return <code>EMPTY</code> instead of making an API call, indicating that the operation for that specific trigger completed successfully without producing a value.</li> </ul> </li> <li> <p><code>NEVER</code></p> <ul> <li>What it does: Represents an Observable that emits zero items.</li> <li>Key Behavior: It never sends a <code>complete</code> notification and never sends an <code>error</code> notification. It remains silent indefinitely after subscription.</li> <li>Analogy: It's like a process that hangs forever without producing output or terminating, or a phone line that just keeps ringing and ringing without ever being answered or going to an error state. It signals \"I have nothing for you right now, and I might never have anything, and I'm certainly not finished.\"</li> <li>Use Case: Represents a stream that simply never emits or terminates. This can be useful in testing scenarios or when you want to keep a combination operator (like <code>race</code> or <code>combineLatest</code>) alive, even if one of its potential sources will never produce a relevant value or complete. It effectively keeps that \"slot\" open indefinitely without signalling completion or error. It can also be used intentionally to prevent parts of an Observable chain from completing.</li> </ul> </li> </ol>"},{"location":"Operators/Creation/empty-never/#direct-comparison","title":"Direct Comparison","text":"Feature <code>EMPTY</code> <code>NEVER</code> <code>next</code> emissions 0 0 <code>complete</code> Yes (immediately) No (never) <code>error</code> No (by default) No (never) Terminates? Yes (completes immediately) No (runs indefinitely)"},{"location":"Operators/Creation/empty-never/#code-snippet-demonstration","title":"Code Snippet Demonstration","text":"<pre><code>import { Component, OnInit, OnDestroy } from \"@angular/core\";\nimport { EMPTY, NEVER, Subscription } from \"rxjs\";\n\n@Component({\n  selector: \"app-empty-never-demo\",\n  template: `\n    &lt;h4&gt;EMPTY vs NEVER Demo&lt;/h4&gt;\n    &lt;p&gt;\n      Check the console log at ${new Date().toLocaleTimeString(\"en-IN\", {\n        timeZone: \"Asia/Kolkata\",\n      })} (IST).\n    &lt;/p&gt;\n    &lt;p&gt;EMPTY Status: {{ emptyStatus }}&lt;/p&gt;\n    &lt;p&gt;NEVER Status: {{ neverStatus }}&lt;/p&gt;\n  `,\n})\nexport class EmptyNeverDemoComponent implements OnInit, OnDestroy {\n  emptyStatus = \"Subscribing...\";\n  neverStatus = \"Subscribing...\";\n\n  private emptySub: Subscription | undefined;\n  private neverSub: Subscription | undefined;\n\n  ngOnInit(): void {\n    console.log(`--- Subscribing to EMPTY ---`);\n    this.emptySub = EMPTY.subscribe({\n      next: () =&gt; {\n        console.log(\"EMPTY: next (This will not be logged)\");\n        this.emptyStatus = \"Got next (unexpected)\";\n      },\n      error: (err) =&gt; {\n        console.error(\"EMPTY: error\", err);\n        this.emptyStatus = `Error: ${err}`;\n      },\n      complete: () =&gt; {\n        // This is called immediately!\n        console.log(\n          `EMPTY: complete! (Called immediately) at ${new Date().toLocaleTimeString()}`\n        );\n        this.emptyStatus = \"Completed immediately\";\n      },\n    });\n    // The line below will likely log 'Completed immediately' because EMPTY completes synchronously\n    console.log(\n      `Current EMPTY status after sync subscribe: ${this.emptyStatus}`\n    );\n\n    console.log(`\\n--- Subscribing to NEVER ---`);\n    this.neverSub = NEVER.subscribe({\n      next: () =&gt; {\n        console.log(\"NEVER: next (This will not be logged)\");\n        this.neverStatus = \"Got next (unexpected)\";\n      },\n      error: (err) =&gt; {\n        console.error(\"NEVER: error (This will not be logged)\");\n        this.neverStatus = `Error: ${err}`;\n      },\n      complete: () =&gt; {\n        // This is never called!\n        console.log(\"NEVER: complete! (This will never be logged)\");\n        this.neverStatus = \"Completed (unexpected)\";\n      },\n    });\n    // NEVER does nothing, so status remains 'Subscribing...'\n    console.log(\n      `Current NEVER status after sync subscribe: ${this.neverStatus}`\n    );\n\n    // Set a timeout just to show NEVER doesn't complete on its own\n    setTimeout(() =&gt; {\n      if (this.neverStatus === \"Subscribing...\") {\n        console.log(\n          \"\\nAfter 2 seconds, NEVER still hasn't emitted or completed.\"\n        );\n        this.neverStatus = \"Still running after 2s (as expected)\";\n      }\n    }, 2000);\n  }\n\n  ngOnDestroy(): void {\n    console.log(\"\\n--- Component Destroying ---\");\n    if (this.emptySub &amp;&amp; !this.emptySub.closed) {\n      // This check is usually false as EMPTY completes immediately\n      console.log(\"Unsubscribing from EMPTY (already closed likely).\");\n      this.emptySub.unsubscribe();\n    } else {\n      console.log(\"EMPTY subscription was already closed.\");\n    }\n\n    if (this.neverSub &amp;&amp; !this.neverSub.closed) {\n      // This is important for NEVER if the component is destroyed\n      console.log(\"Unsubscribing from NEVER.\");\n      this.neverSub.unsubscribe();\n    }\n  }\n}\n</code></pre>"},{"location":"Operators/Creation/empty-never/#summary","title":"Summary","text":"<p>Choose <code>EMPTY</code> when you need an Observable that does nothing but signals successful completion instantly.</p> <p>Choose <code>NEVER</code> when you need an Observable that does nothing and never signals completion or error.</p>"},{"location":"Operators/Creation/from/","title":"from","text":"<p>The <code>from()</code> operator is another creation operator, but its main purpose is to convert various other types of objects and data structures into an Observable. It's versatile and can handle things like:</p> <ul> <li>Arrays (or array-like objects like <code>NodeList</code>, <code>arguments</code>)</li> <li>Iterables (like <code>Map</code>, <code>Set</code>, or strings)</li> <li>Promises</li> <li>Other Observables (though this is less common as you usually just use the Observable directly)</li> </ul> <p>When given an array or iterable, <code>from()</code> emits each item from that collection one by one, in order, and then completes. When given a Promise, it waits for the Promise to resolve, emits the resolved value as its single <code>next</code> notification, and then completes. If the Promise rejects, <code>from()</code> emits an error notification.</p>"},{"location":"Operators/Creation/from/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Conversion: Its primary role is converting something else into an Observable.</li> <li>Single Argument: It takes only one argument \u2013 the object to convert.</li> <li>Emission Behavior:</li> <li>For arrays/iterables: Emits items synchronously, one by one.</li> <li>For Promises: Emits the resolved value asynchronously when the promise settles.</li> <li>Completes: It completes after emitting all items (from iterables) or the resolved value (from promises).</li> </ul>"},{"location":"Operators/Creation/from/#difference-from-of","title":"Difference from <code>of()</code>","text":"<p>This is a common point of confusion:</p> <ul> <li><code>of([1, 2, 3])</code>: Emits the entire array <code>[1, 2, 3]</code> as a single item.</li> <li><code>from([1, 2, 3])</code>: Emits <code>1</code>, then <code>2</code>, then <code>3</code> as three separate items.</li> </ul>"},{"location":"Operators/Creation/from/#real-world-example-scenarios","title":"Real-World Example Scenarios","text":"<ol> <li>Processing Array Items: You might fetch configuration data which arrives as a plain array, but you want to use RxJS operators (<code>map</code>, <code>filter</code>, etc.) to process each item in the array within a stream.</li> <li>Integrating Promises: You're working within an Angular/RxJS codebase, but need to interact with a browser API or a third-party JavaScript library that returns a <code>Promise</code>. <code>from()</code> lets you easily bring that promise-based result into your RxJS workflow.</li> </ol>"},{"location":"Operators/Creation/from/#code-snippet-1-using-from-with-an-array","title":"Code Snippet 1 (Using <code>from()</code> with an Array)","text":"<p>Let's say you have an array of user IDs and you want to create an Observable stream that emits each ID individually.</p> <pre><code>import { Component, OnInit } from \"@angular/core\";\nimport { from, Observable } from \"rxjs\"; // Import 'from'\nimport { map } from \"rxjs/operators\";\n\n@Component({\n  selector: \"app-user-id-processor\",\n  template: `\n    &lt;h4&gt;Processing User IDs:&lt;/h4&gt;\n    &lt;ul&gt;\n      &lt;li *ngFor=\"let processedId of processedUserIds$ | async\"&gt;\n        {{ processedId }}\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  `,\n})\nexport class UserIdProcessorComponent implements OnInit {\n  userIds: string[] = [\"user-001\", \"user-007\", \"user-101\"];\n  processedUserIds$: Observable&lt;string&gt; | undefined;\n\n  ngOnInit(): void {\n    console.log(\"Component initializing...\");\n\n    // Convert the userIds array into an Observable stream\n    const userIdStream$ = from(this.userIds);\n\n    // Example: Use RxJS operators on the stream from the array\n    this.processedUserIds$ = userIdStream$.pipe(\n      map((id) =&gt; `Processed: ${id.toUpperCase()}`) // Apply an operator to each emitted ID\n    );\n\n    console.log(\n      \"Observable created from array. Subscribing manually for demonstration...\"\n    );\n\n    this.processedUserIds$.subscribe({\n      next: (value) =&gt; {\n        // Called for each ID ('Processed: USER-001', 'Processed: USER-007', etc.)\n        console.log(\"Received processed ID:\", value);\n      },\n      error: (err) =&gt; {\n        console.error(\"Error:\", err); // Won't happen here\n      },\n      complete: () =&gt; {\n        // Called after the last ID is processed and emitted\n        console.log(\"User ID stream complete!\");\n      },\n    });\n    console.log(\"Subscription processing for array finished (synchronously).\");\n  }\n}\n</code></pre>"},{"location":"Operators/Creation/from/#code-snippet-2-using-from-with-a-promise","title":"Code Snippet 2 (Using <code>from()</code> with a Promise)","text":"<p>Imagine you need to use the browser's <code>Workspace</code> API (which returns a Promise) to get some data and integrate it into your component's Observable-based logic.</p> <pre><code>import { Component, OnInit } from \"@angular/core\";\nimport { from, Observable } from \"rxjs\"; // Import 'from'\nimport { switchMap, catchError, tap } from \"rxjs/operators\";\n\n@Component({\n  selector: \"app-promise-integrator\",\n  template: `\n    &lt;h4&gt;Data from Promise:&lt;/h4&gt;\n    &lt;div *ngIf=\"data$ | async as fetchedData\"&gt;\n      Data fetched: {{ fetchedData | json }}\n    &lt;/div&gt;\n    &lt;div *ngIf=\"errorMessage\"&gt;Error: {{ errorMessage }}&lt;/div&gt;\n  `,\n})\nexport class PromiseIntegratorComponent implements OnInit {\n  data$: Observable&lt;any&gt; | undefined;\n  errorMessage: string = \"\";\n\n  ngOnInit(): void {\n    console.log(\"Component initializing...\");\n\n    // 1. Create a Promise (e.g., using fetch)\n    const dataPromise = fetch(\"https://api.example.com/data\") // Example API\n      .then((response) =&gt; {\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json(); // This also returns a Promise\n      });\n\n    console.log(\"Promise created. Converting to Observable using from()...\");\n\n    // 2. Convert the Promise to an Observable using from()\n    const promiseAsObservable$ = from(dataPromise);\n\n    // 3. Use the Observable in your RxJS pipeline\n    this.data$ = promiseAsObservable$.pipe(\n      tap((data) =&gt;\n        console.log(\"Data received from promise via Observable:\", data)\n      ),\n      catchError((error) =&gt; {\n        // Handle potential errors from the promise (fetch failure, JSON parsing error)\n        console.error(\"Error emitted from promise Observable:\", error);\n        this.errorMessage = error.message || \"Failed to fetch data\";\n        return from([]); // Return an empty observable to prevent killing the main stream\n        // Or: return throwError(() =&gt; new Error('Custom error message'));\n      })\n    );\n\n    console.log(\n      \"Subscribing to promise-based Observable (will resolve asynchronously)...\"\n    );\n    // AsyncPipe in the template will handle the subscription here.\n    // Manual subscription for logging completion:\n    this.data$.subscribe({\n      next: () =&gt; {\n        /* Handled by tap above / AsyncPipe */\n      },\n      error: () =&gt; {\n        /* Handled by catchError above */\n      },\n      complete: () =&gt; {\n        // Called only if the promise resolves successfully and catchError doesn't replace the stream\n        if (!this.errorMessage) {\n          console.log(\"Promise-based Observable stream complete!\");\n        }\n      },\n    });\n  }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Array Example: <code>from(this.userIds)</code> takes the array and emits each string element individually, allowing operators like <code>map</code> to work on each one.</li> <li>Promise Example: <code>from(dataPromise)</code> takes the promise returned by <code>Workspace().then(...)</code>. It waits (asynchronously) for the promise to resolve. If it resolves successfully, the resolved JSON data is emitted as the <code>next</code> value. If the promise rejects (e.g., network error), <code>from()</code> emits an <code>error</code> notification, which we handle with <code>catchError</code>. The stream completes after the single value (or error) is emitted.</li> </ul>"},{"location":"Operators/Creation/from/#summary","title":"Summary","text":"<p><code>from()</code> is your go-to operator when you need to turn an array, iterable, or Promise into an Observable stream, typically to process its contents individually or integrate it seamlessly into your existing RxJS pipelines.</p>"},{"location":"Operators/Creation/interval/","title":"interval","text":"<p><code>interval()</code> is an RxJS creation operator that generates an Observable which emits sequential numbers (0, 1, 2, 3, and so on) at a specified, regular time interval (in milliseconds).</p> <p>Think of it as setting up a metronome that ticks indefinitely, emitting the tick count each time.</p>"},{"location":"Operators/Creation/interval/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Sequential Numbers: Emits <code>0</code>, then <code>1</code>, then <code>2</code>, ...</li> <li>Timed Emissions: You specify the delay between emissions (e.g., <code>interval(1000)</code> emits every 1 second).</li> <li>Asynchronous: The emissions happen asynchronously based on the timer you set.</li> <li>Never Completes: This is important! By default, <code>interval()</code> never stops emitting on its own. It will run forever unless you explicitly unsubscribe or use another operator (like <code>take</code>) to limit it.</li> <li>Cold Observable: Each subscription starts its own independent timer. If two parts of your code subscribe to <code>interval(1000)</code>, they will each get their own sequence starting from 0.</li> </ul>"},{"location":"Operators/Creation/interval/#real-world-example-scenario","title":"Real-World Example Scenario","text":"<p>A very common use case in web applications, including Angular, is polling. Imagine you need to check a server endpoint repeatedly to see if there's new data available, like:</p> <ul> <li>Checking for new chat messages every 5 seconds.</li> <li>Updating a dashboard with fresh statistics every 30 seconds.</li> <li>Checking the status of a long-running background job every 10 seconds.</li> </ul> <p><code>interval()</code> provides the timed trigger for making these checks.</p>"},{"location":"Operators/Creation/interval/#code-snippet-angular-component-polling-example","title":"Code Snippet (Angular Component - Polling Example)","text":"<p>Let's create a component that checks for hypothetical server status updates every 5 seconds (5000 milliseconds). We'll use <code>interval()</code> to trigger the check and <code>HttpClient</code> to make the request. We must remember to clean up the interval when the component is destroyed.</p> <pre><code>import { Component, OnInit, OnDestroy } from \"@angular/core\";\nimport { HttpClient } from \"@angular/common/http\";\nimport { interval, Subscription, Observable } from \"rxjs\";\nimport { switchMap, startWith, catchError, tap } from \"rxjs/operators\";\n\n@Component({\n  selector: \"app-status-poller\",\n  template: `\n    &lt;h4&gt;Server Status Check&lt;/h4&gt;\n    &lt;p&gt;Checking every 5 seconds...&lt;/p&gt;\n    &lt;div *ngIf=\"status\"&gt;\n      &lt;strong&gt;Last Status:&lt;/strong&gt; {{ status | json }}\n      &lt;br /&gt;\n      &lt;em&gt;Last Checked: {{ lastChecked | date : \"mediumTime\" }}&lt;/em&gt;\n    &lt;/div&gt;\n    &lt;div *ngIf=\"errorMessage\"&gt;&lt;strong&gt;Error:&lt;/strong&gt; {{ errorMessage }}&lt;/div&gt;\n  `,\n})\nexport class StatusPollerComponent implements OnInit, OnDestroy {\n  status: any = null;\n  lastChecked: Date | null = null;\n  errorMessage: string = \"\";\n\n  // To hold the subscription to the interval observable\n  private pollingSubscription: Subscription | undefined;\n  private readonly POLLING_INTERVAL_MS = 5000; // 5 seconds\n\n  constructor(private http: HttpClient) {}\n\n  ngOnInit(): void {\n    console.log(\n      `Starting status polling now (${new Date().toLocaleString()})...`\n    );\n\n    // Create an observable that emits every 5 seconds\n    const pollingInterval$ = interval(this.POLLING_INTERVAL_MS);\n\n    this.pollingSubscription = pollingInterval$\n      .pipe(\n        // Use startWith(0) to trigger the first check immediately,\n        // instead of waiting for the first 5-second interval to pass.\n        startWith(0), // Emit 0 immediately, then continue with interval 0, 1, 2...\n        tap(() =&gt;\n          console.log(\"Polling interval triggered... Fetching status.\")\n        ),\n        // For each emission from the interval, switch to making an HTTP GET request\n        switchMap(() =&gt; {\n          // switchMap cancels previous pending HTTP requests if the interval fires again quickly\n          return this.http.get&lt;any&gt;(\"/api/server/status\").pipe(\n            // Replace with your actual API endpoint\n            catchError((error) =&gt; {\n              // Handle HTTP errors gracefully\n              console.error(\"Error fetching status:\", error);\n              this.errorMessage = `Failed to fetch status (${\n                error.statusText || \"Unknown Error\"\n              })`;\n              this.status = null; // Clear previous status on error\n              // Return an empty observable or throwError to stop polling if needed\n              // For this example, we'll let polling continue\n              return []; // Don't emit anything on error, effectively skipping this interval's update\n            })\n          );\n        })\n      )\n      .subscribe({\n        next: (statusData) =&gt; {\n          // Successfully got status data from the API\n          console.log(\"Status received:\", statusData);\n          this.status = statusData;\n          this.lastChecked = new Date(); // Record the time of the successful check\n          this.errorMessage = \"\"; // Clear any previous error message\n        },\n        error: (err) =&gt; {\n          // This would typically catch errors NOT handled by the inner catchError,\n          // or if catchError re-throws an error.\n          console.error(\"Polling stream error:\", err);\n          this.errorMessage = \"Polling mechanism failed.\";\n        },\n        // Note: No 'complete' handler needed as interval() doesn't complete.\n      });\n  }\n\n  ngOnDestroy(): void {\n    // VERY IMPORTANT: Unsubscribe when the component is destroyed!\n    // Otherwise, the interval and polling will continue running in the background indefinitely,\n    // causing memory leaks and unnecessary network requests.\n    if (this.pollingSubscription) {\n      this.pollingSubscription.unsubscribe();\n      console.log(\"Polling stopped and unsubscribed.\");\n    }\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>interval(5000)</code>: Creates the basic timer emitting <code>0, 1, 2,...</code> every 5 seconds.</li> <li><code>startWith(0)</code>: We often want to check immediately when the component loads, not wait for the first interval. <code>startWith(0)</code> makes it emit <code>0</code> right away.</li> <li><code>switchMap(...)</code>: This is key for polling. When the interval emits, <code>switchMap</code> subscribes to the inner Observable (the <code>http.get()</code> call). If the interval emits again before the HTTP request finishes, <code>switchMap</code> automatically cancels the previous pending HTTP request and starts a new one. This prevents outdated responses or unnecessary concurrent requests for simple polling.</li> <li><code>catchError(...)</code>: Inside <code>switchMap</code>, we catch errors from the <code>http.get()</code> call specifically, allowing us to handle API errors without stopping the entire polling <code>interval</code>.</li> <li><code>subscribe(...)</code>: We process the successful status updates received from the API.</li> <li><code>ngOnDestroy()</code> / <code>unsubscribe()</code>: This is critical. We store the subscription returned by <code>.subscribe()</code> and call <code>.unsubscribe()</code> on it when the component is destroyed. This stops the <code>interval</code> timer and prevents memory leaks.</li> </ol>"},{"location":"Operators/Creation/interval/#summary","title":"Summary","text":"<p><code>interval()</code> is a fundamental tool for creating streams based on timed intervals, frequently used for polling or triggering periodic actions, but always requiring careful handling of unsubscription to avoid issues.</p>"},{"location":"Operators/Creation/of/","title":"of","text":"<p>The <code>of()</code> operator is a creation operator. Its job is simple: it creates an Observable that takes a sequence of arguments you provide, emits each of those arguments one after the other in the order you provided them, and then immediately completes.</p> <p>Think of it as a way to turn a fixed set of known values into an Observable stream.</p>"},{"location":"Operators/Creation/of/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Synchronous: It emits all its values immediately and synchronously when you subscribe.</li> <li>Ordered: It emits the values in the exact order they are passed as arguments.</li> <li>Completes: After emitting the last value, it sends a completion notification.</li> <li>Takes Multiple Arguments: You list the values you want to emit directly as arguments to <code>of()</code>.</li> </ul>"},{"location":"Operators/Creation/of/#real-world-example-scenario","title":"Real-World Example Scenario","text":"<p>Imagine you have a component in your Angular application that needs to display a list of predefined, static options, like user roles available for selection, default chart types, or initial filter categories. These values are known upfront, they don't need to be fetched from an API right now, but maybe other parts of your application expect to work with Observables for consistency. <code>of()</code> is perfect for creating an Observable stream from this static list.</p> <p>Example: Let's say you want to display a list of predefined priority levels ('Low', 'Medium', 'High', 'Critical') in a dropdown or as filter options.</p>"},{"location":"Operators/Creation/of/#code-snippet-angular-component","title":"Code Snippet (Angular Component)","text":"<pre><code>import { Component, OnInit } from \"@angular/core\";\nimport { Observable, of } from \"rxjs\"; // Import 'of'\n\n@Component({\n  selector: \"app-priority-options\",\n  template: `\n    &lt;h4&gt;Available Priorities:&lt;/h4&gt;\n    &lt;ul&gt;\n      &lt;li *ngFor=\"let priority of priorities$ | async\"&gt;{{ priority }}&lt;/li&gt;\n    &lt;/ul&gt;\n  `,\n})\nexport class PriorityOptionsComponent implements OnInit {\n  // Declare an Observable property to hold the stream of priorities\n  priorities$: Observable&lt;string&gt; | undefined;\n\n  ngOnInit(): void {\n    console.log(\"Component initializing...\");\n\n    // Use of() to create an Observable from a fixed list of strings\n    this.priorities$ = of(\"Low\", \"Medium\", \"High\", \"Critical\");\n\n    console.log(\n      \"Observable created with of(). Subscribing manually for demonstration...\"\n    );\n\n    // Manual subscription (often handled by AsyncPipe in templates as shown above)\n    this.priorities$.subscribe({\n      next: (value) =&gt; {\n        // This will be called for each value ('Low', 'Medium', 'High', 'Critical')\n        console.log(\"Received priority:\", value);\n      },\n      error: (err) =&gt; {\n        // This won't be called in this case because of() doesn't error\n        console.error(\"Error:\", err);\n      },\n      complete: () =&gt; {\n        // This will be called immediately after the last value ('Critical') is emitted\n        console.log(\"Priority stream complete!\");\n      },\n    });\n\n    console.log(\"Subscription processing finished (synchronously).\");\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>import { of } from 'rxjs';</code>: We import the <code>of</code> operator.</li> <li><code>this.priorities$ = of('Low', 'Medium', 'High', 'Critical');</code>: We call <code>of()</code> with our list of priority strings as arguments. This immediately creates an Observable (<code>this.priorities$</code>).</li> <li>Subscription Behavior:<ul> <li>When <code>subscribe()</code> is called (either manually or via the <code>async</code> pipe), the Observable created by <code>of()</code> synchronously emits 'Low', then 'Medium', then 'High', then 'Critical'.</li> <li>The <code>next</code> handler in our manual subscription logs each of these values.</li> <li>Immediately after emitting 'Critical', the Observable sends the <code>complete</code> notification, and our <code>complete</code> handler logs \"Priority stream complete!\".</li> <li>The <code>error</code> handler is never called because <code>of()</code> successfully emits its predefined values.</li> </ul> </li> <li><code>async</code> pipe: In the template (<code>*ngFor=\"let priority of priorities$ | async\"</code>), Angular's <code>async</code> pipe subscribes to <code>priorities$</code>, receives each value ('Low', 'Medium', etc.), updates the list, and automatically unsubscribes and handles completion/errors when the component is destroyed.</li> </ol>"},{"location":"Operators/Creation/of/#summary","title":"Summary","text":"<p><code>of()</code> is a straightforward way to create an Observable when you have a fixed number of values readily available and you want them emitted sequentially as part of a stream.</p>"},{"location":"Operators/Creation/timer/","title":"timer","text":"<p><code>timer()</code> is an RxJS creation operator that creates an Observable which emits values after a specified delay, and can optionally continue emitting values at regular intervals thereafter.</p> <p>It behaves differently based on the arguments you provide:</p> <ol> <li> <p><code>timer(dueTime)</code>:</p> <ul> <li>Waits for the specified <code>dueTime</code> (in milliseconds, or a <code>Date</code>).</li> <li>Emits a single value: <code>0</code>.</li> <li>Immediately completes.</li> </ul> </li> <li> <p><code>timer(initialDelay, period)</code>:</p> <ul> <li>Waits for the specified <code>initialDelay</code> (in milliseconds).</li> <li>Emits the first value: <code>0</code>.</li> <li>Then, waits for <code>period</code> milliseconds.</li> <li>Emits the next value: <code>1</code>.</li> <li>Continues emitting sequential numbers (<code>2</code>, <code>3</code>, ...) every <code>period</code> milliseconds.</li> <li>This form never completes on its own (just like <code>interval</code>).</li> </ul> </li> </ol>"},{"location":"Operators/Creation/timer/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Asynchronous: Emissions happen after specified delays.</li> <li>Completion:</li> <li>Completes after one emission (<code>0</code>) if only <code>dueTime</code> is provided.</li> <li>Never completes if <code>period</code> is also provided.</li> <li>Initial Delay: The second form allows a specific delay before the first emission, which is different from <code>interval</code> (where the first emission occurs after the first period).</li> <li>Cold Observable: Each subscription starts its own independent timer.</li> </ul>"},{"location":"Operators/Creation/timer/#difference-from-interval","title":"Difference from <code>interval()</code>","text":"<ul> <li><code>interval(1000)</code>: Waits 1000ms, emits <code>0</code>, waits 1000ms, emits <code>1</code>, ...</li> <li><code>timer(1000)</code>: Waits 1000ms, emits <code>0</code>, completes.</li> <li><code>timer(0, 1000)</code>: Waits 0ms (emits <code>0</code> immediately), waits 1000ms, emits <code>1</code>, waits 1000ms, emits <code>2</code>, ... (Starts immediately, then intervals).</li> <li><code>timer(5000, 1000)</code>: Waits 5000ms, emits <code>0</code>, waits 1000ms, emits <code>1</code>, waits 1000ms, emits <code>2</code>, ... (Initial delay before starting intervals).</li> </ul>"},{"location":"Operators/Creation/timer/#real-world-example-scenarios","title":"Real-World Example Scenarios","text":"<ol> <li> <p><code>timer(dueTime)</code> Scenario: Delayed Action / Welcome Message</p> <ul> <li>Imagine you want to show a \"Need help?\" tooltip or a welcome message in your Angular app, but only after the user has been on the page for, say, 3 seconds, giving them time to look around first. You only want this message to appear once.</li> </ul> </li> <li> <p><code>timer(initialDelay, period)</code> Scenario: Delayed Polling</p> <ul> <li>Similar to the <code>interval</code> polling example, but maybe you don't want to start checking the server status immediately on component load. Perhaps you want to wait 5 seconds for initial setup/rendering to finish, and then start checking every 10 seconds.</li> </ul> </li> </ol> <p>Code Snippet 1 (Using <code>timer(dueTime)</code> - Delayed Message):</p> <pre><code>import { Component, OnInit } from \"@angular/core\";\nimport { timer, Subscription } from \"rxjs\";\n\n@Component({\n  selector: \"app-delayed-message\",\n  template: `\n    &lt;h4&gt;Welcome!&lt;/h4&gt;\n    &lt;div *ngIf=\"showHelpMessage\" class=\"tooltip-message\"&gt;\n      Looks like you've been here a few seconds. Need any help?\n    &lt;/div&gt;\n  `,\n})\nexport class DelayedMessageComponent implements OnInit {\n  showHelpMessage = false;\n  private timerSubscription: Subscription | undefined;\n\n  ngOnInit(): void {\n    const messageDelay = 3000; // 3 seconds\n    console.log(\n      `Component initialized at ${new Date().toLocaleTimeString()}. Setting timer for ${messageDelay}ms.`\n    );\n\n    // Create an observable that emits 0 after 3 seconds, then completes.\n    const delayTimer$ = timer(messageDelay);\n\n    this.timerSubscription = delayTimer$.subscribe({\n      next: (value) =&gt; {\n        // This will be called once with value 0 after 3 seconds\n        console.log(\n          `Timer emitted ${value} at ${new Date().toLocaleTimeString()}. Showing message.`\n        );\n        this.showHelpMessage = true;\n      },\n      complete: () =&gt; {\n        // This will be called immediately after the 'next' emission\n        console.log(\"Delay timer completed.\");\n        // Since it completes, explicit unsubscription in ngOnDestroy for *this specific timer*\n        // isn't strictly necessary for leak prevention, but is still good practice\n        // if the component could be destroyed *before* the timer fires.\n      },\n    });\n  }\n\n  // Good practice to include, especially if combining with other subscriptions\n  ngOnDestroy(): void {\n    if (this.timerSubscription) {\n      this.timerSubscription.unsubscribe();\n      console.log(\n        \"Delayed message timer unsubscribed (if it was still running).\"\n      );\n    }\n  }\n}\n</code></pre> <p>Code Snippet 2 (Using <code>timer(initialDelay, period)</code> - Delayed Polling):</p> <p>Let's adapt the polling example to wait 5 seconds initially, then poll every 10 seconds.</p> <pre><code>import { Component, OnInit, OnDestroy } from \"@angular/core\";\nimport { HttpClient } from \"@angular/common/http\";\nimport { timer, Subscription, Observable } from \"rxjs\";\nimport { switchMap, catchError, tap } from \"rxjs/operators\";\n\n@Component({\n  selector: \"app-delayed-poller\",\n  template: `\n    &lt;h4&gt;Delayed Server Status Check&lt;/h4&gt;\n    &lt;p&gt;Waiting 5s initially, then checking every 10s...&lt;/p&gt;\n    &lt;div *ngIf=\"status\"&gt;\n      &lt;strong&gt;Last Status:&lt;/strong&gt; {{ status | json }}\n      &lt;br /&gt;\n      &lt;em&gt;Last Checked: {{ lastChecked | date : \"mediumTime\" }}&lt;/em&gt;\n    &lt;/div&gt;\n    &lt;div *ngIf=\"errorMessage\"&gt;&lt;strong&gt;Error:&lt;/strong&gt; {{ errorMessage }}&lt;/div&gt;\n  `,\n})\nexport class DelayedPollerComponent implements OnInit, OnDestroy {\n  status: any = null;\n  lastChecked: Date | null = null;\n  errorMessage: string = \"\";\n\n  private pollingSubscription: Subscription | undefined;\n  private readonly INITIAL_DELAY_MS = 5000; // 5 seconds\n  private readonly POLLING_PERIOD_MS = 10000; // 10 seconds\n\n  constructor(private http: HttpClient) {}\n\n  ngOnInit(): void {\n    console.log(\n      `Starting delayed polling now (${new Date().toLocaleString()}). Initial delay: ${\n        this.INITIAL_DELAY_MS\n      }ms, Period: ${this.POLLING_PERIOD_MS}ms.`\n    );\n\n    // Create timer: waits 5s, emits 0, then emits 1, 2,... every 10s\n    const pollingTimer$ = timer(this.INITIAL_DELAY_MS, this.POLLING_PERIOD_MS);\n\n    this.pollingSubscription = pollingTimer$\n      .pipe(\n        tap((count) =&gt;\n          console.log(`Polling timer emitted ${count}. Fetching status.`)\n        ),\n        // Switch to HTTP request on each timer emission\n        switchMap((count) =&gt; {\n          return this.http.get&lt;any&gt;(\"/api/server/status\").pipe(\n            // Use your actual endpoint\n            catchError((error) =&gt; {\n              console.error(\n                `Error fetching status (emission ${count}):`,\n                error\n              );\n              this.errorMessage = `Failed to fetch status (${\n                error.statusText || \"Unknown Error\"\n              })`;\n              this.status = null;\n              return []; // Continue polling even after error\n            })\n          );\n        })\n      )\n      .subscribe({\n        next: (statusData) =&gt; {\n          console.log(\"Status received:\", statusData);\n          this.status = statusData;\n          this.lastChecked = new Date();\n          this.errorMessage = \"\";\n        },\n        error: (err) =&gt; {\n          console.error(\"Polling stream error:\", err);\n          this.errorMessage = \"Polling mechanism failed.\";\n        },\n        // No 'complete' handler here because this timer variant never completes\n      });\n  }\n\n  ngOnDestroy(): void {\n    // VERY IMPORTANT for the timer(initialDelay, period) variant!\n    if (this.pollingSubscription) {\n      this.pollingSubscription.unsubscribe();\n      console.log(\"Delayed polling stopped and unsubscribed.\");\n    }\n  }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Example 1: <code>timer(3000)</code> waits 3 seconds, emits <code>0</code>, completes. Useful for one-off delayed actions.</li> <li>Example 2: <code>timer(5000, 10000)</code> waits 5 seconds, emits <code>0</code>, then continues emitting <code>1, 2, ...</code> at 10-second intervals. This requires careful unsubscription in <code>ngOnDestroy</code> just like <code>interval</code>.</li> </ul>"},{"location":"Operators/Creation/timer/#summary","title":"Summary","text":"<p><code>timer()</code> provides more flexibility than <code>interval()</code> for controlling when emissions start, offering both a one-shot delay (<code>timer(dueTime)</code>) and a recurring emission with an initial offset (<code>timer(initialDelay, period)</code>). Remember to unsubscribe from the recurring variant!</p>"},{"location":"Operators/Error/catchError/","title":"catchError","text":"<p><code>catchError()</code> is an RxJS operator used for graceful error handling within an Observable stream. When an error occurs in the source Observable (or in any preceding operators in the <code>pipe</code>), <code>catchError</code> intercepts that error notification. It gives you a chance to:</p> <ol> <li>Analyze the error: Log it, send it to a monitoring service, etc.</li> <li>Attempt recovery: You might retry the operation (often using the <code>retry</code> operator before <code>catchError</code>).</li> <li>Provide a fallback value: Return a default value or an empty state so the stream can continue gracefully instead of just terminating.</li> <li>Re-throw the error: If you can't handle it, you can let the error propagate further down the chain to the subscriber's error handler.</li> </ol>"},{"location":"Operators/Error/catchError/#how-catcherror-works","title":"How <code>catchError</code> Works","text":"<ul> <li>You place <code>catchError</code> inside the <code>.pipe()</code> method.</li> <li>It takes a function as an argument. This function receives the <code>error</code> object and optionally the <code>caught</code> Observable (the source stream that errored, useful for retrying).</li> <li>Crucially, this function MUST return a new Observable.</li> <li>If you return <code>of(someDefaultValue)</code> (e.g., <code>of([])</code>, <code>of(null)</code>), the outer stream will receive that default value in its <code>next</code> handler, and then it will complete successfully (it won't hit the <code>error</code> handler of the subscription).</li> <li>If you return <code>EMPTY</code> (from RxJS), the outer stream simply completes without emitting any further values.</li> <li>If you <code>throw error</code> (or <code>throw new Error(...)</code>) inside the <code>catchError</code> function, the error is passed along to the <code>error</code> handler of your <code>subscribe</code> block (or the next <code>catchError</code> downstream).</li> </ul>"},{"location":"Operators/Error/catchError/#real-world-example-handling-http-request-errors","title":"Real-World Example: Handling HTTP Request Errors","text":"<p>This is the most common use case in Angular. Imagine fetching user data from an API. The API might fail for various reasons (server down, user not found, network issue). Instead of letting the error break your component, you want to catch it, show a message, and perhaps return <code>null</code> or an empty user object.</p>"},{"location":"Operators/Error/catchError/#code-snippet-example","title":"Code Snippet Example","text":"<p>Let's create a component that tries to fetch user data. We'll use <code>catchError</code> to handle potential <code>HttpClient</code> errors.</p> <pre><code>import { Component, DestroyRef, inject, OnInit, signal } from \"@angular/core\";\nimport { HttpClient, HttpErrorResponse } from \"@angular/common/http\";\nimport { Observable, of, EMPTY, throwError } from \"rxjs\"; // Import 'of', 'EMPTY', 'throwError'\nimport { catchError, tap } from \"rxjs/operators\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n@Component({\n  selector: \"app-user-profile\",\n  standalone: true,\n  imports: [], // Add CommonModule if using *ngIf/*ngFor later\n  template: `\n    &lt;h2&gt;User Profile&lt;/h2&gt;\n    &lt;div *ngIf=\"loading()\"&gt;Loading user data...&lt;/div&gt;\n\n    &lt;div *ngIf=\"user() as userData\"&gt;\n      &lt;p&gt;ID: {{ userData.id }}&lt;/p&gt;\n      &lt;p&gt;Name: {{ userData.name }}&lt;/p&gt;\n      &lt;p&gt;Email: {{ userData.email }}&lt;/p&gt;\n    &lt;/div&gt;\n\n    &lt;div *ngIf=\"errorMsg()\" style=\"color: red;\"&gt;Error: {{ errorMsg() }}&lt;/div&gt;\n\n    &lt;button (click)=\"loadUser()\" [disabled]=\"loading()\"&gt;Reload User&lt;/button&gt;\n  `,\n})\nexport class UserProfileComponent implements OnInit {\n  private http = inject(HttpClient);\n  private destroyRef = inject(DestroyRef);\n\n  // --- State Signals ---\n  user = signal&lt;User | null&gt;(null);\n  loading = signal&lt;boolean&gt;(false);\n  errorMsg = signal&lt;string | null&gt;(null);\n\n  private userId = 1; // Example user ID\n\n  ngOnInit() {\n    this.loadUser();\n  }\n\n  loadUser() {\n    this.loading.set(true);\n    this.errorMsg.set(null); // Clear previous errors\n    this.user.set(null); // Clear previous user data\n\n    this.fetchUserData(this.userId)\n      .pipe(\n        takeUntilDestroyed(this.destroyRef) // Auto-unsubscribe on destroy\n      )\n      .subscribe({\n        next: (userData) =&gt; {\n          this.user.set(userData); // Update user signal on success\n          this.loading.set(false);\n          console.log(\"User data loaded:\", userData);\n        },\n        error: (err) =&gt; {\n          // This error handler is called ONLY if catchError re-throws the error\n          this.loading.set(false);\n          // Error is already set by catchError if we return a fallback\n          // If catchError re-threw, we might set a generic message here\n          if (!this.errorMsg()) {\n            // Check if message wasn't set by catchError\n            this.errorMsg.set(\"An unexpected error occurred downstream.\");\n          }\n          console.error(\"Subscription Error Handler:\", err);\n        },\n        complete: () =&gt; {\n          // Called when the stream finishes successfully\n          // (including after catchError returns a fallback like 'of(null)')\n          this.loading.set(false); // Ensure loading is off\n          console.log(\"User data stream completed.\");\n        },\n      });\n  }\n\n  private fetchUserData(id: number): Observable&lt;User | null&gt; {\n    // Use a non-existent URL to force an error for demonstration\n    // const apiUrl = `/api/users/${id}`; // Real URL\n    const apiUrl = `/api/non-existent-users/${id}`; // Fake URL for testing error\n\n    return this.http.get&lt;User&gt;(apiUrl).pipe(\n      tap(() =&gt; console.log(`Attempting to fetch user ${id}`)), // Side effect logging\n\n      // --- catchError Operator ---\n      catchError((error: HttpErrorResponse) =&gt; {\n        console.error(\"HTTP Error intercepted by catchError:\", error);\n\n        // ---- Strategy 1: Handle and return a fallback value ----\n        // Set user-friendly error message\n        if (error.status === 404) {\n          this.errorMsg.set(`User with ID ${id} not found.`);\n        } else if (error.status === 0 || error.status &gt;= 500) {\n          this.errorMsg.set(\n            \"Server error or network issue. Please try again later.\"\n          );\n        } else {\n          this.errorMsg.set(`An error occurred: ${error.message}`);\n        }\n        this.loading.set(false); // Turn off loading indicator\n        // Return null as a fallback. The 'next' handler of subscribe will receive null.\n        return of(null);\n\n        // ---- Strategy 2: Handle and return EMPTY (completes without value) ----\n        // this.errorMsg.set('Could not load user data.');\n        // this.loading.set(false);\n        // return EMPTY; // Stream completes, 'next' handler is not called.\n\n        // ---- Strategy 3: Log and re-throw the error ----\n        // this.errorMsg.set('Failed to load user data. Error propagated.'); // Set msg here or in subscribe error block\n        // this.loading.set(false);\n        // return throwError(() =&gt; new Error(`Failed fetching user ${id}: ${error.message}`)); // Propagate error to subscribe's error handler\n      })\n    );\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>WorkspaceUserData</code> makes an HTTP GET request using <code>HttpClient</code>.</li> <li>We <code>.pipe()</code> the result through <code>catchError</code>.</li> <li>If the HTTP request fails (e.g., returns 404 Not Found), the <code>catchError</code> function executes.</li> <li>Inside <code>catchError</code>:<ul> <li>We log the actual <code>HttpErrorResponse</code>.</li> <li>We set a user-friendly error message in the <code>errorMsg</code> signal based on the error status.</li> <li>We set <code>loading</code> to false.</li> <li>Crucially, we return <code>of(null)</code>. This creates a new observable that emits <code>null</code> once and then completes.</li> </ul> </li> <li>Because <code>catchError</code> returned <code>of(null)</code>, the original stream is considered \"handled.\" The <code>subscribe</code> block's <code>next</code> handler receives <code>null</code>. The component updates the <code>user</code> signal to <code>null</code> and the <code>error</code> handler is not executed. The stream completes normally.</li> <li>The template uses <code>*ngIf</code> directives bound to the signals (<code>user()</code>, <code>errorMsg()</code>, <code>loading()</code>) to conditionally display the user data, the loading indicator, or the error message.</li> </ol> <p>If we had chosen Strategy 3 (using <code>throwError</code>), the error would propagate to the <code>subscribe</code> block's <code>error</code> handler.</p> <p><code>catchError</code> is essential for building robust Angular applications that can gracefully handle failures in asynchronous operations like API calls.</p>"},{"location":"Operators/Error/retry/","title":"retry","text":"<p>Imagine you're trying to do something that might fail occasionally due to temporary issues (like a shaky internet connection). The <code>retry</code> operator helps you automatically try that operation again if it fails.</p> <p>It subscribes to the original (source) Observable. If that Observable emits an error, instead of immediately passing the error down the chain, <code>retry</code> resubscribes to the source Observable, effectively \"trying again\".</p>"},{"location":"Operators/Error/retry/#key-points","title":"Key Points","text":"<ol> <li>Error Triggered: It only activates when the source Observable sends an error notification.</li> <li>Resubscription: It attempts the exact same operation again by resubscribing.</li> <li>Count: You can (and usually should) provide a number to <code>retry(n)</code> specifying how many times to retry after the initial failure. So, <code>retry(2)</code> means 1 initial attempt + 2 retries = 3 total attempts maximum.</li> <li>Success: If any attempt (initial or retry) is successful, the success value is passed through, and <code>retry</code> does nothing further for that subscription.</li> <li>Final Error: If all attempts (initial + all retries) fail, the error from the last attempt is sent down the Observable chain.</li> <li>Infinite Retries: Using <code>retry()</code> without a count will retry indefinitely upon error. This is usually dangerous!</li> </ol>"},{"location":"Operators/Error/retry/#real-world-example","title":"Real-World Example","text":"<p>Fetching data from a web server is a classic case. Sometimes, network requests fail due to temporary glitches, a brief server hiccup, or packet loss. You don't want your application to break immediately. Instead, you might want to automatically try fetching the data again once or twice before showing an error message to the user.</p> <ul> <li>Source Observable: The <code>HttpClient</code> GET request Observable that fetches user data.</li> <li>Potential Error: A network error or a 5xx server error (indicating a temporary server issue).</li> </ul> <p><code>retry</code> is ideal here to handle these transient failures gracefully.</p>"},{"location":"Operators/Error/retry/#angular-code-snippet","title":"Angular Code Snippet","text":"<p>Let's create a service that fetches user data and a component that uses it, incorporating <code>retry</code>.</p> <p>1. User Data Service (<code>user.service.ts</code>)</p> <pre><code>import { Injectable, inject } from \"@angular/core\";\nimport { HttpClient, HttpErrorResponse } from \"@angular/common/http\";\nimport { Observable, throwError, timer } from \"rxjs\";\nimport { retry, catchError, tap } from \"rxjs/operators\";\n\nexport interface UserData {\n  id: number;\n  name: string;\n  email: string;\n}\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class UserService {\n  private http = inject(HttpClient);\n  private apiUrl = \"/api/user/profile\"; // Example API endpoint\n\n  getUserProfile(): Observable&lt;UserData&gt; {\n    console.log(\"Attempting to fetch user profile...\");\n    return this.http.get&lt;UserData&gt;(this.apiUrl).pipe(\n      tap(() =&gt;\n        console.log(\"Fetched user profile successfully on an attempt.\")\n      ),\n      // Retry configuration:\n      // count: 2 - Retry up to 2 times after the initial failure (3 total attempts).\n      // delay: 1000 - Wait 1 second between retries.\n      retry({\n        count: 2,\n        delay: (error: HttpErrorResponse, retryCount: number) =&gt; {\n          // Optional: Add more sophisticated delay logic (e.g., exponential backoff)\n          // Only retry on specific error types (e.g., network or 5xx server errors)\n          if (error.status &gt;= 500 || error.status === 0) {\n            // Server error or network error\n            console.warn(\n              `Attempt ${retryCount}: Retrying after error: ${error.message}. Waiting 1 second...`\n            );\n            return timer(1000); // Use RxJS timer for delay\n          } else {\n            // Don't retry for client errors (4xx) or other unexpected errors\n            console.error(\n              `Attempt ${retryCount}: Not retrying for error: ${error.message}`\n            );\n            return throwError(() =&gt; error); // Propagate the error immediately\n          }\n        },\n      }),\n      catchError((error: HttpErrorResponse) =&gt; {\n        // This catchError runs AFTER retries have been exhausted OR if retry decides not to retry\n        console.error(\"Failed to fetch user profile after all retries:\", error);\n        // You might want to return a user-friendly error object or re-throw\n        return throwError(\n          () =&gt;\n            new Error(\"Could not load user profile. Please try again later.\")\n        );\n      })\n    );\n  }\n}\n</code></pre> <p>2. User Profile Component (<code>user-profile.component.ts</code>)</p> <pre><code>import {\n  Component,\n  inject,\n  signal,\n  ChangeDetectionStrategy,\n  OnInit,\n  DestroyRef,\n} from \"@angular/core\";\nimport { CommonModule } from \"@angular/common\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\nimport { UserService, UserData } from \"./user.service\";\nimport { catchError, tap, finalize } from \"rxjs/operators\";\nimport { EMPTY } from \"rxjs\"; // Import EMPTY\n\n@Component({\n  selector: \"app-user-profile\",\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    &lt;h3&gt;User Profile&lt;/h3&gt;\n    @if (loading()) {\n    &lt;p&gt;Loading user profile...&lt;/p&gt;\n    } @else if (errorMsg()) {\n    &lt;p style=\"color: red;\"&gt;Error: {{ errorMsg() }}&lt;/p&gt;\n    } @else if (userProfile()) {\n    &lt;div&gt;\n      &lt;p&gt;&lt;strong&gt;ID:&lt;/strong&gt; {{ userProfile()?.id }}&lt;/p&gt;\n      &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt; {{ userProfile()?.name }}&lt;/p&gt;\n      &lt;p&gt;&lt;strong&gt;Email:&lt;/strong&gt; {{ userProfile()?.email }}&lt;/p&gt;\n    &lt;/div&gt;\n    } @else {\n    &lt;p&gt;Click the button to load profile.&lt;/p&gt;\n    }\n\n    &lt;button (click)=\"loadProfile()\" [disabled]=\"loading()\"&gt;Load Profile&lt;/button&gt;\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class UserProfileComponent {\n  private userService = inject(UserService);\n  private destroyRef = inject(DestroyRef);\n\n  // --- State Signals ---\n  userProfile = signal&lt;UserData | null&gt;(null);\n  loading = signal&lt;boolean&gt;(false);\n  errorMsg = signal&lt;string | null&gt;(null);\n\n  loadProfile(): void {\n    this.loading.set(true);\n    this.errorMsg.set(null); // Clear previous errors\n    this.userProfile.set(null); // Clear previous data\n\n    this.userService\n      .getUserProfile()\n      .pipe(\n        tap((data) =&gt; console.log(\"Component received user data:\", data)),\n        // Automatically unsubscribe when the component is destroyed\n        takeUntilDestroyed(this.destroyRef),\n        // Handle final success or error within the component\n        catchError((err: Error) =&gt; {\n          console.error(\"Component caught final error:\", err);\n          this.errorMsg.set(err.message || \"An unknown error occurred.\");\n          // Return EMPTY to gracefully complete the observable chain here\n          // so the finalize operator still runs, but no further 'next' is expected.\n          return EMPTY;\n        }),\n        finalize(() =&gt; {\n          // This runs whether the observable completes successfully or errors out (after retries/catchError)\n          this.loading.set(false);\n          console.log(\"Finished loading attempt (success or final error).\");\n        })\n      )\n      .subscribe({\n        next: (data) =&gt; {\n          this.userProfile.set(data); // Update signal on success\n        },\n        // Error handling is done in catchError now, but could also be done here\n        // error: (err) =&gt; { /* Already handled by catchError */ }\n        // complete: () =&gt; { /* Optional: actions on completion */ }\n      });\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>UserService</code>:<ul> <li><code>getUserProfile</code> makes an HTTP GET request.</li> <li><code>.pipe()</code> is used to chain operators.</li> <li><code>retry({ count: 2, delay: ... })</code>: If the <code>http.get</code> call results in an error, this configuration checks the error type. If it's a server-side error (<code>&gt;=500</code>) or a network error (<code>status === 0</code>), it waits for 1 second (<code>timer(1000)</code>) and then tells RxJS to resubscribe (retry the <code>http.get</code>). This happens up to 2 times after the first failure. If it's a client error (like 404 Not Found), it uses <code>throwError(() =&gt; error)</code> to stop retrying immediately.</li> <li><code>catchError</code>: This operator runs only if the <code>retry</code> logic gives up (either exhausts retries or decides not to retry based on the error type). It catches the final error, logs it, and returns a new error observable (<code>throwError</code>) with a user-friendly message.</li> </ul> </li> <li><code>UserProfileComponent</code>:<ul> <li>It uses Signals (<code>userProfile</code>, <code>loading</code>, <code>errorMsg</code>) to manage the component's state reactively.</li> <li><code>loadProfile</code> triggers the process.</li> <li>It calls <code>userService.getUserProfile()</code>.</li> <li><code>takeUntilDestroyed(this.destroyRef)</code> ensures the subscription is cleaned up.</li> <li><code>catchError</code>: Catches the final error passed down from the service (after retries) and updates the <code>errorMsg</code> signal. Returning <code>EMPTY</code> prevents the error from propagating further and allows <code>finalize</code> to run.</li> <li><code>finalize</code>: This operator runs regardless of whether the stream completed successfully or errored out (after retries/<code>catchError</code>). It's perfect for setting <code>loading.set(false)</code>.</li> <li><code>.subscribe()</code>: Updates the <code>userProfile</code> signal when data is successfully received.</li> </ul> </li> </ol>"},{"location":"Operators/Error/retry/#important-considerations-for-retry","title":"Important Considerations for <code>retry</code>","text":"<ul> <li>Don't Retry Everything: Only retry operations that might succeed on a subsequent attempt (transient network/server errors). Don't retry things like \"404 Not Found\" or \"400 Bad Request\" errors, as retrying won't fix the underlying problem. The <code>delay</code> function in the <code>retry</code> configuration object is ideal for this conditional retrying logic.</li> <li>Avoid Infinite Retries: Always specify a reasonable retry count.</li> <li>Side Effects: Be very careful retrying Observables that have side effects (e.g., POST or PUT requests). Retrying might cause the action (like creating a resource) to happen multiple times. It's generally safer for idempotent requests like GET or DELETE.</li> <li>Delay: Retrying immediately might not be helpful if the server needs a moment to recover. Adding a delay, possibly increasing with each retry (exponential backoff), is often recommended. The <code>retry({ delay: ... })</code> configuration makes this much easier than the older <code>retryWhen</code> operator.</li> </ul>"},{"location":"Operators/Error/retryWhen/","title":"retryWhen","text":"<p><code>retryWhen</code> gives you full control over the retry logic based on the errors that occur. Unlike <code>retry(n)</code>, which just retries immediately or with a simple configured delay, <code>retryWhen</code> lets you look at the sequence of errors and decide if and when to retry.</p> <p>It works like this:</p> <ol> <li>You provide <code>retryWhen</code> with a function.</li> <li>This function receives an Observable (let's call it <code>errors$</code>) as input. This <code>errors$</code> observable emits the actual error objects whenever your source Observable fails.</li> <li>Your function must return a new Observable (let's call it the \"notifier\" Observable).</li> <li>Retry Trigger: The source Observable (e.g., your HTTP request) is resubscribed to (retried) every time the notifier Observable emits a <code>next</code> value.</li> <li>Stop Retrying: If the notifier Observable emits an <code>error</code> or <code>complete</code> notification, the retrying stops, and the main Observable chain will emit that same <code>error</code> or <code>complete</code> notification.</li> </ol>"},{"location":"Operators/Error/retryWhen/#key-points","title":"Key Points","text":"<ol> <li>Error Input: Operates on the stream of errors from the source.</li> <li>Notifier Output: You define when to retry by controlling when the notifier emits <code>next</code>.</li> <li>Complex Logic: Allows for sophisticated strategies like exponential backoff, checking external conditions (e.g., network status), or even prompting the user (though UI interaction within operators is generally discouraged).</li> <li>Termination: You must ensure your notifier eventually emits an <code>error</code> or <code>complete</code> if you want the retries to stop; otherwise, you risk infinite retries. Usually, you <code>throwError</code> within the notifier's stream after a certain condition (like max retries exceeded) is met.</li> </ol>"},{"location":"Operators/Error/retryWhen/#important-note","title":"Important Note","text":"<p>While <code>retryWhen</code> is powerful, it's also known for being complex and somewhat tricky to use correctly. For many common retry scenarios (like retrying a fixed number of times with a delay, or retrying based on error type), the simpler <code>retry</code> operator with its configuration object (<code>retry({ count: 3, delay: ... })</code>) is often preferred and easier to understand in modern RxJS. Use <code>retryWhen</code> when you need highly customized or complex retry logic that <code>retry</code> cannot handle easily.</p>"},{"location":"Operators/Error/retryWhen/#real-world-example","title":"Real-World Example","text":"<p>Let's implement a classic exponential backoff strategy. If an HTTP request fails, we want to retry, but wait longer each time before retrying, and give up after a few attempts.</p> <ul> <li>Attempt 1: Fails -&gt; Wait 1 second -&gt; Retry</li> <li>Attempt 2: Fails -&gt; Wait 2 seconds -&gt; Retry</li> <li>Attempt 3: Fails -&gt; Wait 4 seconds -&gt; Retry</li> <li> <p>Attempt 4: Fails -&gt; Give up and propagate the error.</p> </li> <li> <p>Source Observable: An <code>HttpClient</code> GET request.</p> </li> <li>Error Stream: The <code>errors$</code> observable passed into <code>retryWhen</code>.</li> <li>Notifier Logic: Calculate increasing delay based on retry count, emit after delay, but throw an error if max retries exceeded.</li> </ul>"},{"location":"Operators/Error/retryWhen/#angular-code-snippet","title":"Angular Code Snippet","text":"<p>We'll modify the previous <code>UserService</code> example to use <code>retryWhen</code> for exponential backoff.</p> <p>1. User Data Service with <code>retryWhen</code></p> <pre><code>import { Injectable, inject } from \"@angular/core\";\nimport { HttpClient, HttpErrorResponse } from \"@angular/common/http\";\nimport { Observable, throwError, timer, pipe } from \"rxjs\";\nimport {\n  retryWhen,\n  delayWhen,\n  scan,\n  tap,\n  catchError,\n  mergeMap,\n} from \"rxjs/operators\";\n\nexport interface UserData {\n  id: number;\n  name: string;\n  email: string;\n}\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class UserService {\n  private http = inject(HttpClient);\n  private apiUrl = \"/api/user/profile\"; // Example API endpoint\n\n  getUserProfileWithRetryWhen(\n    maxRetries = 3,\n    initialDelay = 1000\n  ): Observable&lt;UserData&gt; {\n    console.log(\"Attempting to fetch user profile (using retryWhen)...\");\n    return this.http.get&lt;UserData&gt;(this.apiUrl).pipe(\n      tap(() =&gt;\n        console.log(\"Fetched user profile successfully on an attempt.\")\n      ),\n      // --- retryWhen Logic ---\n      retryWhen(\n        (\n          errors$ // errors$ is an Observable of the errors\n        ) =&gt;\n          errors$.pipe(\n            // Use scan to keep track of the retry attempts\n            scan((retryCount, error: HttpErrorResponse) =&gt; {\n              // Check if error is retryable and count is within limits\n              // Here we retry only on 5xx or network errors, similar to before\n              if (\n                retryCount &gt;= maxRetries ||\n                !(error.status &gt;= 500 || error.status === 0)\n              ) {\n                // If max retries reached or error is not retryable, throw the error\n                // This will cause the notifier stream to error out, stopping retries.\n                console.error(\n                  `Attempt ${\n                    retryCount + 1\n                  }: Not retrying. Max retries (${maxRetries}) reached or error not retryable (${\n                    error.status\n                  }).`\n                );\n                throw error; // Re-throw the error to be caught by the outer catchError\n              }\n              // Otherwise, increment the count for the next potential retry\n              console.warn(\n                `Attempt ${retryCount + 1} failed. Error: ${\n                  error.message\n                }. Will retry.`\n              );\n              return retryCount + 1;\n            }, 0), // Initial value for retryCount is 0\n            // Calculate delay based on the retry count (exponential backoff)\n            delayWhen((retryCount) =&gt; {\n              const delay = initialDelay * Math.pow(2, retryCount - 1); // Calculate delay: 1000ms, 2000ms, 4000ms...\n              console.log(\n                `Attempt ${retryCount}: Waiting ${delay}ms before next retry...`\n              );\n              return timer(delay); // Emit after the calculated delay\n            })\n            // Note: If the scan operator above throws an error, this delayWhen\n            // will not execute, and the error propagates immediately.\n          )\n      ),\n      // --- End of retryWhen Logic ---\n      catchError((error: HttpErrorResponse) =&gt; {\n        // This runs AFTER retryWhen gives up (notifier stream errors out)\n        console.error(\n          \"Failed to fetch user profile after all retryWhen attempts:\",\n          error\n        );\n        return throwError(\n          () =&gt;\n            new Error(\n              \"Could not load user profile (retryWhen). Please try again later.\"\n            )\n        );\n      })\n    );\n  }\n}\n</code></pre> <p>2. User Profile Component</p> <pre><code>import {\n  Component,\n  inject,\n  signal,\n  ChangeDetectionStrategy,\n  OnInit,\n  DestroyRef,\n} from \"@angular/core\";\nimport { CommonModule } from \"@angular/common\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\nimport { UserService, UserData } from \"./user.service\"; // Adjust path if needed\nimport { catchError, tap, finalize } from \"rxjs/operators\";\nimport { EMPTY } from \"rxjs\";\n\n@Component({\n  selector: \"app-user-profile-rw\", // Changed selector\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    &lt;h3&gt;User Profile (retryWhen Example)&lt;/h3&gt;\n    @if (loading()) {\n    &lt;p&gt;Loading user profile...&lt;/p&gt;\n    } @else if (errorMsg()) {\n    &lt;p style=\"color: red;\"&gt;Error: {{ errorMsg() }}&lt;/p&gt;\n    } @else if (userProfile()) {\n    &lt;div&gt;\n      &lt;p&gt;&lt;strong&gt;ID:&lt;/strong&gt; {{ userProfile()?.id }}&lt;/p&gt;\n      &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt; {{ userProfile()?.name }}&lt;/p&gt;\n      &lt;p&gt;&lt;strong&gt;Email:&lt;/strong&gt; {{ userProfile()?.email }}&lt;/p&gt;\n    &lt;/div&gt;\n    } @else {\n    &lt;p&gt;Click the button to load profile.&lt;/p&gt;\n    }\n\n    &lt;button (click)=\"loadProfile()\" [disabled]=\"loading()\"&gt;\n      Load Profile (retryWhen)\n    &lt;/button&gt;\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class UserProfileRetryWhenComponent {\n  // Renamed component\n  private userService = inject(UserService);\n  private destroyRef = inject(DestroyRef);\n\n  // --- State Signals ---\n  userProfile = signal&lt;UserData | null&gt;(null);\n  loading = signal&lt;boolean&gt;(false);\n  errorMsg = signal&lt;string | null&gt;(null);\n\n  loadProfile(): void {\n    this.loading.set(true);\n    this.errorMsg.set(null);\n    this.userProfile.set(null);\n\n    // Call the method using retryWhen\n    this.userService\n      .getUserProfileWithRetryWhen()\n      .pipe(\n        tap((data) =&gt; console.log(\"Component received user data:\", data)),\n        takeUntilDestroyed(this.destroyRef),\n        catchError((err: Error) =&gt; {\n          console.error(\"Component caught final error:\", err);\n          this.errorMsg.set(err.message || \"An unknown error occurred.\");\n          return EMPTY;\n        }),\n        finalize(() =&gt; {\n          this.loading.set(false);\n          console.log(\"Finished loading attempt (success or final error).\");\n        })\n      )\n      .subscribe({\n        next: (data) =&gt; {\n          this.userProfile.set(data);\n        },\n      });\n  }\n}\n</code></pre> <p>Explanation of <code>retryWhen</code> Logic:</p> <ol> <li><code>retryWhen(errors$ =&gt; ...)</code>: We receive the stream of errors (<code>errors$</code>).</li> <li><code>errors$.pipe(...)</code>: We process this error stream.</li> <li><code>scan((retryCount, error) =&gt; {...}, 0)</code>: <code>scan</code> is like <code>reduce</code> for Observables. It maintains state across emissions.<ul> <li><code>retryCount</code> holds the number of retries attempted so far (starts at 0).</li> <li><code>error</code> is the current error emitted by the source.</li> <li>Inside <code>scan</code>, we check if <code>retryCount &gt;= maxRetries</code> or if the <code>error</code> type is one we don't want to retry.</li> <li>If we should stop retrying, we <code>throw error;</code>. This is crucial! It makes the <code>scan</code> operator (and thus the whole notifier stream) emit an error, which signals <code>retryWhen</code> to stop and propagate this error.</li> <li>If we should retry, we increment the <code>retryCount</code> and return it. This incremented count becomes the input <code>retryCount</code> for the next error emission and is also passed down the notifier pipe.</li> </ul> </li> <li><code>delayWhen(retryCount =&gt; timer(delay))</code>: This operator takes the <code>retryCount</code> passed down from <code>scan</code>.<ul> <li>It calculates the exponential delay: <code>initialDelay * Math.pow(2, retryCount - 1)</code>.</li> <li><code>timer(delay)</code> creates an Observable that emits a single value (0) after <code>delay</code> milliseconds.</li> <li><code>delayWhen</code> waits for this <code>timer</code> to emit before it emits the value it received (the <code>retryCount</code>). This emission is what triggers <code>retryWhen</code> to resubscribe to the original <code>http.get</code> request.</li> </ul> </li> </ol>"},{"location":"Operators/Error/retryWhen/#summary","title":"Summary","text":"<p><code>retryWhen</code> lets you construct a custom \"notifier\" Observable based on the errors from the source. When the notifier emits <code>next</code>, a retry occurs. When the notifier emits <code>error</code> or <code>complete</code>, retrying stops. While powerful for complex cases, remember that the modern <code>retry</code> operator often handles common scenarios more simply.</p>"},{"location":"Operators/Filtering/debounceTime/","title":"debounceTime","text":"<p><code>debounceTime()</code> is a rate-limiting operator in RxJS. It helps control how often values are emitted from a source Observable, especially when the source emits values very rapidly.</p> <p>Think of it like this: <code>debounceTime()</code> waits for a pause in the emissions from the source. When the source emits a value, <code>debounceTime</code> starts a timer for a specified duration (let's say <code>X</code> milliseconds).</p> <ul> <li>If the source emits another value before that <code>X</code> milliseconds timer runs out, the operator discards the previous value and restarts the timer for the new value.</li> <li>Only if the timer completes its full <code>X</code> milliseconds without any new values arriving from the source, will <code>debounceTime</code> finally emit the last value it received.</li> </ul> <p>In short, it only emits a value after a specific period of silence from the source Observable.</p>"},{"location":"Operators/Filtering/debounceTime/#key-characteristics","title":"Key Characteristics","text":"<ol> <li>Requires Silence: It waits for a specified duration (<code>dueTime</code>) where no new values are emitted by the source.</li> <li>Emits Last Value: When the silence duration is met, it emits the most recent value received from the source before the silence began.</li> <li>Resets Timer: Each new emission from the source before the <code>dueTime</code> expires resets the timer. Intermediate values are discarded.</li> <li>Rate Limiting: Effectively limits the rate at which values pass through, based on pauses in activity.</li> </ol>"},{"location":"Operators/Filtering/debounceTime/#real-world-analogy-autocomplete-search-box","title":"Real-World Analogy: Autocomplete Search Box","text":"<p>This is the classic example! Imagine searching on a website. You type into the search box:</p> <ul> <li><code>L</code> -&gt; (API call for \"L\"? No, too quick!)</li> <li><code>La</code> -&gt; (API call for \"La\"? No, too quick!)</li> <li><code>Lap</code> -&gt; (API call for \"Lap\"? No, too quick!)</li> <li><code>Lapt</code> -&gt; (API call for \"Lapt\"? No, too quick!)</li> <li><code>Lapto</code> -&gt; (API call for \"Lapto\"? No, too quick!)</li> <li><code>Laptop</code> -&gt; (User pauses typing for 300ms...) -&gt; OK, NOW send API request for \"Laptop\"</li> </ul> <p>You don't want to send an API request to your server for every single letter the user types. That would be incredibly inefficient and costly. Instead, you use <code>debounceTime(300)</code>. The operator waits until the user pauses typing for 300 milliseconds. Only then does it take the last value typed (\"Laptop\") and send it to the server for searching. If the user types quickly without pausing, all the intermediate values (\"L\", \"La\", \"Lap\", etc.) are ignored.</p>"},{"location":"Operators/Filtering/debounceTime/#angular-example-typeahead-search-input","title":"Angular Example: Typeahead Search Input","text":"<p>Let's refine the Angular search component using <code>debounceTime</code>.</p> <pre><code>import { Component, OnInit, inject } from \"@angular/core\";\nimport { FormControl, ReactiveFormsModule } from \"@angular/forms\"; // Need ReactiveFormsModule\nimport { HttpClient } from \"@angular/common/http\"; // Assuming API call\nimport { Observable, of } from \"rxjs\";\nimport {\n  debounceTime, // &lt;-- The operator we're focusing on\n  distinctUntilChanged, // Prevent duplicates\n  switchMap, // Handle async operations, cancel previous\n  catchError, // Handle API errors\n  tap, // For side-effects like loading indicators\n} from \"rxjs/operators\";\nimport { DestroyRef } from \"@angular/core\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\nimport { NgFor, NgIf, AsyncPipe } from \"@angular/common\"; // Need CommonModule directives/pipes\n\n@Component({\n  selector: \"app-efficient-search\",\n  standalone: true,\n  imports: [ReactiveFormsModule, NgFor, NgIf, AsyncPipe],\n  template: `\n    &lt;input\n      type=\"search\"\n      [formControl]=\"searchControl\"\n      placeholder=\"Enter search term...\"\n    /&gt;\n\n    &lt;div *ngIf=\"isLoading\" class=\"loading-indicator\"&gt;Searching...&lt;/div&gt;\n\n    &lt;ul *ngIf=\"results$ | async as searchResults\"&gt;\n      &lt;li *ngFor=\"let result of searchResults\"&gt;{{ result }}&lt;/li&gt;\n      &lt;li\n        *ngIf=\"searchResults.length === 0 &amp;&amp; searchControl.value &amp;&amp; !isLoading\"\n      &gt;\n        No results found.\n      &lt;/li&gt;\n    &lt;/ul&gt;\n\n    &lt;div *ngIf=\"errorMsg\" class=\"error-message\"&gt;{{ errorMsg }}&lt;/div&gt;\n  `,\n})\nexport class EfficientSearchComponent implements OnInit {\n  searchControl = new FormControl(\"\");\n  results$: Observable&lt;string[]&gt;; // Observable stream for results\n  isLoading = false;\n  errorMsg: string | null = null;\n\n  // Use inject() for dependencies\n  private http = inject(HttpClient);\n  private destroyRef = inject(DestroyRef);\n\n  ngOnInit() {\n    this.results$ = this.searchControl.valueChanges.pipe(\n      // 1. DEBOUNCE: Wait for 300ms pause after last keystroke\n      debounceTime(300),\n\n      // 2. DISTINCT: Only proceed if the text is different from the last debounced value\n      distinctUntilChanged(),\n\n      // 3. TAP (Side-effect): Show loading, clear errors before making the call\n      tap((term) =&gt; {\n        if (term &amp;&amp; term.length &gt; 0) {\n          // Only show loading for actual searches\n          this.isLoading = true;\n          this.errorMsg = null;\n        } else {\n          this.isLoading = false; // Hide loading if input is cleared\n        }\n        console.log(`Debounced search term: \"${term}\"`);\n      }),\n\n      // 4. SWITCHMAP: Make the API call, cancel previous if new term arrives\n      switchMap((term) =&gt; {\n        if (!term || term.length &lt; 1) {\n          // If input is empty or too short, return empty array immediately\n          return of([]); // 'of([])' returns an Observable&lt;string[]&gt;\n        }\n        // Replace with your actual API search function\n        return this.searchApi(term).pipe(\n          catchError((err) =&gt; {\n            console.error(\"API Search Error:\", err);\n            this.errorMsg = \"Search failed. Please try again.\";\n            return of([]); // Return empty on error\n          })\n        );\n      }),\n\n      // 5. TAP (Side-effect): Hide loading after API call completes (success or handled error)\n      tap(() =&gt; {\n        this.isLoading = false;\n      }),\n\n      // 6. AUTOCLEANUP: Ensure subscription is managed\n      takeUntilDestroyed(this.destroyRef)\n    );\n  }\n\n  // Dummy search API function\n  private searchApi(term: string): Observable&lt;string[]&gt; {\n    console.log(`--- Making API call for: \"${term}\" ---`);\n    // In a real app: return this.http.get&lt;string[]&gt;(`/api/search?q=${term}`);\n    const mockResults = term\n      ? [`${term} - result 1`, `${term} - result 2`]\n      : [];\n    return of(mockResults).pipe(delay(500)); // Simulate network delay\n  }\n}\n// Required import for delay in dummy API\nimport { delay } from \"rxjs/operators\";\n</code></pre> <p>In this Angular Example:</p> <ol> <li><code>debounceTime(300)</code> ensures that we don't react to every keystroke. The pipeline only continues after the user has paused typing for 300ms.</li> <li><code>distinctUntilChanged()</code> works well after <code>debounceTime</code> to prevent searching for the exact same term multiple times if the user pauses, types something, then deletes it back to the original term before pausing again.</li> <li><code>tap()</code> allows us to update the <code>isLoading</code> state before (<code>true</code>) and after (<code>false</code>) the API call logic initiated by <code>switchMap</code>.</li> <li><code>switchMap()</code> handles the asynchronous API call. Crucially, combined with <code>debounceTime</code>, it ensures that only the request for the latest stable search term is executed, and any previous pending requests for older terms are cancelled.</li> <li><code>takeUntilDestroyed</code> handles unsubscription automatically.</li> </ol> <p>Using <code>debounceTime</code> here dramatically improves user experience and reduces unnecessary load on backend services.</p>"},{"location":"Operators/Filtering/distinctUntilChanged/","title":"distinctUntilChanged","text":"<p><code>distinctUntilChanged()</code> is a straightforward yet very useful filtering operator. Its purpose is to prevent consecutive duplicate values from passing through an Observable stream.</p> <p>It works by remembering the most recent value it emitted. When a new value arrives from the source, <code>distinctUntilChanged()</code> compares this new value with the previously emitted value:</p> <ul> <li>If the new value is different from the previous one, it allows the new value to pass through and remembers it as the new \"previous\" value.</li> <li>If the new value is the same as the previous one, it filters out (discards) the new value.</li> </ul> <p>By default, it uses strict equality (<code>===</code>) for comparison. You can optionally provide your own comparison function if you need custom logic (e.g., comparing specific properties of objects). The very first value emitted by the source always passes through, as there's nothing previous to compare it against.</p>"},{"location":"Operators/Filtering/distinctUntilChanged/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Filters Consecutive Duplicates: Only emits a value if it's different from the immediately preceding emission.</li> <li>Comparison: Uses <code>===</code> by default; accepts an optional custom comparator function.</li> <li>Stateful: It needs to keep track of the last emitted value.</li> <li>Passes First Value: The first emission always gets through.</li> <li>Passes Errors/Completion: Doesn't interfere with error or completion notifications.</li> </ul>"},{"location":"Operators/Filtering/distinctUntilChanged/#real-world-example-optimizing-user-input-handling","title":"Real-World Example: Optimizing User Input Handling","text":"<p>Imagine you're building a feature with a search input field. As the user types, you want to react to their input, perhaps by making an API call to fetch search results.</p> <p>Now, input events can sometimes fire frequently, even if the actual text value hasn't changed (e.g., related to focus events or specific key presses that don't alter the text). Furthermore, if you use <code>debounceTime</code> to wait for pauses in typing, the user might pause, resume typing the same characters, and pause again, potentially emitting the same search term multiple times consecutively after debouncing.</p> <p>If fetching search results is an expensive operation (network request, database query), you absolutely want to avoid making redundant requests for the exact same search term back-to-back. <code>distinctUntilChanged()</code> is the perfect tool here. By placing it in your Observable pipe after you've extracted the input value (and often after <code>debounceTime</code>), you ensure that your API call logic only executes when the search term the user has settled on actually changes from the previous term you searched for.</p>"},{"location":"Operators/Filtering/distinctUntilChanged/#code-snippet","title":"Code Snippet","text":"<pre><code>import { Component, OnInit, OnDestroy } from \"@angular/core\";\nimport { FormControl, ReactiveFormsModule } from \"@angular/forms\";\nimport { Subscription } from \"rxjs\";\nimport { map, debounceTime, distinctUntilChanged, tap } from \"rxjs/operators\";\nimport { CommonModule } from \"@angular/common\";\n\n@Component({\n  selector: \"app-distinct-search-reactive\",\n  standalone: true,\n  imports: [CommonModule, ReactiveFormsModule],\n  template: `\n    &lt;h4&gt;Distinct Search Input Demo (Reactive Forms)&lt;/h4&gt;\n    &lt;p&gt;Time: {{ currentTime }}&lt;/p&gt;\n    &lt;p&gt;\n      Uses FormControl.valueChanges. Filters out consecutive duplicate search\n      terms after debounce. Check console.\n    &lt;/p&gt;\n    &lt;input\n      [formControl]=\"searchInputControl\"\n      type=\"text\"\n      class=\"form-control\"\n      placeholder=\"Type here...\"\n    /&gt;\n    &lt;div class=\"mt-2\"&gt;\n      &lt;h6&gt;Search triggered for:&lt;/h6&gt;\n      &lt;ul class=\"list-group\"&gt;\n        &lt;li *ngFor=\"let term of searchLog\" class=\"list-group-item small\"&gt;\n          {{ term }}\n        &lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  `,\n})\nexport class DistinctSearchReactiveComponent implements OnInit, OnDestroy {\n  searchInputControl = new FormControl(\"\");\n  searchLog: string[] = [];\n  currentTime: string = new Date().toLocaleTimeString();\n  private inputSubscription: Subscription | undefined;\n\n  ngOnInit(): void {\n    this.inputSubscription = this.searchInputControl.valueChanges\n      .pipe(\n        tap((value) =&gt; {\n          this.currentTime = new Date().toLocaleTimeString();\n          console.log(`[${this.currentTime}] Raw valueChange: \"${value}\"`);\n        }),\n        debounceTime(400),\n        map((value) =&gt; (typeof value === \"string\" ? value.trim() : \"\")),\n        tap((value) =&gt; {\n          this.currentTime = new Date().toLocaleTimeString();\n          console.log(`  [${this.currentTime}] Debounced: \"${value}\"`);\n        }),\n        distinctUntilChanged(),\n        tap((value) =&gt; {\n          this.currentTime = new Date().toLocaleTimeString();\n          console.log(\n            `    [${this.currentTime}] Distinct: \"${value}\" -&gt; Triggering Search!`\n          );\n        })\n      )\n      .subscribe({\n        next: (searchTerm) =&gt; {\n          const termStr = searchTerm ?? \"\";\n          this.searchLog.push(\n            `[${new Date().toLocaleTimeString()}] \"${termStr}\"`\n          );\n          if (this.searchLog.length &gt; 10) this.searchLog.shift();\n          // API call placeholder\n        },\n        error: (err) =&gt; console.error(\"Input stream error:\", err),\n      });\n  }\n\n  ngOnDestroy(): void {\n    this.inputSubscription?.unsubscribe();\n    console.log(\"Search input subscription stopped.\");\n  }\n}\n</code></pre>"},{"location":"Operators/Filtering/distinctUntilChanged/#explanation","title":"Explanation","text":"<ol> <li><code>fromEvent(..., 'input')</code>: Creates a stream of input events.</li> <li><code>map(...)</code>: Extracts the text value from each event.</li> <li><code>debounceTime(400)</code>: Waits for a 400ms pause in typing before passing the latest value. This helps prevent excessive processing during rapid typing.</li> <li><code>distinctUntilChanged()</code>: This is the crucial step. It receives the debounced value. It compares this value to the last value that it allowed through. If the current debounced value is identical to the previous one (e.g., user paused, typed the same letter again, paused), <code>distinctUntilChanged</code> filters it out. Only if the debounced value has actually changed since the last emission will it pass through.</li> <li><code>tap(...)</code> after distinctUntilChanged: The logging here only happens for values that are truly distinct after debouncing.</li> <li><code>subscribe({...})</code>: The <code>next</code> handler, which would typically trigger the expensive search operation, is only called when <code>distinctUntilChanged</code> allows a value through, thus avoiding redundant searches for the same term.</li> </ol>"},{"location":"Operators/Filtering/distinctUntilChanged/#summary","title":"Summary","text":"<p><code>distinctUntilChanged()</code> is a simple but powerful operator for optimizing streams by ensuring that downstream operations only occur when a value actually changes compared to its immediate predecessor, filtering out consecutive duplicates.</p>"},{"location":"Operators/Filtering/filter/","title":"filter","text":"<p>The <code>filter()</code> operator is, as the name suggests, a filtering operator. It looks at each value emitted by the source Observable and applies a condition check \u2013 called a predicate function \u2013 to it.</p> <ul> <li>If the predicate function returns <code>true</code> for a value, <code>filter()</code> allows that value to pass through to the next operator or subscriber.</li> <li>If the predicate function returns <code>false</code>, <code>filter()</code> simply discards that value, and it's never seen downstream.</li> </ul> <p>It works very much like the <code>Array.prototype.filter()</code> method in JavaScript, but operates on values emitted asynchronously over time by an Observable.</p>"},{"location":"Operators/Filtering/filter/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Conditional Emission: Only emits values that satisfy the condition defined in the predicate function.</li> <li>Takes a Predicate Function: You provide a function <code>filter(predicateFn)</code> where <code>predicateFn</code> takes the source value (and optionally its index) and returns <code>true</code> or <code>false</code>.</li> <li>Doesn't Modify Values: It doesn't change the content of the values that pass through; it only decides if they pass.</li> <li>Preserves Relative Order: The values that do pass maintain their original relative order.</li> <li>Passes Through Errors/Completion: If the source Observable errors or completes, <code>filter</code> passes those notifications along immediately.</li> </ul>"},{"location":"Operators/Filtering/filter/#real-world-example-scenario","title":"Real-World Example Scenario","text":"<p>It's Tuesday afternoon here in Bengaluru (around 3:00 PM IST). Imagine you have a stream of incoming tasks or notifications in your Angular application. Each task object might have a <code>priority</code> property ('high', 'medium', 'low'). You might have different parts of your UI or different logic handlers interested only in tasks of a certain priority.</p> <p>Scenario: Let's say you want to display an urgent notification counter that only increments when a task with <code>'high'</code> priority arrives. You can use <code>filter()</code> to create a new stream containing only those high-priority tasks.</p>"},{"location":"Operators/Filtering/filter/#code-snippet-angular-component-filtering-high-priority-tasks","title":"Code Snippet (Angular Component - Filtering High-Priority Tasks)","text":"<pre><code>import { Component, OnInit, OnDestroy } from \"@angular/core\";\nimport { Subject, Subscription } from \"rxjs\";\nimport { filter, tap } from \"rxjs/operators\"; // Import filter\n\ninterface Task {\n  id: number;\n  description: string;\n  priority: \"high\" | \"medium\" | \"low\";\n}\n\n@Component({\n  selector: \"app-task-filter-demo\",\n  template: `\n    &lt;h4&gt;Task Filtering Demo&lt;/h4&gt;\n    &lt;p&gt;Simulating incoming tasks. Check console log and high priority list.&lt;/p&gt;\n    &lt;button (click)=\"simulateIncomingTask()\" class=\"btn btn-secondary\"&gt;\n      Simulate New Task\n    &lt;/button&gt;\n\n    &lt;div class=\"mt-3\"&gt;\n      &lt;h5&gt;High Priority Tasks Only (Count: {{ highPriorityTaskCount }})&lt;/h5&gt;\n      &lt;ul class=\"list-group\"&gt;\n        &lt;li\n          *ngFor=\"let task of highPriorityTasks\"\n          class=\"list-group-item list-group-item-danger small\"\n        &gt;\n          ID: {{ task.id }} - {{ task.description }}\n        &lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n    &lt;div class=\"mt-3\"&gt;\n      &lt;h5&gt;All Tasks Log:&lt;/h5&gt;\n      &lt;ul class=\"list-group\"&gt;\n        &lt;li *ngFor=\"let task of allTasksLog\" class=\"list-group-item small\"&gt;\n          ID: {{ task.id }} - {{ task.description }} (Priority:\n          {{ task.priority }})\n        &lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  `,\n})\nexport class TaskFilterDemoComponent implements OnInit, OnDestroy {\n  highPriorityTaskCount = 0;\n  highPriorityTasks: Task[] = [];\n  allTasksLog: Task[] = [];\n\n  // Use a Subject to simulate a stream of incoming tasks\n  private taskSubject = new Subject&lt;Task&gt;();\n  private taskSubscription: Subscription | undefined;\n  private taskIdCounter = 0;\n\n  ngOnInit(): void {\n    // Subscribe to the task stream\n    this.taskSubscription = this.taskSubject\n      .pipe(\n        tap((task) =&gt; {\n          // Log every task that comes in *before* filtering\n          console.log(\n            `[${new Date().toLocaleTimeString()}] Received Task: ID=${\n              task.id\n            }, Prio=${task.priority}`\n          );\n          this.allTasksLog.push(task);\n          if (this.allTasksLog.length &gt; 10) this.allTasksLog.shift(); // Keep log short\n        }),\n        // Apply the filter operator\n        filter((task: Task) =&gt; {\n          // This is the predicate function.\n          // It returns true only if the task's priority is 'high'.\n          const shouldPass = task.priority === \"high\";\n          console.log(\n            `   Filtering Task ID ${task.id} (Prio: ${task.priority}). Should pass? ${shouldPass}`\n          );\n          return shouldPass;\n        }),\n        // The rest of the pipe only sees tasks that passed the filter\n        tap((highPrioTask) =&gt; {\n          console.log(`      -&gt; Task ID ${highPrioTask.id} passed the filter!`);\n        })\n      )\n      .subscribe({\n        next: (highPriorityTask: Task) =&gt; {\n          // This 'next' handler only receives tasks where priority === 'high'\n          this.highPriorityTaskCount++;\n          this.highPriorityTasks.push(highPriorityTask);\n          if (this.highPriorityTasks.length &gt; 5) this.highPriorityTasks.shift(); // Keep list short\n        },\n        error: (err) =&gt; console.error(\"Task stream error:\", err),\n        // complete: () =&gt; console.log('Task stream completed') // Only if subject completes\n      });\n  }\n\n  simulateIncomingTask(): void {\n    this.taskIdCounter++;\n    const priorities: Array&lt;\"high\" | \"medium\" | \"low\"&gt; = [\n      \"low\",\n      \"medium\",\n      \"high\",\n    ];\n    const randomPriority =\n      priorities[Math.floor(Math.random() * priorities.length)];\n\n    const newTask: Task = {\n      id: this.taskIdCounter,\n      description: `Simulated task number ${this.taskIdCounter}`,\n      priority: randomPriority,\n    };\n    console.log(\n      `------------------\\nSimulating: Pushing task ${newTask.id} with priority ${newTask.priority}`\n    );\n    this.taskSubject.next(newTask); // Push the new task onto the stream\n  }\n\n  ngOnDestroy(): void {\n    if (this.taskSubscription) {\n      this.taskSubscription.unsubscribe();\n    }\n    this.taskSubject.complete();\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>Subject&lt;Task&gt;</code>: We use a Subject to mimic an Observable stream where <code>Task</code> objects arrive over time (triggered by the button click).</li> <li><code>tap(...)</code> (before filter): We use <code>tap</code> to log every task that enters the pipe, before it hits the filter, so we can see everything that arrives.</li> <li><code>filter((task: Task) =&gt; task.priority === 'high')</code>: This is the core.<ul> <li>The <code>filter</code> operator receives each <code>Task</code> object emitted by the <code>taskSubject</code>.</li> <li>The predicate function <code>(task: Task) =&gt; task.priority === 'high'</code> checks if the <code>priority</code> property of the task is strictly equal to <code>'high'</code>.</li> <li>If it is <code>true</code>, the <code>task</code> object is passed further down the pipe.</li> <li>If it is <code>false</code> (i.e., priority is 'medium' or 'low'), the <code>task</code> object is discarded by <code>filter</code>.</li> </ul> </li> <li><code>tap(...)</code> (after filter): We log again here to clearly see which tasks made it through the filter.</li> <li><code>subscribe({ next: ... })</code>: The <code>next</code> handler will only be executed for tasks that passed the filter (those with 'high' priority). We update the count and the list based on these filtered tasks.</li> </ol>"},{"location":"Operators/Filtering/filter/#summary","title":"Summary","text":"<p><code>filter()</code> acts as a gatekeeper for your Observable streams, allowing only the data that meets your specific criteria to proceed, making it essential for selecting relevant information from potentially noisy streams.</p>"},{"location":"Operators/Filtering/find/","title":"find","text":"<p>The <code>find</code> operator searches through the sequence of values emitted by a source Observable. It takes a predicate function (a function that returns <code>true</code> or <code>false</code>) as an argument.</p> <p><code>find</code> will:</p> <ol> <li>Check each value emitted by the source against the predicate function.</li> <li>If it finds a value for which the predicate returns <code>true</code>:<ul> <li>It emits that single value.</li> <li>It immediately completes the output Observable (it stops listening to the source).</li> </ul> </li> <li>If the source Observable completes without emitting any value that satisfies the predicate function:<ul> <li><code>find</code> emits <code>undefined</code>.</li> <li>It then completes.</li> </ul> </li> </ol>"},{"location":"Operators/Filtering/find/#analogy","title":"Analogy","text":"<p>Imagine you're watching items pass by on a conveyor belt (the source Observable). You're looking for a specific item, say, the first red ball.</p> <ul> <li>You start watching (<code>subscribe</code>).</li> <li>Items go by: blue square, green triangle... (<code>find</code> checks each with your predicate <code>item =&gt; item.color === 'red'</code>).</li> <li>A red ball appears! (<code>find</code> predicate returns <code>true</code>).</li> <li>You grab that red ball (emit the value).</li> <li>You walk away because you found what you needed (complete the output Observable). You don't care about any other items that might come later on the belt.</li> <li>If the belt stops (<code>source completes</code>) before you see any red balls, you walk away empty-handed (emit <code>undefined</code>).</li> </ul>"},{"location":"Operators/Filtering/find/#key-points","title":"Key Points","text":"<ul> <li>Emits At Most One Value: You'll only ever get the first matching item or <code>undefined</code>.</li> <li>Completes Early: As soon as a match is found, the operator completes. This can be efficient if you only need the first occurrence.</li> <li>Predicate Function: The core logic lives in the function you provide to test each value.</li> <li>vs <code>filter</code>: Don't confuse <code>find</code> with <code>filter</code>. <code>filter</code> lets all values that match the predicate pass through, while <code>find</code> only lets the first one through and then stops.</li> </ul>"},{"location":"Operators/Filtering/find/#real-world-example-finding-the-first-admin-user-in-a-stream","title":"Real-World Example: Finding the First Admin User in a Stream","text":"<p>Suppose you have a stream of user objects being emitted (perhaps from a WebSocket or paginated API results). You want to find the very first user object that has administrative privileges and then stop processing.</p>"},{"location":"Operators/Filtering/find/#code-snippet","title":"Code Snippet","text":"<p>1. Mock User Service (Emits Users One by One)</p> <pre><code>import { Injectable } from \"@angular/core\";\nimport { Observable, from, timer } from \"rxjs\";\nimport { concatMap, delay, tap } from \"rxjs/operators\"; // Use concatMap for sequential emission with delay\n\nexport interface User {\n  id: number;\n  name: string;\n  isAdmin: boolean;\n}\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class UserStreamService {\n  getUsers(): Observable&lt;User&gt; {\n    const users: User[] = [\n      { id: 1, name: \"Alice (User)\", isAdmin: false },\n      { id: 2, name: \"Bob (User)\", isAdmin: false },\n      { id: 3, name: \"Charlie (Admin)\", isAdmin: true }, // The one we want!\n      { id: 4, name: \"Diana (User)\", isAdmin: false },\n      { id: 5, name: \"Eve (Admin)\", isAdmin: true }, // `find` won't reach this one\n    ];\n\n    console.log(\"UserStreamService: Starting user emission...\");\n\n    // Emit users one by one with a small delay between them\n    return from(users).pipe(\n      concatMap((user) =&gt;\n        timer(500).pipe(\n          // Wait 500ms before emitting next user\n          tap(() =&gt; console.log(` -&gt; Emitting user: ${user.name}`)),\n          switchMap(() =&gt; of(user)) // Emit the user after the delay\n        )\n      )\n      // This simpler version emits immediately, find still works:\n      // return from(users).pipe(\n      //  tap(user =&gt; console.log(` -&gt; Emitting user: ${user.name}`))\n      // );\n    );\n  }\n}\n</code></pre> <p>2. Component Using <code>find</code></p> <pre><code>import {\n  Component,\n  inject,\n  signal,\n  ChangeDetectionStrategy,\n  OnInit,\n  DestroyRef,\n} from \"@angular/core\";\nimport { CommonModule } from \"@angular/common\"; // For @if and json pipe\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\nimport { UserStreamService, User } from \"./user-stream.service\"; // Adjust path\nimport { find, tap } from \"rxjs/operators\";\n\n@Component({\n  selector: \"app-find-admin\",\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    &lt;div&gt;\n      &lt;h4&gt;Find Operator Example&lt;/h4&gt;\n      &lt;p&gt;Searching for the first admin user in the stream...&lt;/p&gt;\n\n      @if (foundAdmin()) {\n      &lt;div class=\"result found\"&gt;\n        &lt;strong&gt;First Admin Found:&lt;/strong&gt;\n        &lt;pre&gt;{{ foundAdmin() | json }}&lt;/pre&gt;\n      &lt;/div&gt;\n      } @else if (searchComplete()) {\n      &lt;p class=\"result not-found\"&gt;\n        No admin user found before the stream completed.\n      &lt;/p&gt;\n      } @else {\n      &lt;p class=\"result searching\"&gt;Searching...&lt;/p&gt;\n      }\n    &lt;/div&gt;\n  `,\n  // No 'styles' section\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class FindAdminComponent implements OnInit {\n  private userStreamService = inject(UserStreamService);\n  private destroyRef = inject(DestroyRef);\n\n  // --- State Signals ---\n  foundAdmin = signal&lt;User | undefined&gt;(undefined); // Result can be User or undefined\n  searchComplete = signal&lt;boolean&gt;(false); // Track if the find operation finished\n\n  ngOnInit(): void {\n    console.log(\"FindAdminComponent: Subscribing to find the first admin...\");\n\n    this.userStreamService\n      .getUsers()\n      .pipe(\n        tap((user) =&gt;\n          console.log(`Checking user: ${user.name}, isAdmin: ${user.isAdmin}`)\n        ),\n\n        // --- Apply the find operator ---\n        // Predicate checks the isAdmin property\n        find((user) =&gt; user.isAdmin === true),\n        // --------------------------------\n\n        takeUntilDestroyed(this.destroyRef) // Standard cleanup\n      )\n      .subscribe({\n        next: (adminUser) =&gt; {\n          // This 'next' block runs AT MOST ONCE.\n          // 'adminUser' will be the first user where isAdmin is true, OR undefined.\n          if (adminUser) {\n            console.log(\"SUCCESS: First admin found -&gt;\", adminUser);\n            this.foundAdmin.set(adminUser);\n          } else {\n            // This case happens if the source stream completes BEFORE an admin is found.\n            console.log(\n              \"INFO: Stream completed without finding an admin user.\"\n            );\n          }\n          this.searchComplete.set(true); // Mark search as finished\n        },\n        error: (err) =&gt; {\n          console.error(\"Error during user stream processing:\", err);\n          this.searchComplete.set(true); // Mark as finished on error too\n        },\n        complete: () =&gt; {\n          // This 'complete' runs immediately after 'find' emits its value (or undefined).\n          // It does NOT wait for the source stream ('getUsers') to necessarily finish\n          // if an admin was found early.\n          console.log(\"Find operation stream completed.\");\n          // Ensure completion state is set, e.g., if source was empty.\n          this.searchComplete.set(true);\n        },\n      });\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>UserStreamService</code> provides an Observable <code>getUsers()</code> that emits user objects sequentially with a delay.</li> <li><code>FindAdminComponent</code> subscribes to this stream in <code>ngOnInit</code>.</li> <li><code>find(user =&gt; user.isAdmin === true)</code>: This is the core. For each user emitted by <code>getUsers()</code>:<ul> <li>The predicate <code>user =&gt; user.isAdmin === true</code> is evaluated.</li> <li>It checks Alice (false), Bob (false).</li> <li>It checks Charlie (true!). The predicate returns <code>true</code>.</li> <li><code>find</code> immediately emits the Charlie <code>User</code> object.</li> <li><code>find</code> immediately completes its output stream. It unsubscribes from the <code>getUsers()</code> source; Diana and Eve will likely not even be processed by the <code>tap</code> or emitted by the source in this specific component subscription because <code>find</code> stopped listening early.</li> </ul> </li> <li>The <code>subscribe</code> block receives the Charlie object in its <code>next</code> handler. The <code>foundAdmin</code> signal is updated, and the UI displays the result. The <code>searchComplete</code> signal is set.</li> <li>The <code>complete</code> handler runs immediately after <code>next</code>, logging that the <code>find</code> operation is done.</li> </ol> <p>If you were to change the <code>users</code> array in the service so no user has <code>isAdmin: true</code>, the <code>getUsers</code> stream would emit all users and then complete. <code>find</code> would never find a match, so it would emit <code>undefined</code> when its source completes. The <code>next</code> handler would receive <code>undefined</code>, the UI would show the \"not found\" message, and <code>complete</code> would run.</p>"},{"location":"Operators/Filtering/first/","title":"first","text":"<p>The <code>first()</code> operator is used to get only the first value emitted by a source Observable that meets an optional condition. After emitting that single value, it immediately completes the stream.</p> <p>It can be used in a few ways:</p> <ol> <li><code>first()</code> (no arguments): Emits the very first value from the source, then completes. If the source completes without emitting any values, <code>first()</code> will emit an <code>EmptyError</code>.</li> <li><code>first(predicateFn)</code>: Emits the first value from the source for which the provided <code>predicateFn</code> function returns <code>true</code>, then completes. If the source completes before any value satisfies the predicate, <code>first()</code> will emit an <code>EmptyError</code>.</li> <li><code>first(predicateFn, defaultValue)</code>: Same as above, but if the source completes before any value satisfies the predicate, it emits the provided <code>defaultValue</code> instead of erroring, and then completes.</li> </ol>"},{"location":"Operators/Filtering/first/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Selects First Value: Emits only one value \u2013 the first that qualifies based on the arguments.</li> <li>Completes Stream: Immediately completes after emitting the single value (or default value/error).</li> <li>Unsubscribes from Source: Cleans up the source subscription upon completion or error.</li> <li>Potential Error: Can throw <code>EmptyError</code> if no suitable value is found before the source completes (unless a <code>defaultValue</code> is supplied).</li> </ul>"},{"location":"Operators/Filtering/first/#real-world-example-scenario","title":"Real-World Example Scenario","text":"<p>Imagine your Angular application needs to load some initial configuration data when it starts. This data might be available via an Observable (perhaps from a service using <code>ReplaySubject(1)</code> or <code>BehaviorSubject</code>). You only care about getting that first available configuration value to initialize your component, even if the source Observable might emit updates later. <code>first()</code> is ideal for grabbing that initial emission and then completing the stream cleanly.</p> <p>Scenario: Let's simulate a stream emitting user status updates ('pending', 'active', 'inactive'). We only want to know the first time the user becomes 'active'.</p>"},{"location":"Operators/Filtering/first/#code-snippet","title":"Code Snippet","text":"<pre><code>import { Component, OnInit } from \"@angular/core\";\nimport {\n  of,\n  first,\n  catchError,\n  EMPTY,\n  throwError,\n  timer,\n  map,\n  concat,\n} from \"rxjs\";\nimport { EmptyError } from \"rxjs\";\n\n@Component({\n  selector: \"app-first-demo\",\n  standalone: true,\n  imports: [],\n  template: `\n    &lt;h4&gt;First Operator Demo&lt;/h4&gt;\n    &lt;p&gt;Looking for the first 'active' status. Check console.&lt;/p&gt;\n    &lt;p&gt;Result: {{ resultStatus }}&lt;/p&gt;\n  `,\n})\nexport class FirstDemoComponent implements OnInit {\n  resultStatus = \"Waiting...\";\n\n  ngOnInit(): void {\n    const statusUpdates$ = concat(\n      timer(500).pipe(map(() =&gt; \"pending\")),\n      timer(1000).pipe(map(() =&gt; \"pending\")),\n      timer(1500).pipe(map(() =&gt; \"active\")), // First 'active' here\n      timer(2000).pipe(map(() =&gt; \"pending\")),\n      timer(2500).pipe(map(() =&gt; \"inactive\"))\n    );\n\n    console.log(\n      `[${new Date().toLocaleTimeString()}] Subscribing to find first 'active' status...`\n    );\n\n    statusUpdates$\n      .pipe(\n        first((status) =&gt; status === \"active\"),\n        catchError((error) =&gt; {\n          if (error instanceof EmptyError) {\n            console.warn(\n              `[${new Date().toLocaleTimeString()}] No 'active' status found before stream completed.`\n            );\n            this.resultStatus = \"No active status found.\";\n            return EMPTY;\n          } else {\n            console.error(\n              `[${new Date().toLocaleTimeString()}] Stream error:`,\n              error\n            );\n            this.resultStatus = `Error: ${error.message}`;\n            return throwError(() =&gt; error);\n          }\n        })\n      )\n      .subscribe({\n        next: (activeStatus) =&gt; {\n          console.log(\n            `[${new Date().toLocaleTimeString()}] Found first active status: ${activeStatus}`\n          );\n          this.resultStatus = `First active status: ${activeStatus}`;\n        },\n        complete: () =&gt; {\n          console.log(\n            `[${new Date().toLocaleTimeString()}] Stream completed by first().`\n          );\n          // Note: resultStatus might already be set by next or catchError\n          if (this.resultStatus === \"Waiting...\") {\n            this.resultStatus =\n              \"Stream completed (likely handled by catchError/default)\";\n          }\n        },\n      });\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>statusUpdates$</code>: We simulate a stream emitting different status strings over time using <code>concat</code> and <code>timer</code>.</li> <li><code>first(status =&gt; status === 'active')</code>: This operator listens to <code>statusUpdates$</code>.<ul> <li>It ignores 'pending'.</li> <li>When 'active' arrives, <code>first()</code> emits 'active'.</li> <li>Immediately after emitting 'active', it sends the <code>complete</code> signal and unsubscribes from <code>statusUpdates$</code>. The subsequent 'pending' and 'inactive' emissions are never processed by this subscription.</li> </ul> </li> <li><code>catchError(...)</code>: This handles the <code>EmptyError</code> that <code>first()</code> would throw if the <code>statusUpdates$</code> completed before emitting 'active'. In this example, 'active' is found, so this specific error path isn't taken.</li> <li><code>subscribe({...})</code>:<ul> <li>The <code>next</code> handler receives the single value 'active'.</li> <li>The <code>complete</code> handler is called right after <code>next</code>, confirming the stream finished.</li> </ul> </li> </ol>"},{"location":"Operators/Filtering/first/#summary","title":"Summary","text":"<p><code>first()</code> is used when you need exactly one value from the beginning of a stream (optionally matching a condition) and want the stream to complete immediately afterward. It's concise for getting initial values or the first occurrence of a specific event. Remember its potential to throw <code>EmptyError</code> if no qualifying value is emitted before the source completes.</p>"},{"location":"Operators/Filtering/last/","title":"last","text":"<p>The <code>last()</code> operator is used to get only the very last value emitted by a source Observable that satisfies an optional condition, but only after the source Observable completes.</p> <p>It operates similarly to <code>first()</code> but focuses on the end of the stream:</p> <ol> <li><code>last()</code> (no arguments): Waits for the source Observable to complete. Once completed, it emits the single, last value that the source emitted. If the source completes without emitting any values, <code>last()</code> will emit an <code>EmptyError</code>.</li> <li><code>last(predicateFn)</code>: Waits for the source Observable to complete. Once completed, it looks at all the values the source emitted and finds the last one for which the <code>predicateFn</code> returned <code>true</code>. It emits that single value. If no value satisfied the predicate before completion, <code>last()</code> emits an <code>EmptyError</code>.</li> <li><code>last(predicateFn, defaultValue)</code>: Same as above, but if no value satisfied the predicate before completion, it emits the <code>defaultValue</code> instead of erroring.</li> </ol>"},{"location":"Operators/Filtering/last/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Waits for Completion: Critically depends on the source Observable sending a <code>complete</code> notification before it can emit a value. It won't work on streams that never complete (like a raw <code>interval</code>).</li> <li>Selects Last Value: Emits only one value \u2013 the last that qualifies based on the arguments, determined after the source finishes.</li> <li>Completes Stream: Completes itself immediately after emitting the single value (or default value/error).</li> <li>Potential Error: Can throw <code>EmptyError</code> if the source completes without emitting suitable values (unless a <code>defaultValue</code> is supplied).</li> </ul>"},{"location":"Operators/Filtering/last/#real-world-example-scenario","title":"Real-World Example Scenario","text":"<p>Imagine you have an Observable representing a sequence of operations that must finish, like processing steps in a batch job. The stream might emit intermediate status updates, but you only care about the final result or status message that is emitted just before the entire process completes.</p> <p>Scenario: Let's simulate a stream emitting scores achieved during different phases of a game round. We only want to get the final score achieved at the end of the round.</p>"},{"location":"Operators/Filtering/last/#code-snippet","title":"Code Snippet","text":"<pre><code>import { Component, OnInit } from \"@angular/core\";\nimport { of, last, catchError, EMPTY, throwError } from \"rxjs\";\nimport { EmptyError } from \"rxjs\";\n\n@Component({\n  selector: \"app-last-demo\",\n  standalone: true,\n  imports: [],\n  template: `\n    &lt;h4&gt;Last Operator Demo&lt;/h4&gt;\n    &lt;p&gt;Getting the final score from a completed round. Check console.&lt;/p&gt;\n    &lt;p&gt;Result: {{ finalScoreStatus }}&lt;/p&gt;\n  `,\n})\nexport class LastDemoComponent implements OnInit {\n  finalScoreStatus = \"Waiting for round to complete...\";\n\n  ngOnInit(): void {\n    const roundScores$ = of(10, 50, 20, 100); // Finite, completes after 100\n\n    console.log(\n      `[${new Date().toLocaleTimeString()}] Subscribing to get final score...`\n    );\n\n    roundScores$\n      .pipe(\n        last(), // No predicate, just get the very last value\n        catchError((error) =&gt; {\n          if (error instanceof EmptyError) {\n            console.warn(\n              `[${new Date().toLocaleTimeString()}] Source completed without emitting values.`\n            );\n            this.finalScoreStatus = \"Round completed with no scores.\";\n            return EMPTY;\n          } else {\n            console.error(\n              `[${new Date().toLocaleTimeString()}] Stream error:`,\n              error\n            );\n            this.finalScoreStatus = `Error: ${error.message}`;\n            return throwError(() =&gt; error);\n          }\n        })\n      )\n      .subscribe({\n        next: (finalScore) =&gt; {\n          console.log(\n            `[${new Date().toLocaleTimeString()}] Final score received: ${finalScore}`\n          );\n          this.finalScoreStatus = `Final Score: ${finalScore}`;\n        },\n        complete: () =&gt; {\n          console.log(\n            `[${new Date().toLocaleTimeString()}] Stream completed by last().`\n          );\n        },\n      });\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>roundScores$ = of(10, 50, 20, 100)</code>: We create a finite Observable using <code>of()</code>. This stream emits 10, 50, 20, 100 and then immediately completes.</li> <li><code>last()</code>: This operator subscribes to <code>roundScores$</code>. It internally keeps track of the most recently emitted value. Because <code>roundScores$</code> completes right after emitting 100, <code>last()</code> knows the stream is finished.</li> <li>Emission: Once <code>roundScores$</code> completes, <code>last()</code> emits the very last value it saw, which is <code>100</code>.</li> <li><code>catchError(...)</code>: Handles the <code>EmptyError</code> case if the source (<code>of()</code>) had been empty (e.g., <code>of()</code>).</li> <li><code>subscribe({...})</code>:<ul> <li>The <code>next</code> handler receives the single value <code>100</code>.</li> <li>The <code>complete</code> handler is called right after <code>next</code>, confirming the stream finished.</li> </ul> </li> </ol>"},{"location":"Operators/Filtering/last/#summary","title":"Summary","text":"<p><code>last()</code> is used when you need the final value emitted by a completing Observable stream (optionally matching a condition). It inherently requires waiting for the source to finish before it can determine and emit the last value. Remember it won't work if the source stream never completes.</p>"},{"location":"Operators/Filtering/skip/","title":"skip","text":"<p>The <code>skip()</code> operator is quite straightforward: it tells an Observable stream to simply ignore the first <code>N</code> values it emits. After skipping the specified number of items, it will then allow all subsequent emissions to pass through normally.</p> <p>Think of it as telling someone to start counting after a certain number. If you say <code>skip(3)</code>, you're essentially saying \"Ignore the 1st, 2nd, and 3rd things that happen, but tell me about the 4th, 5th, 6th, and so on.\"</p>"},{"location":"Operators/Filtering/skip/#key-characteristics","title":"Key Characteristics","text":"<ol> <li>Counts and Ignores: It keeps an internal count of how many items have been emitted by the source.</li> <li>Skips the Start: It prevents the first <code>N</code> emissions from reaching the subscriber or subsequent operators in the pipe.</li> <li>Emits After Skipping: Once <code>N</code> items have been skipped, all following items are emitted without further modification by <code>skip()</code>.</li> <li>Argument: It takes one argument: <code>count</code> (the number of emissions to skip).</li> </ol>"},{"location":"Operators/Filtering/skip/#real-world-analogy","title":"Real-World Analogy","text":"<p>Imagine you are subscribing to a news feed that sends updates every hour. However, you know that the first 2 updates of the day are always just routine system checks or old news summaries that you don't care about.</p> <p>You can use <code>skip(2)</code> on this news feed stream. This way, you won't be bothered by the first two updates each day. You'll only start receiving notifications from the 3rd update onwards, which contains the actual news you're interested in.</p>"},{"location":"Operators/Filtering/skip/#angular-example-ignoring-initial-value-from-behaviorsubject","title":"Angular Example: Ignoring Initial Value from `BehaviorSubject","text":"<p>A common use case in Angular involves <code>BehaviorSubject</code> or <code>ReplaySubject(1)</code>. These types of Subjects store the \"current\" value and emit it immediately to any new subscriber. Sometimes, you only want to react to future changes pushed to the Subject, not the value it happens to hold at the exact moment you subscribe.</p> <p>Let's say you have a service managing user authentication status:</p> <pre><code>import { Injectable } from \"@angular/core\";\nimport { BehaviorSubject } from \"rxjs\";\n\n@Injectable({ providedIn: \"root\" })\nexport class AuthService {\n  // Initially, user is logged out. Emits `false` immediately to new subscribers.\n  private loggedInStatus = new BehaviorSubject&lt;boolean&gt;(false);\n  isLoggedIn$ = this.loggedInStatus.asObservable();\n\n  login() {\n    // Simulate successful login\n    console.log(\"AuthService: User logged in.\");\n    this.loggedInStatus.next(true);\n  }\n\n  logout() {\n    console.log(\"AuthService: User logged out.\");\n    this.loggedInStatus.next(false);\n  }\n}\n\n// --- In a Component ---\nimport { Component, DestroyRef, inject, signal } from \"@angular/core\";\nimport { NgIf } from \"@angular/common\"; // Import NgIf for the template\nimport { takeUntilDestroyed, toSignal } from \"@angular/core/rxjs-interop\"; // Core interop functions\nimport { filter, skip } from \"rxjs/operators\";\nimport { AuthService } from \"./auth.service\"; // Assuming AuthService exists as defined previously\n\n@Component({\n  selector: \"app-login-watcher\",\n  standalone: true,\n  imports: [NgIf],\n  template: `\n    &lt;div&gt;\n      User is currently: {{ isLoggedIn() ? \"Logged In\" : \"Logged Out\" }}\n    &lt;/div&gt;\n\n    &lt;div *ngIf=\"loginMessage()\" style=\"color: green;\"&gt;{{ loginMessage() }}&lt;/div&gt;\n\n    &lt;button (click)=\"authService.login()\"&gt;Log In&lt;/button&gt;\n    &lt;button (click)=\"authService.logout()\"&gt;Log Out&lt;/button&gt;\n  `,\n})\nexport class LoginWatcherComponent {\n  protected authService = inject(AuthService);\n  private destroyRef = inject(DestroyRef);\n\n  isLoggedIn = toSignal(this.authService.isLoggedIn$, { initialValue: false });\n\n  // Use a signal to hold the dynamic login message\n  loginMessage = signal&lt;string&gt;(\"\"); // Initialize with an empty string\n\n  constructor() {\n    this.setupLoginSubscription();\n  }\n\n  private setupLoginSubscription(): void {\n    this.authService.isLoggedIn$\n      .pipe(\n        skip(1),\n        // Optional: Filter for only 'true' values if you only care about login events\n        filter((isLoggedIn) =&gt; isLoggedIn === true),\n        Automatically unsubscribe when the component is destroyed\n        takeUntilDestroyed(this.destroyRef)\n      )\n      .subscribe(() =&gt; {\n        console.log(\"LoginWatcherComponent: Detected LOGIN event!\");\n        // Use the signal's .set() method to update the state\n        this.loginMessage.set(\n          `Welcome back! Login detected at ${new Date().toLocaleTimeString()}`\n        );\n\n        // Clear the message after a few seconds using standard setTimeout\n        setTimeout(() =&gt; {\n          // Use .set() again to clear the signal's value\n          this.loginMessage.set(\"\");\n        }, 5000);\n      });\n\n    console.log(\n      \"LoginWatcherComponent initialized. Waiting for login events...\"\n    );\n  }\n}\n</code></pre> <p>Explanation of the Angular Example:</p> <ol> <li><code>AuthService</code> uses a <code>BehaviorSubject</code> (<code>loggedInStatus</code>) initialized to <code>false</code>.</li> <li><code>isLoggedIn</code> is created using toSignal, which converts the <code>isLoggedIn$</code> Observable into a signal. This is useful for displaying the current state reactively in the template (isLoggedIn()). <code>toSignal</code> requires an <code>initialValue</code>.</li> <li>The <code>skip(1)</code> operator intercepts the initial <code>false</code> emission and discards it.</li> <li>The <code>subscribe</code> block does not run initially.</li> <li>Later, if the user clicks the \"Log In\" button, <code>authService.login()</code> calls <code>this.loggedInStatus.next(true)</code>.</li> <li>This new value <code>true</code> is emitted by the <code>BehaviorSubject</code>.</li> <li><code>skip(1)</code> has already done its job (skipped one item), so it lets <code>true</code> pass through.</li> <li>The optional <code>filter(isLoggedIn =&gt; isLoggedIn === true)</code> also lets <code>true</code> pass.</li> <li>The <code>subscribe</code> block now executes, logging the message and updating the component's <code>loginMessage</code> property, because a new value was emitted after the initial skipped one.</li> </ol>"},{"location":"Operators/Filtering/skip/#summary","title":"Summary","text":"<p><code>skip(N)</code> is useful when you need to disregard a known number of initial emissions from an Observable stream, allowing you to focus on the values that come after that initial phase.</p>"},{"location":"Operators/Filtering/take/","title":"take","text":"<p><code>take()</code> is an RxJS operator that allows you to limit the number of values emitted by a source Observable. You specify a number, <code>N</code>, and <code>take(N)</code> will:</p> <ol> <li>Emit the first <code>N</code> values that come from the source Observable.</li> <li>As soon as the Nth value is emitted, it immediately sends a <code>complete</code> notification.</li> <li>It automatically unsubscribes from the source Observable.</li> </ol> <p>Think of it as telling the Observable, \"Just give me the first N things you have, and then you can stop.\" It's useful for dealing with streams that might emit many or even infinite values when you only need a limited number from the beginning.</p> <p>Key Characteristics:</p> <ul> <li>Limits Emissions: Only allows the first <code>N</code> values through.</li> <li>Completes the Stream: Automatically sends a <code>complete</code> notification after the Nth value.</li> <li>Unsubscribes from Source: Prevents further processing or potential memory leaks from the source after completion.</li> <li>Filtering/Completion: Acts as both a way to filter by count and a way to ensure completion.</li> </ul>"},{"location":"Operators/Filtering/take/#real-world-example-scenario","title":"Real-World Example Scenario","text":"<p>It's Thursday morning here in Bengaluru (around 8:30 AM IST). Imagine you have a feature where you want to allow the user to perform an action, but only permit them to do it a limited number of times within a certain context, perhaps the first 3 times they click a specific \"Try It\" button during a tutorial phase.</p> <p>Scenario: You have a button. You want to react to the user clicking it, but only respond to the first 3 clicks. After the third click, you want to ignore any subsequent clicks on that button for that specific stream instance. <code>take(3)</code> is perfect for this.</p>"},{"location":"Operators/Filtering/take/#code-snippet","title":"Code Snippet","text":"<pre><code>import {\n  Component,\n  OnInit,\n  OnDestroy,\n  ViewChild,\n  ElementRef,\n  inject,\n} from \"@angular/core\";\nimport { fromEvent, Subscription, take, tap } from \"rxjs\";\n\n@Component({\n  selector: \"app-take-demo\",\n  standalone: true,\n  imports: [],\n  template: `\n    &lt;h4&gt;Take Operator Demo&lt;/h4&gt;\n    &lt;p&gt;Reacting only to the first 3 clicks. Check the console.&lt;/p&gt;\n    &lt;button #actionButton class=\"btn btn-primary\"&gt;\n      Click Me (Max 3 Times)\n    &lt;/button&gt;\n    &lt;ul class=\"list-group mt-2\"&gt;\n      &lt;li\n        *ngFor=\"let log of clickLog\"\n        class=\"list-group-item list-group-item-sm small\"\n      &gt;\n        {{ log }}\n      &lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;p class=\"mt-2 small\"&gt;{{ completionStatus }}&lt;/p&gt;\n  `,\n})\nexport class TakeDemoComponent implements OnInit, OnDestroy {\n  @ViewChild(\"actionButton\") actionButton:\n    | ElementRef&lt;HTMLButtonElement&gt;\n    | undefined;\n\n  private clickSubscription: Subscription | undefined;\n  clickLog: string[] = [];\n  completionStatus = \"Stream active...\";\n\n  ngOnInit(): void {\n    if (!this.actionButton) {\n      return;\n    }\n\n    const buttonClicks$ = fromEvent(this.actionButton.nativeElement, \"click\");\n\n    this.clickSubscription = buttonClicks$\n      .pipe(\n        tap((event) =&gt; {\n          console.log(\n            `[${new Date().toLocaleTimeString()}] Button Clicked (Event before take)`\n          );\n        }),\n        take(3),\n        tap((event) =&gt; {\n          console.log(\n            `   [${new Date().toLocaleTimeString()}] Click passed through take()`\n          );\n        })\n      )\n      .subscribe({\n        next: (event: Event) =&gt; {\n          const message = `[${new Date().toLocaleTimeString()}] Processed Click #${\n            this.clickLog.length + 1\n          }`;\n          console.log(`      -&gt; ${message}`);\n          this.clickLog.push(message);\n        },\n        error: (err) =&gt; {\n          console.error(\"Stream error:\", err);\n          this.completionStatus = `Stream Error: ${err}`;\n        },\n        complete: () =&gt; {\n          const message = `[${new Date().toLocaleTimeString()}] Stream Completed by take(3) after 3 emissions.`;\n          console.log(message);\n          this.completionStatus = message;\n          if (this.actionButton) {\n            // Optional: Disable button after completion\n            // this.actionButton.nativeElement.disabled = true;\n          }\n        },\n      });\n  }\n\n  ngOnDestroy(): void {\n    if (this.clickSubscription) {\n      this.clickSubscription.unsubscribe();\n      console.log(\"Take demo subscription stopped on component destroy.\");\n    }\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>fromEvent(...)</code>: Creates an Observable that emits an event every time the button is clicked. This stream could potentially go on forever.</li> <li><code>tap(...)</code> (before take): Logs every single click event that <code>fromEvent</code> emits, just to show they are happening.</li> <li><code>take(3)</code>: This operator is applied. It will allow the first click event to pass through. It will allow the second click event to pass through. It will allow the third click event to pass through.</li> <li>After the third click event passes through: <code>take(3)</code> immediately sends the <code>complete</code> notification down the stream and unsubscribes from the <code>buttonClicks$</code> source.</li> <li><code>tap(...)</code> (after take): Logs only those clicks that were allowed through by <code>take(3)</code>.</li> <li><code>subscribe({...})</code>:<ul> <li>The <code>next</code> handler executes only for the first 3 clicks.</li> <li>The <code>complete</code> handler executes immediately after the 3rd click is processed. The log message confirms this.</li> <li>Any clicks on the button after the third one will not trigger any logging from the taps or the <code>next</code> handler because the subscription managed by <code>take(3)</code> is already finished and unsubscribed from the source.</li> </ul> </li> </ol>"},{"location":"Operators/Filtering/take/#summary","title":"Summary","text":"<p><code>take(N)</code> is a convenient way to limit the number of emissions you care about from an Observable and automatically ensure the stream completes and cleans up after itself once that limit is reached. It's very useful for handling \"first N\" scenarios or for putting a definite end on potentially infinite streams like <code>interval</code> or UI events.</p>"},{"location":"Operators/Filtering/takeUntil/","title":"takeUntil","text":"<p><code>takeUntil()</code> is an RxJS operator primarily used for managing the lifetime of an Observable stream, effectively acting as a completion operator. It mirrors the source Observable, allowing its values to pass through, until a second Observable, called the <code>notifier</code>, emits its first value or completes.</p> <p>As soon as the <code>notifier</code> Observable emits any value or completes, <code>takeUntil()</code> immediately:</p> <ol> <li>Sends a <code>complete</code> notification for the stream it's operating on.</li> <li>Unsubscribes from both the source Observable and the <code>notifier</code> Observable.</li> </ol> <p>The actual value emitted by the <code>notifier</code> doesn't matter; <code>takeUntil</code> only cares about the event of an emission (or completion) from the <code>notifier</code>.</p>"},{"location":"Operators/Filtering/takeUntil/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Conditional Completion: Completes the main stream based on an external signal (the <code>notifier</code>).</li> <li>Takes a Notifier Observable: You provide the Observable that signals when to stop: <code>takeUntil(notifier$)</code>.</li> <li>Passes Source Values: Emits values from the source until the notification occurs.</li> <li>Automatic Unsubscription: Handles cleanup by unsubscribing from both streams upon completion.</li> </ul>"},{"location":"Operators/Filtering/takeUntil/#real-world-example-scenario","title":"Real-World Example Scenario","text":"<p>The most common and idiomatic use case for <code>takeUntil()</code> in Angular is to automatically unsubscribe from Observables when a component is destroyed. This prevents memory leaks, which can occur if subscriptions remain active after a component is removed from the DOM.</p> <p>Scenario: You have an Angular component that needs to perform a periodic action, perhaps updating a timer displayed on the screen every second using <code>interval(1000)</code>. This interval would run forever if not stopped. You need to ensure that when the user navigates away from the component (and it gets destroyed), the interval subscription is automatically cleaned up. <code>takeUntil()</code> combined with a <code>Subject</code> triggered in <code>ngOnDestroy</code> is the standard pattern for this.</p>"},{"location":"Operators/Filtering/takeUntil/#code-snippet","title":"Code Snippet","text":"<pre><code>import { Component, OnInit, OnDestroy } from \"@angular/core\";\nimport { Subject, interval, takeUntil, tap } from \"rxjs\";\n\n@Component({\n  selector: \"app-take-until-demo\",\n  standalone: true,\n  imports: [],\n  template: `\n    &lt;h4&gt;TakeUntil Demo&lt;/h4&gt;\n    &lt;p&gt;Timer running (check console). It stops when component is destroyed.&lt;/p&gt;\n    &lt;p&gt;Current count: {{ currentCount }}&lt;/p&gt;\n  `,\n})\nexport class TakeUntilDemoComponent implements OnInit, OnDestroy {\n  currentCount = 0;\n  private destroy$ = new Subject&lt;void&gt;();\n\n  ngOnInit(): void {\n    console.log(\n      `[${new Date().toLocaleTimeString()}] Component Init - Starting Interval`\n    );\n    interval(1000)\n      .pipe(\n        tap((count) =&gt;\n          console.log(\n            `[${new Date().toLocaleTimeString()}] Interval emitted: ${count}`\n          )\n        ),\n        takeUntil(this.destroy$)\n      )\n      .subscribe({\n        next: (count) =&gt; (this.currentCount = count),\n        complete: () =&gt;\n          console.log(\n            `[${new Date().toLocaleTimeString()}] Interval stream completed via takeUntil.`\n          ),\n      });\n  }\n\n  ngOnDestroy(): void {\n    console.log(\n      `[${new Date().toLocaleTimeString()}] Component Destroy - Signaling takeUntil`\n    );\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>destroy$ = new Subject&lt;void&gt;()</code>: A private <code>Subject</code> is created. This will act as our <code>notifier</code>.</li> <li><code>interval(1000).pipe(...)</code>: We create an Observable that emits numbers every second.</li> <li><code>takeUntil(this.destroy$)</code>: This is the key. The <code>interval</code> stream will continue emitting values until the <code>this.destroy$</code> Subject emits a value.</li> <li><code>subscribe({...})</code>: We subscribe to process the values from the interval.</li> <li><code>ngOnDestroy()</code>: This Angular lifecycle hook is guaranteed to run when the component is about to be destroyed.<ul> <li><code>this.destroy$.next()</code>: We emit a dummy value (<code>void</code>) from our <code>destroy$</code> Subject.</li> <li><code>this.destroy$.complete()</code>: It's good practice to also complete the Subject.</li> </ul> </li> <li>Behavior: As soon as <code>this.destroy$.next()</code> is called in <code>ngOnDestroy</code>, the <code>takeUntil(this.destroy$)</code> operator detects this emission. It immediately completes the <code>interval</code> stream (triggering the <code>complete</code> handler in the subscription) and unsubscribes from <code>interval</code>. No more values will be processed, and the interval timer stops, preventing a memory leak.</li> </ol>"},{"location":"Operators/Filtering/takeUntil/#summary","title":"Summary","text":"<p><code>takeUntil()</code> provides a clean, declarative way to complete an Observable stream based on a signal from another Observable, making it the standard and recommended pattern for managing subscription lifetimes tied to Angular component lifecycles.</p>"},{"location":"Operators/Multicasting/share/","title":"share","text":"<p>Like <code>shareReplay</code>, the <code>share</code> operator is used to share a single subscription to an underlying source Observable among multiple downstream subscribers. This prevents the source Observable's logic (e.g., setting up an interval, making a connection) from executing multiple times.</p> <p>However, <code>share</code> behaves like it's using a plain <code>Subject</code> internally for multicasting. This means:</p> <ol> <li>Shares a Single Subscription: It subscribes to the source Observable only when the first subscriber arrives.</li> <li>Multicasts Live Values: It pushes values from the source to all currently active subscribers.</li> <li>No Replay: If a subscriber joins after the source has already emitted some values, that new subscriber will not receive those past values. They will only get emissions that happen after they subscribed.</li> <li>Reference Counting: It uses reference counting (<code>refCount</code> is implicitly true). The subscription to the source is active only as long as there's at least one downstream subscriber. When the last subscriber leaves, <code>share</code> unsubscribes from the source. If a new subscriber arrives later, it will re-subscribe to the source, potentially restarting it.</li> </ol>"},{"location":"Operators/Multicasting/share/#analogy","title":"Analogy","text":"<p>Think of a live conference call or radio talk show without any recording.</p> <ul> <li>The Show/Call (Source Observable): The conversation happening in real-time.</li> <li>The Broadcast System (<code>share</code>): Connects to the live show once when the first listener joins.</li> <li>Listeners (Subscribers): People joining the call/tuning in.</li> <li>Everyone currently listening hears the same thing at the same time.</li> <li>If you join late, you missed the beginning. You only hear the conversation from the moment you joined onwards. There's no way to hear what was said before you connected.</li> <li>If everyone hangs up/tunes out, the broadcast system disconnects from the show. If someone calls in again later, it reconnects, and the show might start fresh (depending on the source).</li> </ul>"},{"location":"Operators/Multicasting/share/#why-use-share-and-when-not-to","title":"Why Use <code>share</code> (and when not to)?","text":""},{"location":"Operators/Multicasting/share/#use-cases","title":"Use Cases:","text":"<ul> <li>Sharing Observables where past values are irrelevant or shouldn't be replayed (e.g., live event streams, certain WebSocket scenarios where only future messages matter).</li> <li>Sharing \"hot\" Observables or Observables with side effects that should only occur once while there are active listeners (e.g., setting up an interval-based check that runs only when needed).</li> </ul>"},{"location":"Operators/Multicasting/share/#when-not-to-use","title":"When NOT to Use","text":"<ul> <li>HTTP Requests (usually): For typical <code>HttpClient</code> GET requests, you almost always want the result cached and replayed. Use <code>shareReplay({ bufferSize: 1, refCount: true })</code> instead. Using <code>share</code> would mean that if a second component subscribes slightly after the first, and the HTTP request has already completed, the second component might get nothing (if the source completes quickly).</li> <li>State Management: You typically want the current state value replayed, making <code>BehaviorSubject</code> or <code>shareReplay({ bufferSize: 1, ... })</code> more suitable.</li> </ul>"},{"location":"Operators/Multicasting/share/#real-world-example-shared-interval-timer-for-periodic-ui-updates","title":"Real-World Example: Shared Interval Timer for Periodic UI Updates","text":"<p>Imagine you want a timer that ticks every few seconds, and multiple components need to react to these ticks (e.g., to refresh some status indicator). You only want one actual <code>interval</code> timer running in the background, shared among them. New components subscribing should just sync up with the next tick, not get past ticks.</p> <p>Code Snippets:</p> <p>1. Shared Timer Service (<code>timer.service.ts</code>)</p> <pre><code>import { Injectable } from \"@angular/core\";\nimport { Observable, interval, share, tap, map } from \"rxjs\";\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class SharedTimerService {\n  // The shared timer observable\n  readonly sharedTicks$: Observable&lt;number&gt;;\n\n  constructor() {\n    // Create ONE interval timer\n    this.sharedTicks$ = interval(2000).pipe(\n      // Emit every 2 seconds\n      tap((tick) =&gt;\n        console.log(\n          `%c --- Source Interval Emitted: ${tick} --- `,\n          \"background: #eee; color: #999\"\n        )\n      ),\n      // --- Key Operator ---\n      // Share this single interval subscription among all subscribers.\n      // No replay for late subscribers.\n      share()\n      // --------------------\n      // Note: share() is roughly equivalent to:\n      // multicast(() =&gt; new Subject()), // Use a plain Subject (no replay)\n      // refCount() // Start/stop based on subscriber count\n    );\n  }\n}\n</code></pre> <p>2. Component Displaying Ticks</p> <pre><code>import {\n  Component,\n  inject,\n  signal,\n  OnInit,\n  OnDestroy,\n  DestroyRef,\n} from \"@angular/core\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\nimport { SharedTimerService } from \"./timer.service\"; // Adjust path\n\n@Component({\n  selector: \"app-tick-display-a\",\n  standalone: true,\n  template: `\n    &lt;div class=\"display-box\"&gt;\n      &lt;h4&gt;Tick Display A&lt;/h4&gt;\n      &lt;p&gt;Started Subscribing Immediately&lt;/p&gt;\n      &lt;p&gt;Last Tick Received: {{ lastTick() }}&lt;/p&gt;\n    &lt;/div&gt;\n  `,\n  styles: [\n    \".display-box { border: 1px solid purple; padding: 10px; margin: 10px; }\",\n  ],\n})\nexport class TickDisplayAComponent implements OnInit {\n  private timerService = inject(SharedTimerService);\n  private destroyRef = inject(DestroyRef);\n\n  lastTick = signal&lt;number | string&gt;(\"Waiting...\");\n\n  ngOnInit(): void {\n    console.log(\"TickDisplayA: Subscribing to sharedTicks$\");\n    this.timerService.sharedTicks$\n      .pipe(takeUntilDestroyed(this.destroyRef))\n      .subscribe((tickValue) =&gt; {\n        console.log(`TickDisplayA: Received tick ${tickValue}`);\n        this.lastTick.set(tickValue);\n      });\n  }\n}\n</code></pre> <p>3. Another Component Displaying Ticks - Subscribes Late</p> <pre><code>import {\n  Component,\n  inject,\n  signal,\n  OnInit,\n  OnDestroy,\n  DestroyRef,\n} from \"@angular/core\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\nimport { SharedTimerService } from \"./timer.service\"; // Adjust path\n\n@Component({\n  selector: \"app-tick-display-b\",\n  standalone: true,\n  template: `\n    &lt;div class=\"display-box\" style=\"border-color: teal;\"&gt;\n      &lt;h4&gt;Tick Display B&lt;/h4&gt;\n      &lt;p&gt;Started Subscribing After 5 Seconds&lt;/p&gt;\n      &lt;p&gt;Last Tick Received: {{ lastTick() }}&lt;/p&gt;\n    &lt;/div&gt;\n  `,\n  styles: [\n    \".display-box { border: 1px solid purple; padding: 10px; margin: 10px; }\",\n  ],\n})\nexport class TickDisplayBComponent implements OnInit {\n  private timerService = inject(SharedTimerService);\n  private destroyRef = inject(DestroyRef);\n\n  lastTick = signal&lt;number | string&gt;(\"Waiting...\");\n\n  ngOnInit(): void {\n    // Simulate this component loading or deciding to subscribe later\n    setTimeout(() =&gt; {\n      console.log(\"TickDisplayB: Subscribing to sharedTicks$ (after delay)\");\n      this.timerService.sharedTicks$\n        .pipe(takeUntilDestroyed(this.destroyRef))\n        .subscribe((tickValue) =&gt; {\n          // *** Key Point ***\n          // This will likely NOT receive tick 0 or 1, because it subscribed late.\n          // It will receive the next tick emitted by the *already running* interval.\n          console.log(`TickDisplayB: Received tick ${tickValue}`);\n          this.lastTick.set(tickValue);\n        });\n    }, 5000); // Subscribe after 5 seconds\n  }\n}\n</code></pre> <p>4. App Component</p> <pre><code>import { Component } from \"@angular/core\";\nimport { TickDisplayAComponent } from \"./tick-display-a.component\"; // Adjust path\nimport { TickDisplayBComponent } from \"./tick-display-b.component\"; // Adjust path\n\n@Component({\n  selector: \"app-root\",\n  standalone: true,\n  imports: [TickDisplayAComponent, TickDisplayBComponent], // Import components\n  template: `\n    &lt;h1&gt;RxJS share Demo&lt;/h1&gt;\n    &lt;app-tick-display-a&gt;&lt;/app-tick-display-a&gt;\n    &lt;app-tick-display-b&gt;&lt;/app-tick-display-b&gt;\n  `,\n})\nexport class AppComponent {}\n</code></pre> <p>Explanation:</p> <ol> <li><code>SharedTimerService</code> creates an <code>interval(2000)</code> Observable and applies <code>share()</code> to it, storing the result in <code>sharedTicks$</code>.</li> <li><code>TickDisplayAComponent</code> subscribes immediately in <code>ngOnInit</code>. This is the first subscription. <code>share</code> subscribes to the source <code>interval</code>, which starts emitting 0, 1, 2... every 2 seconds. Component A receives all these ticks.</li> <li><code>TickDisplayBComponent</code> waits 5 seconds before subscribing in its <code>ngOnInit</code>.</li> <li>When Component B subscribes, the source <code>interval</code> (shared via <code>share</code>) is already running and might have already emitted ticks 0 and 1.</li> <li>Component B will not receive ticks 0 and 1. Its subscription will start receiving ticks from the next emission of the shared interval (likely tick 2 or 3, depending on timing).</li> <li>Both components receive subsequent ticks (3, 4, 5...) simultaneously as they are emitted by the single, shared interval.</li> <li>If both components are destroyed, their subscriptions (managed by <code>takeUntilDestroyed</code>) end. <code>share</code> sees the subscriber count is zero and unsubscribes from the source <code>interval</code>, stopping it.</li> </ol> <p>This demonstrates how <code>share</code> provides a way to execute a source Observable once and multicast its live values, without the buffering and replay behaviour of <code>shareReplay</code>.</p>"},{"location":"Operators/Multicasting/shareReplay/","title":"shareReplay","text":"<p>Imagine you have an Observable that does some expensive work when someone subscribes (like making an HTTP request). If multiple parts of your application subscribe to this same Observable independently, the expensive work will happen multiple times (multiple identical HTTP requests!).</p> <p><code>shareReplay</code> solves this by:</p> <ol> <li>Sharing a Single Subscription: It ensures that only one subscription is ever made to the original source Observable, no matter how many downstream subscribers there are.</li> <li>Multicasting Results: It takes the values emitted by that single source subscription and broadcasts them to all downstream subscribers.</li> <li>Replaying Buffered Values: It keeps a buffer of the most recent values (you specify how many) and immediately sends those buffered values to any new subscriber that joins later.</li> </ol>"},{"location":"Operators/Multicasting/shareReplay/#analogy","title":"Analogy","text":"<p>Think of watching a live stream on the internet that also has DVR/replay capabilities.</p> <ul> <li>The Original Broadcast (Source Observable): The actual live event happening once.</li> <li>The Streaming Service (<code>shareReplay</code>): It takes the single live broadcast.</li> <li>Viewers (Subscribers): People tuning in to watch.</li> <li>The first viewer causes the streaming service to connect to the original broadcast.</li> <li>All viewers watch the same broadcast via the streaming service (multicasting).</li> <li>Someone tuning in late can immediately see the last few minutes (replaying the buffer) before catching up to the live feed.</li> <li>The streaming service only needs one connection to the original broadcast source, regardless of how many viewers there are.</li> </ul>"},{"location":"Operators/Multicasting/shareReplay/#key-configuration","title":"Key Configuration","text":"<p><code>shareReplay</code> is typically configured with an object: <code>shareReplay({ bufferSize: 1, refCount: true })</code></p> <ul> <li><code>bufferSize</code>: How many of the latest emissions to buffer and replay to new subscribers.</li> <li><code>bufferSize: 1</code> is very common, especially for HTTP requests where you just want the single result cached and shared.</li> <li><code>refCount</code>: (Reference Counting) This is crucial!</li> <li><code>refCount: true</code>: The operator keeps track of how many active subscribers there are. It subscribes to the source Observable only when the first subscriber arrives. It unsubscribes from the source Observable when the last subscriber unsubscribes. This is usually what you want for things like HTTP requests to avoid keeping connections or resources active unnecessarily. If a new subscriber arrives later, it will re-subscribe to the source.</li> <li><code>refCount: false</code>: The subscription to the source Observable, once established by the first subscriber, stays active forever (or until the source completes/errors), even if all subscribers leave. Use this only if you intend for the source to keep running in the background regardless of subscribers.</li> </ul>"},{"location":"Operators/Multicasting/shareReplay/#real-world-example-efficiently-fetching-shared-configuration-data","title":"Real-World Example: Efficiently Fetching Shared Configuration Data","text":"<p>Imagine multiple components in your application need access to some configuration data fetched from an API endpoint (<code>/api/config</code>). Without <code>shareReplay</code>, each component subscribing to the fetch operation would trigger a separate HTTP GET request.</p> <p>Code Snippets:</p> <p>1. Configuration Service (<code>config.service.ts</code>)</p> <pre><code>import { Injectable, inject } from \"@angular/core\";\nimport { HttpClient } from \"@angular/common/http\";\nimport { Observable, shareReplay, tap, timer, switchMap } from \"rxjs\";\n\nexport interface AppConfig {\n  apiUrl: string;\n  featureFlags: {\n    newDashboard: boolean;\n    betaTesting: boolean;\n  };\n  theme: string;\n}\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class ConfigService {\n  private http = inject(HttpClient);\n  private configUrl = \"/api/app-config\"; // Your API endpoint\n\n  // --- Shared Config Observable ---\n  // This is the Observable that components will subscribe to.\n  readonly config$: Observable&lt;AppConfig&gt;;\n\n  constructor() {\n    // Make the HTTP request ONLY ONCE and share the result.\n    this.config$ = this.http.get&lt;AppConfig&gt;(this.configUrl).pipe(\n      tap(() =&gt;\n        console.log(\n          \"%c Fetching application config from API... \",\n          \"background: #ffcc00; color: black;\"\n        )\n      ),\n      // --- Key Operator ---\n      shareReplay({\n        bufferSize: 1, // Cache and replay the single config object\n        refCount: true, // Unsubscribe from HTTP when no components are listening\n      })\n      // --------------------\n    );\n\n    // Example of a source that emits periodically - shareReplay works here too\n    // this.config$ = timer(0, 5000).pipe( // Emit every 5 seconds\n    //   switchMap(() =&gt; this.http.get&lt;AppConfig&gt;(this.configUrl)),\n    //   tap(() =&gt; console.log('%c Fetching application config from API... ', 'background: #ffcc00; color: black;')),\n    //   shareReplay({ bufferSize: 1, refCount: true })\n    // );\n  }\n\n  // You might still have methods for specific actions, but data access is via config$\n}\n</code></pre> <p>2. Component A - Consumes Config</p> <pre><code>import {\n  Component,\n  inject,\n  signal,\n  OnInit,\n  DestroyRef,\n  ChangeDetectionStrategy,\n} from \"@angular/core\";\nimport { CommonModule } from \"@angular/common\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\nimport { ConfigService, AppConfig } from \"./config.service\"; // Adjust path\n\n@Component({\n  selector: \"app-comp-a\",\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    &lt;div class=\"component-box\"&gt;\n      &lt;h4&gt;Component A&lt;/h4&gt;\n      @if (config()) {\n      &lt;p&gt;API URL: {{ config()?.apiUrl }}&lt;/p&gt;\n      &lt;p&gt;Theme: {{ config()?.theme }}&lt;/p&gt;\n      } @else {\n      &lt;p&gt;Loading config...&lt;/p&gt;\n      }\n    &lt;/div&gt;\n  `,\n  styles: [\n    \".component-box { border: 1px solid blue; padding: 10px; margin: 10px; }\",\n  ],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class CompAComponent implements OnInit {\n  private configService = inject(ConfigService);\n  private destroyRef = inject(DestroyRef);\n\n  config = signal&lt;AppConfig | null&gt;(null);\n\n  ngOnInit(): void {\n    console.log(\"CompA: Subscribing to config$\");\n    this.configService.config$\n      .pipe(takeUntilDestroyed(this.destroyRef))\n      .subscribe((cfg) =&gt; {\n        console.log(\"CompA: Received config\", cfg);\n        this.config.set(cfg);\n      });\n  }\n}\n</code></pre> <p>3. Component B - Consumes Config</p> <pre><code>import {\n  Component,\n  inject,\n  signal,\n  OnInit,\n  DestroyRef,\n  ChangeDetectionStrategy,\n} from \"@angular/core\";\nimport { CommonModule } from \"@angular/common\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\nimport { ConfigService, AppConfig } from \"./config.service\"; // Adjust path\n\n@Component({\n  selector: \"app-comp-b\",\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    &lt;div class=\"component-box\" style=\"border-color: green;\"&gt;\n      &lt;h4&gt;Component B&lt;/h4&gt;\n      @if (config()) {\n      &lt;p&gt;\n        New Dashboard Feature:\n        {{ config()?.featureFlags?.newDashboard ? \"ENABLED\" : \"DISABLED\" }}\n      &lt;/p&gt;\n      &lt;p&gt;\n        Beta Testing: {{ config()?.featureFlags?.betaTesting ? \"ON\" : \"OFF\" }}\n      &lt;/p&gt;\n      } @else {\n      &lt;p&gt;Loading config...&lt;/p&gt;\n      }\n    &lt;/div&gt;\n  `,\n  styles: [\n    \".component-box { border: 1px solid blue; padding: 10px; margin: 10px; }\",\n  ],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class CompBComponent implements OnInit {\n  private configService = inject(ConfigService);\n  private destroyRef = inject(DestroyRef);\n\n  config = signal&lt;AppConfig | null&gt;(null);\n\n  ngOnInit(): void {\n    console.log(\"CompB: Subscribing to config$\");\n    // Simulate CompB loading slightly later\n    setTimeout(() =&gt; {\n      this.configService.config$\n        .pipe(takeUntilDestroyed(this.destroyRef))\n        .subscribe((cfg) =&gt; {\n          console.log(\"CompB: Received config\", cfg);\n          this.config.set(cfg);\n        });\n    }, 50); // Simulate slight delay\n  }\n}\n</code></pre> <p>4. App Component</p> <pre><code>import { Component } from \"@angular/core\";\nimport { CompAComponent } from \"./comp-a.component\"; // Adjust path\nimport { CompBComponent } from \"./comp-b.component\"; // Adjust path\n\n@Component({\n  selector: \"app-root\",\n  standalone: true,\n  imports: [CompAComponent, CompBComponent], // Import components\n  template: `\n    &lt;h1&gt;RxJS shareReplay Demo&lt;/h1&gt;\n    &lt;app-comp-a&gt;&lt;/app-comp-a&gt;\n    &lt;app-comp-b&gt;&lt;/app-comp-b&gt;\n  `,\n})\nexport class AppComponent {}\n</code></pre> <p>Explanation:</p> <ol> <li>The <code>ConfigService</code> defines <code>config$</code>. Inside the constructor, it chains <code>http.get(...)</code> with <code>tap()</code> (for logging the fetch attempt) and then <code>shareReplay({ bufferSize: 1, refCount: true })</code>.</li> <li>When <code>CompAComponent</code> initializes (<code>ngOnInit</code>), it subscribes to <code>configService.config$</code>. This is the first subscription.</li> <li>Because it's the first subscription and <code>refCount</code> is true, <code>shareReplay</code> subscribes to its source (the <code>http.get</code>). The HTTP request is made. You'll see the \"Fetching application config from API...\" log message once.</li> <li>When the HTTP request completes, <code>shareReplay</code> receives the <code>AppConfig</code> data. It buffers this single value (<code>bufferSize: 1</code>) and sends it to <code>CompAComponent</code>.</li> <li>A moment later, <code>CompBComponent</code> initializes and subscribes to the same <code>configService.config$</code>.</li> <li>Because <code>shareReplay</code> already has an active source subscription and a buffered value, it does not trigger a new HTTP request. Instead, it immediately replays the buffered <code>AppConfig</code> value to <code>CompBComponent</code>. You will not see the \"Fetching...\" log message a second time.</li> <li>Both components now have the same configuration data, fetched with only a single API call.</li> <li>If both <code>CompA</code> and <code>CompB</code> were destroyed (causing their subscriptions via <code>takeUntilDestroyed</code> to end), <code>shareReplay</code> (because <code>refCount: true</code>) would notice the subscriber count dropped to zero and would unsubscribe from the source <code>http.get</code> Observable. If a new component subscribed later, the fetch process would start again.</li> </ol>"},{"location":"Operators/Multicasting/shareReplay/#summary","title":"Summary","text":"<p><code>shareReplay</code> is essential for optimizing applications by preventing redundant work and ensuring multiple parts of your UI react to the same shared data stream efficiently.</p>"},{"location":"Operators/Subjects/behaviorSubject/","title":"behaviorSubject","text":"<p>A <code>BehaviorSubject</code> is a special type of <code>Subject</code> with two key distinctions:</p> <ol> <li>Requires an Initial Value: You must provide a starting value when you create a <code>BehaviorSubject</code>.</li> <li>Emits Current Value on Subscription: When a new Observer subscribes, a <code>BehaviorSubject</code> immediately emits its most recent value (the \"current\" value) to that new subscriber. If no <code>next()</code> calls have happened yet, it emits the initial value.</li> </ol> <p>Think of it like a whiteboard or a notice board:</p> <ul> <li>It always has something written on it (the initial value).</li> <li>Whenever someone updates the board (<code>next()</code> is called), the message changes.</li> <li>Anyone who walks up to the board (subscribes) immediately sees the message currently written on it. They don't have to wait for the next update to know the current status.</li> </ul> <p>Like a regular <code>Subject</code>, it still multicasts \u2013 pushing values to all current subscribers when <code>next()</code> is called.</p>"},{"location":"Operators/Subjects/behaviorSubject/#why-use-a-behaviorsubject","title":"Why Use a <code>BehaviorSubject</code>?","text":"<p><code>BehaviorSubject</code> is excellent for managing state because application state usually always has a current value.</p> <ol> <li>Representing State: Perfect for things like:<ul> <li>Current user authentication status (e.g., <code>null</code> initially, then a <code>User</code> object).</li> <li>Currently selected theme ('light' or 'dark').</li> <li>The latest value of filters applied to a list.</li> <li>Configuration settings.</li> </ul> </li> <li>Providing Initial Data: Components often need to know the current state as soon as they initialize to render correctly. <code>BehaviorSubject</code> guarantees they get a value immediately upon subscription.</li> <li>Synchronous Access (Use Sparingly): <code>BehaviorSubject</code> has a <code>getValue()</code> method that allows you to synchronously get its current value without subscribing. While useful occasionally, relying heavily on this can be an anti-pattern compared to reactive subscriptions. Signals often provide a better way to get current values reactively.</li> </ol>"},{"location":"Operators/Subjects/behaviorSubject/#real-world-example-application-theme-service","title":"Real-World Example: Application Theme Service","text":"<p>Let's create a service that manages the application's theme (e.g., 'light' or 'dark'). The theme always has a current state, and components need to know the current theme immediately when they load.</p>"},{"location":"Operators/Subjects/behaviorSubject/#code-snippets","title":"Code Snippets","text":"<p>1. Theme Service (<code>theme.service.ts</code>)</p> <pre><code>import { Injectable } from \"@angular/core\";\nimport { BehaviorSubject, Observable } from \"rxjs\";\n\nexport type AppTheme = \"light\" | \"dark\";\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class ThemeService {\n  // 1. Define the initial theme state.\n  private initialTheme: AppTheme = \"light\";\n\n  // 2. Create the BehaviorSubject with the initial value.\n  // Private to control who can emit new values.\n  private themeSubject = new BehaviorSubject&lt;AppTheme&gt;(this.initialTheme);\n\n  // 3. Expose the theme state as an Observable for components to subscribe to.\n  // '.asObservable()' prevents external code from calling .next() on our subject.\n  theme$: Observable&lt;AppTheme&gt; = this.themeSubject.asObservable();\n\n  // Method to change the theme\n  setTheme(newTheme: AppTheme): void {\n    if (newTheme !== this.getCurrentTheme()) {\n      // Optional: Prevent emitting same value\n      console.log(`ThemeService: Setting theme to ${newTheme}`);\n      // 4. Emit the new theme value to all subscribers.\n      this.themeSubject.next(newTheme);\n    }\n  }\n\n  // Method to get the current value synchronously (use with caution)\n  getCurrentTheme(): AppTheme {\n    return this.themeSubject.getValue();\n  }\n}\n</code></pre> <p>2. Theme Switcher Component - Changes the theme</p> <pre><code>import { Component, inject } from \"@angular/core\";\nimport { ThemeService, AppTheme } from \"./theme.service\"; // Adjust path\n\n@Component({\n  selector: \"app-theme-switcher\",\n  standalone: true,\n  template: `\n    &lt;div&gt;\n      &lt;label&gt;Select Theme: &lt;/label&gt;\n      &lt;button (click)=\"setTheme('light')\" [disabled]=\"currentTheme === 'light'\"&gt;\n        Light\n      &lt;/button&gt;\n      &lt;button (click)=\"setTheme('dark')\" [disabled]=\"currentTheme === 'dark'\"&gt;\n        Dark\n      &lt;/button&gt;\n      &lt;p&gt;\n        &lt;small&gt;Current theme in service: {{ currentTheme }}&lt;/small&gt;\n      &lt;/p&gt;\n    &lt;/div&gt;\n  `,\n  styles: [\n    \"div { margin-bottom: 15px; padding: 10px; border: 1px dashed grey; }\",\n  ],\n})\nexport class ThemeSwitcherComponent {\n  private themeService = inject(ThemeService);\n\n  // Get the current theme synchronously for the button state (demonstration)\n  get currentTheme(): AppTheme {\n    return this.themeService.getCurrentTheme();\n  }\n\n  setTheme(theme: AppTheme): void {\n    this.themeService.setTheme(theme);\n  }\n}\n</code></pre> <p>3. Themed Content Component - Reacts to the theme</p> <pre><code>import {\n  Component,\n  inject,\n  signal,\n  OnInit,\n  DestroyRef,\n  ChangeDetectionStrategy,\n  HostBinding,\n} from \"@angular/core\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\nimport { ThemeService, AppTheme } from \"./theme.service\"; // Adjust path\n\n@Component({\n  selector: \"app-themed-content\",\n  standalone: true,\n  template: `\n    &lt;div class=\"content\"&gt;\n      &lt;h3&gt;Themed Content&lt;/h3&gt;\n      &lt;p&gt;\n        My current theme is: &lt;strong&gt;{{ currentThemeSignal() }}&lt;/strong&gt;\n      &lt;/p&gt;\n      &lt;p&gt;I received this theme immediately when I loaded!&lt;/p&gt;\n    &lt;/div&gt;\n  `,\n  styles: [\n    `\n      :host(.dark-theme) .content {\n        background-color: #333;\n        color: white;\n        border: 1px solid yellow;\n      }\n      :host(.light-theme) .content {\n        background-color: #f4f4f4;\n        color: black;\n        border: 1px solid blue;\n      }\n      .content {\n        padding: 20px;\n        margin-top: 10px;\n        transition: all 0.3s ease;\n      }\n    `,\n  ],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class ThemedContentComponent implements OnInit {\n  private themeService = inject(ThemeService);\n  private destroyRef = inject(DestroyRef);\n\n  // Signal to hold the current theme for the template\n  currentThemeSignal = signal&lt;AppTheme&gt;(\"light\"); // Initialize with default\n\n  // Use HostBinding to apply theme class to the component's host element\n  @HostBinding(\"class.dark-theme\") isDark = false;\n  @HostBinding(\"class.light-theme\") isLight = true;\n\n  ngOnInit(): void {\n    // Subscribe to the theme state from the service\n    this.themeService.theme$\n      .pipe(\n        // Automatically unsubscribe when the component is destroyed\n        takeUntilDestroyed(this.destroyRef)\n      )\n      .subscribe((theme) =&gt; {\n        // *** Key Point ***\n        // This code runs IMMEDIATELY when ngOnInit executes because\n        // BehaviorSubject emits the current value ('light') upon subscription.\n        console.log(`ThemedContentComponent received theme: ${theme}`);\n\n        // Update the signal for the template\n        this.currentThemeSignal.set(theme);\n\n        // Update host bindings for styling\n        this.isDark = theme === \"dark\";\n        this.isLight = theme === \"light\";\n      });\n  }\n}\n</code></pre> <p>4. App Component</p> <pre><code>import { Component } from \"@angular/core\";\nimport { ThemeSwitcherComponent } from \"./theme-switcher.component\"; // Adjust path\nimport { ThemedContentComponent } from \"./themed-content.component\"; // Adjust path\n\n@Component({\n  selector: \"app-root\",\n  standalone: true,\n  imports: [ThemeSwitcherComponent, ThemedContentComponent], // Import components\n  template: `\n    &lt;h1&gt;RxJS BehaviorSubject Demo&lt;/h1&gt;\n    &lt;app-theme-switcher&gt;&lt;/app-theme-switcher&gt;\n    &lt;app-themed-content&gt;&lt;/app-themed-content&gt;\n  `,\n})\nexport class AppComponent {}\n</code></pre> <p>Explanation:</p> <ol> <li><code>ThemeService</code> creates a <code>BehaviorSubject</code> called <code>themeSubject</code> initialized with <code>'light'</code>.</li> <li>It exposes <code>theme$</code> as an observable.</li> <li>When <code>ThemedContentComponent</code> initializes (<code>ngOnInit</code>), it subscribes to <code>themeService.theme$</code>.</li> <li>Crucially: Because it's a <code>BehaviorSubject</code>, the subscription immediately receives the current value (<code>'light'</code>) without waiting for <code>setTheme</code> to be called. The component can instantly update its <code>currentThemeSignal</code> and apply the correct styling.</li> <li>When the user clicks buttons in <code>ThemeSwitcherComponent</code>, <code>themeService.setTheme()</code> is called.</li> <li>This calls <code>themeSubject.next(newTheme)</code>, broadcasting the new theme to all subscribers.</li> <li><code>ThemedContentComponent</code>'s subscription receives the new theme, updates its signal (<code>currentThemeSignal</code>), and its appearance changes accordingly.</li> </ol> <p>Compare this to a regular <code>Subject</code>: If we used a plain <code>Subject</code> without an initial value, <code>ThemedContentComponent</code> wouldn't know the theme when it first loaded. It would only react after the user first clicked a button in the <code>ThemeSwitcherComponent</code>. <code>BehaviorSubject</code> solves this by providing that essential current state immediately.</p>"},{"location":"Operators/Subjects/replaySubject/","title":"replaySubject","text":"<p>Think of a <code>ReplaySubject</code> as a <code>Subject</code> that records a history of the values that have passed through it. When a new Observer subscribes, the <code>ReplaySubject</code> immediately sends (\"replays\") a specified number of the most recent values from its recording to that new subscriber.</p>"},{"location":"Operators/Subjects/replaySubject/#key-features","title":"Key Features","text":"<ol> <li>Records Values: It keeps a buffer of the last <code>n</code> values that were emitted via <code>next()</code>.</li> <li>Replays on Subscription: New subscribers immediately receive the buffered values (up to the specified buffer size) in the order they were originally emitted.</li> <li>Configurable Buffer: You specify the buffer size when creating it (e.g., <code>new ReplaySubject&lt;string&gt;(3)</code> will store and replay the last 3 values).</li> <li>Optional Time Window: You can also specify a <code>windowTime</code> (in milliseconds) along with the buffer size. This makes it replay values that were emitted within that time window and are within the buffer size limit.</li> <li>No Initial Value Required: Unlike <code>BehaviorSubject</code>, it doesn't need a starting value.</li> <li>Multicasting: Like all Subjects, it pushes new values (<code>next()</code>) to all current subscribers simultaneously after the initial replay.</li> </ol>"},{"location":"Operators/Subjects/replaySubject/#analogy","title":"Analogy","text":"<p>Imagine a meeting recorder or a chat log:</p> <ul> <li>When someone speaks (<code>next()</code> is called), the recorder captures it.</li> <li>It keeps a log of the recent conversation (the buffer).</li> <li>If someone joins the meeting late (subscribes), they can quickly catch up by listening to the recording of the last few minutes/points (the replay). They get the context they missed.</li> <li>After catching up, they hear the live conversation (<code>next()</code> emissions) along with everyone else.</li> </ul>"},{"location":"Operators/Subjects/replaySubject/#why-use-a-replaysubject","title":"Why Use a <code>ReplaySubject</code>?","text":"<ol> <li>Caching Recent Events: When you need to ensure that consumers who subscribe later still get access to the most recent few events or data points, not just the single latest one (like <code>BehaviorSubject</code>) or none (like <code>Subject</code>).</li> <li>Late Subscribers Needing Context: Useful in scenarios like:<ul> <li>A log of recent user actions.</li> <li>A stream of notifications where seeing the last few is important.</li> <li>Data streams where events happen quickly, and a subscriber might miss some if they aren't connected constantly.</li> </ul> </li> </ol>"},{"location":"Operators/Subjects/replaySubject/#real-world-example-recent-activity-log-service","title":"Real-World Example: Recent Activity Log Service","text":"<p>Let's create a service that logs recent significant actions within the application (e.g., \"Item Added\", \"Settings Saved\"). We want components that display this log to show the last 5 actions, even if the component loads after those actions have occurred.</p>"},{"location":"Operators/Subjects/replaySubject/#code-snippets","title":"Code Snippets","text":"<p>1. Activity Log Service (<code>activity-log.service.ts</code>)</p> <pre><code>import { Injectable } from \"@angular/core\";\nimport { ReplaySubject, Observable } from \"rxjs\";\n\nexport interface LogEntry {\n  message: string;\n  timestamp: Date;\n}\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class ActivityLogService {\n  // 1. Define the buffer size: Store the last 5 log entries.\n  private readonly logBufferSize = 5;\n\n  // 2. Create the ReplaySubject with the specified buffer size.\n  // Private to control who can add logs.\n  private logSubject = new ReplaySubject&lt;LogEntry&gt;(this.logBufferSize);\n\n  // 3. Expose the log entries as an Observable.\n  logEntries$: Observable&lt;LogEntry&gt; = this.logSubject.asObservable();\n\n  // Method for other parts of the app to add log entries\n  addLog(message: string): void {\n    const newEntry: LogEntry = {\n      message: message,\n      timestamp: new Date(),\n    };\n    console.log(`ActivityLogService: Adding log - \"${message}\"`);\n    // 4. Push the new log entry into the ReplaySubject.\n    // It gets stored in the buffer and sent to current subscribers.\n    this.logSubject.next(newEntry);\n  }\n}\n</code></pre> <p>2. Action Simulator Component - Adds Logs</p> <pre><code>import { Component, inject } from \"@angular/core\";\nimport { ActivityLogService } from \"./activity-log.service\"; // Adjust path\n\n@Component({\n  selector: \"app-action-simulator\",\n  standalone: true,\n  template: `\n    &lt;div&gt;\n      &lt;h4&gt;Simulate Actions&lt;/h4&gt;\n      &lt;button (click)=\"simulateAdd()\"&gt;Add Item&lt;/button&gt;\n      &lt;button (click)=\"simulateSave()\"&gt;Save Settings&lt;/button&gt;\n      &lt;button (click)=\"simulateDelete()\"&gt;Delete User&lt;/button&gt;\n    &lt;/div&gt;\n  `,\n  styles: [\n    \"div { margin-bottom: 15px; padding: 10px; border: 1px dashed green; }\",\n  ],\n})\nexport class ActionSimulatorComponent {\n  private logService = inject(ActivityLogService);\n  private itemCounter = 0;\n\n  simulateAdd(): void {\n    this.itemCounter++;\n    this.logService.addLog(`Item #${this.itemCounter} added to cart.`);\n  }\n\n  simulateSave(): void {\n    this.logService.addLog(\"User preferences saved successfully.\");\n  }\n\n  simulateDelete(): void {\n    this.logService.addLog(\"User account marked for deletion.\");\n  }\n}\n</code></pre> <p>3. Activity Log Display Component - Shows Logs</p> <pre><code>import {\n  Component,\n  inject,\n  signal,\n  OnInit,\n  DestroyRef,\n  ChangeDetectionStrategy,\n} from \"@angular/core\";\nimport { CommonModule, DatePipe } from \"@angular/common\"; // Need DatePipe\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\nimport { ActivityLogService, LogEntry } from \"./activity-log.service\"; // Adjust path\n\n@Component({\n  selector: \"app-activity-display\",\n  standalone: true,\n  imports: [CommonModule, DatePipe], // Import CommonModule and DatePipe\n  template: `\n    &lt;div class=\"log-display\"&gt;\n      &lt;h4&gt;Recent Activity Log (Last {{ bufferSize }})&lt;/h4&gt;\n      @if (logMessages().length &gt; 0) {\n      &lt;ul&gt;\n        @for (entry of logMessages(); track entry.timestamp) {\n        &lt;li&gt;\n          [{{ entry.timestamp | date : \"mediumTime\" }}] {{ entry.message }}\n        &lt;/li&gt;\n        }\n      &lt;/ul&gt;\n      } @else {\n      &lt;p&gt;No activity logged yet.&lt;/p&gt;\n      }\n    &lt;/div&gt;\n  `,\n  styles: [\n    `\n      .log-display {\n        border: 1px solid orange;\n        padding: 10px;\n        margin-top: 10px;\n        min-height: 150px;\n      }\n      ul {\n        list-style: none;\n        padding-left: 0;\n      }\n      li {\n        margin-bottom: 5px;\n        font-size: 0.9em;\n      }\n    `,\n  ],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class ActivityDisplayComponent implements OnInit {\n  private logService = inject(ActivityLogService);\n  private destroyRef = inject(DestroyRef);\n\n  // Expose buffer size to template if needed (optional)\n  bufferSize = (this.logService as any).logBufferSize; // Access private for demo - better way is getter in service\n\n  // Use a signal to hold the logs for the template\n  logMessages = signal&lt;LogEntry[]&gt;([]);\n\n  ngOnInit(): void {\n    // Subscribe to the log entries from the service\n    this.logService.logEntries$\n      .pipe(\n        // Automatically unsubscribe when the component is destroyed\n        takeUntilDestroyed(this.destroyRef)\n      )\n      .subscribe((entry) =&gt; {\n        // *** Key Point ***\n        // When this component subscribes, it might immediately receive\n        // up to 'logBufferSize' (5) entries if they were already added\n        // to the ReplaySubject BEFORE this component loaded/subscribed.\n        console.log(\n          `ActivityDisplayComponent received log: \"${entry.message}\"`\n        );\n\n        // Update the signal. Add new entry to the end.\n        // ReplaySubject emits buffered items one by one, then live ones.\n        // We just append each one as it arrives.\n        this.logMessages.update((currentLogs) =&gt; [...currentLogs, entry]);\n\n        // Optional: Trim the array in the component if you strictly want only 'bufferSize' items VISIBLE\n        // This might be needed if the ReplaySubject's buffer gets cleared/changed,\n        // though usually you'd just display what the ReplaySubject sends.\n        // this.logMessages.update(currentLogs =&gt; currentLogs.slice(-this.bufferSize));\n      });\n  }\n}\n</code></pre> <p>4. App Component</p> <pre><code>import { Component, inject } from \"@angular/core\";\nimport { ActionSimulatorComponent } from \"./action-simulator.component\"; // Adjust path\nimport { ActivityDisplayComponent } from \"./activity-display.component\"; // Adjust path\nimport { ActivityLogService } from \"./activity-log.service\"; // Adjust path\n\n@Component({\n  selector: \"app-root\",\n  standalone: true,\n  imports: [ActionSimulatorComponent, ActivityDisplayComponent], // Import components\n  template: `\n    &lt;h1&gt;RxJS ReplaySubject Demo&lt;/h1&gt;\n    &lt;button (click)=\"addLogDirectly()\"&gt;Add Log (Directly)&lt;/button&gt;\n    &lt;hr /&gt;\n    &lt;app-action-simulator&gt;&lt;/app-action-simulator&gt;\n    &lt;hr /&gt;\n    &lt;app-activity-display&gt;&lt;/app-activity-display&gt;\n    &lt;!-- Add another display later to show replay --&gt;\n    &lt;!-- &lt;app-activity-display&gt;&lt;/app-activity-display&gt; --&gt;\n  `,\n})\nexport class AppComponent {\n  // Inject service just to add an initial log for testing replay\n  private logService = inject(ActivityLogService);\n\n  constructor() {\n    // Add a log entry *before* any components might fully initialize\n    this.logService.addLog(\"Application session started.\");\n  }\n\n  addLogDirectly(): void {\n    this.logService.addLog(\"Direct Log Button Clicked.\");\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>ActivityLogService</code> creates a <code>ReplaySubject</code> configured to buffer the last 5 (<code>logBufferSize</code>) <code>LogEntry</code> objects.</li> <li>When <code>addLog</code> is called (by <code>ActionSimulatorComponent</code> or directly), the new <code>LogEntry</code> is pushed into the <code>logSubject</code>. It's stored in the buffer (replacing the oldest if the buffer is full) and sent to any currently subscribed components.</li> <li>When <code>ActivityDisplayComponent</code> initializes (<code>ngOnInit</code>), it subscribes to <code>logService.logEntries$</code>.</li> <li>Crucially: The <code>ReplaySubject</code> immediately replays its buffered messages (up to 5 of the most recent ones, including the \"Application session started.\" log added in the <code>AppComponent</code> constructor) to the new subscription in <code>ActivityDisplayComponent</code>. The component doesn't start with an empty list; it gets the recent history right away.</li> <li>As new logs are added via <code>addLog</code>, they are pushed live to the <code>ActivityDisplayComponent</code>'s subscription and added to its display.</li> </ol> <p>If you were to add a second instance of <code>ActivityDisplayComponent</code> to the <code>AppComponent</code> template later (e.g., after a few logs have already been added), that second instance would also immediately receive the same buffered history upon subscribing, demonstrating the replay functionality for late subscribers.</p>"},{"location":"Operators/Subjects/subject-behaviorSubject-replaySubject/","title":"Subject Vs BehaviorSubject Vs ReplaySubject","text":"<p>Let's summarize the key differences between <code>Subject</code>, <code>BehaviorSubject</code>, and <code>ReplaySubject</code>. Understanding these distinctions is vital for choosing the right tool for the job.</p> <p>Here's a comparison table highlighting the main differences:</p> Feature <code>Subject</code> <code>BehaviorSubject</code> <code>ReplaySubject</code> Initial Value? No Yes (Required on creation) No Value for New Sub? None. Only future values. Yes. The single latest value. Yes. The last <code>n</code> buffered values. Buffers Past Values? No Implicitly buffers only latest Yes. Explicitly buffers last <code>n</code>. Requires Config? No Initial Value Buffer Size (<code>n</code>), optionally time <code>getValue()</code> Method? No Yes (Synchronous access) No <p>Explanation in Simple Terms:</p> <ol> <li> <p><code>Subject</code> (\"The Basic Broadcaster\")</p> <ul> <li>Analogy: Live Radio Broadcast / Event Emitter.</li> <li>Behavior: It's like a plain event channel. When you emit (<code>next()</code>), it sends the value to only those currently subscribed. Anyone subscribing later gets nothing until the next emission. It doesn't remember past events.</li> <li>Use Case: Simple event aggregation, triggers, or when you only care about future events from the moment of subscription. Good for bridging non-observable code (like button clicks via <code>.next()</code>) into streams.</li> <li>Example Recall: Our cross-component communication example where the profile component only needed to know about future login/logout events after it loaded.</li> </ul> </li> <li> <p><code>BehaviorSubject</code> (\"The State Holder\")</p> <ul> <li>Analogy: Whiteboard / Status Board.</li> <li>Behavior: It must be created with an initial value. It always holds the most recent value. When someone subscribes, they immediately get this current value. Then, they receive any subsequent updates.</li> <li>Use Case: Managing state that always has a current value (e.g., logged-in user status, current theme, selected filter). Perfect when components need the current state immediately upon loading. Often used in state management services. Signals in Angular provide a compelling alternative for many state-holding scenarios, offering synchronous reads without needing <code>.getValue()</code>.</li> <li>Example Recall: Our theme service example where components needed to know the current theme ('light' or 'dark') right away.</li> </ul> </li> <li> <p><code>ReplaySubject</code> (\"The Recorder\")</p> <ul> <li>Analogy: Meeting Recorder / Chat History.</li> <li>Behavior: It records a specified number (<code>n</code>) of the most recent values. When someone subscribes, it immediately replays those buffered values to the new subscriber, bringing them up to speed. After the replay, it behaves like a regular <code>Subject</code> for new values.</li> <li>Use Case: Caching recent events when context is important for late subscribers. Useful for activity logs, notification streams, or data streams where missing the last few events would be problematic.</li> <li>Example Recall: Our activity log service example where a display component needed to show the last 5 logged actions, even if it loaded after those actions occurred.</li> </ul> </li> </ol> <p>When to Use Which:</p> <ul> <li>Use <code>Subject</code> when you just need to broadcast events as they happen, and subscribers don't need any history or initial value.</li> <li>Use <code>BehaviorSubject</code> when you need to represent a piece of state that always has a value, and new subscribers should get the current value immediately. (Consider if a Signal might be simpler for this state).</li> <li>Use <code>ReplaySubject</code> when new subscribers need to get a history of the last few emissions to have proper context.</li> </ul> <p>Remember to expose Subjects from services using <code>.asObservable()</code> to prevent external code from calling <code>.next()</code> on them, maintaining better encapsulation.</p>"},{"location":"Operators/Subjects/subject/","title":"subject","text":"<p>Think of a <code>Subject</code> as a special kind of Observable that acts like both an Observable and an Observer:</p> <ol> <li>As an Observable: You can <code>subscribe</code> to it just like any other Observable to receive values it emits.</li> <li>As an Observer: You can manually push values into it by calling its <code>next(value)</code> method. You can also make it emit an error with <code>error(err)</code> or signal completion with <code>complete()</code>.</li> </ol> <p>The key characteristic of a Subject is multicasting. This means that when the Subject emits a value (because <code>next()</code> was called on it), it pushes that value to all of its current subscribers simultaneously. This is different from plain (\"cold\") Observables (like those from <code>HttpClient</code> or <code>interval</code>), which typically start a new, independent execution for each subscriber.</p>"},{"location":"Operators/Subjects/subject/#analogy","title":"Analogy","text":"<p>Imagine a live radio broadcast.</p> <ul> <li>The Radio Station Announcer is the code calling <code>subject.next(\"Breaking news!\")</code>.</li> <li>The Radio Station's Broadcast Tower is the <code>Subject</code> itself.</li> <li>The Listeners tuning their radios are the <code>Subscribers</code>.</li> </ul> <p>When the announcer speaks into the microphone (<code>next()</code>), the tower (<code>Subject</code>) broadcasts that message live, and all listeners (<code>Subscribers</code>) who are currently tuned in hear the same message at the same time. Listeners who tune in later will only hear broadcasts from that point forward; they miss the earlier messages (this is specific to the basic <code>Subject</code> type).</p>"},{"location":"Operators/Subjects/subject/#why-use-a-subject","title":"Why Use a Subject?","text":"<ol> <li>Event Bus: To create a simple way for different parts of your application (like unrelated components) to communicate through a shared service. One part calls <code>next()</code> on the Subject, and other parts listening to that Subject react.</li> <li>Bridging: To take values or events from non-Observable sources (like imperative button clicks, WebSocket messages, etc.) and push them into an Observable stream for further processing with RxJS operators.</li> <li>Sharing Observable Executions: While there are operators like <code>shareReplay</code> often better suited for sharing the result of an Observable, a Subject can sometimes be used to manually control and share a single subscription's output.</li> </ol>"},{"location":"Operators/Subjects/subject/#real-world-example-cross-component-communication","title":"Real-World Example: Cross-Component Communication","text":"<p>Let's say you have a header component with a \"Login\" button and a user profile component elsewhere on the page. When the user successfully logs in (maybe via a popup triggered from the header), you want the user profile component to update immediately without a page refresh.</p> <p>We can use a shared service with a Subject to announce the login status change.</p> <p>Code Snippets:</p> <p>1. Shared Authentication Service (<code>auth.service.ts</code>)</p> <pre><code>import { Injectable } from \"@angular/core\";\nimport { Subject, Observable } from \"rxjs\";\n\nexport interface User {\n  id: string;\n  name: string;\n}\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class AuthService {\n  // 1. Private Subject: Only the service can push values into it.\n  // We use 'User | null' to indicate either a logged-in user or logged-out state.\n  private userLoginStatusSubject = new Subject&lt;User | null&gt;();\n\n  // 2. Public Observable: Components subscribe to this to listen for changes.\n  // '.asObservable()' hides the .next(), .error(), .complete() methods from consumers.\n  userLoginStatus$: Observable&lt;User | null&gt; =\n    this.userLoginStatusSubject.asObservable();\n\n  // Simulate a login process\n  login(username: string): void {\n    console.log(\"AuthService: Attempting login...\");\n    // In a real app, this would involve an HTTP call, password check etc.\n    setTimeout(() =&gt; {\n      const fakeUser: User = { id: \"user123\", name: username };\n      console.log(\"AuthService: Login successful, broadcasting user.\");\n      // 3. Broadcasting the change: Push the new user data into the Subject.\n      this.userLoginStatusSubject.next(fakeUser);\n    }, 1000); // Simulate network delay\n  }\n\n  // Simulate a logout process\n  logout(): void {\n    console.log(\"AuthService: Logging out, broadcasting null user.\");\n    // 4. Broadcasting the change: Push 'null' into the Subject.\n    this.userLoginStatusSubject.next(null);\n  }\n}\n</code></pre> <p>2. Header Component - Triggers Login/Logout</p> <pre><code>import { Component, inject } from \"@angular/core\";\nimport { AuthService } from \"./auth.service\"; // Adjust path if needed\n\n@Component({\n  selector: \"app-header\",\n  standalone: true,\n  template: `\n    &lt;nav&gt;\n      &lt;span&gt;My App&lt;/span&gt;\n      &lt;button (click)=\"loginUser()\"&gt;Login&lt;/button&gt;\n      &lt;button (click)=\"logoutUser()\"&gt;Logout&lt;/button&gt;\n    &lt;/nav&gt;\n  `,\n  styles: [\n    \"nav { display: flex; justify-content: space-between; padding: 10px; background-color: #eee; }\",\n  ],\n})\nexport class HeaderComponent {\n  private authService = inject(AuthService);\n\n  loginUser(): void {\n    // Prompt or fixed user for simplicity\n    const username = prompt(\"Enter username\", \"Alice\");\n    if (username) {\n      this.authService.login(username);\n    }\n  }\n\n  logoutUser(): void {\n    this.authService.logout();\n  }\n}\n</code></pre> <p>3. User Profile Component - Listens for Changes</p> <pre><code>import {\n  Component,\n  inject,\n  signal,\n  OnInit,\n  DestroyRef,\n  ChangeDetectionStrategy,\n} from \"@angular/core\";\nimport { CommonModule } from \"@angular/common\"; // Needed for @if\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\nimport { AuthService, User } from \"./auth.service\"; // Adjust path if needed\n\n@Component({\n  selector: \"app-user-profile\",\n  standalone: true,\n  imports: [CommonModule], // Import CommonModule\n  template: `\n    &lt;div class=\"profile-status\"&gt;\n      &lt;h4&gt;User Status&lt;/h4&gt;\n      @if (loggedInUser()) {\n      &lt;p&gt;Welcome, {{ loggedInUser()?.name }}! (ID: {{ loggedInUser()?.id }})&lt;/p&gt;\n      } @else {\n      &lt;p&gt;You are currently logged out.&lt;/p&gt;\n      }\n    &lt;/div&gt;\n  `,\n  styles: [\n    `\n      .profile-status {\n        border: 1px solid lightblue;\n        padding: 10px;\n        margin-top: 10px;\n      }\n    `,\n  ],\n  changeDetection: ChangeDetectionStrategy.OnPush, // Good practice with signals/observables\n})\nexport class UserProfileComponent implements OnInit {\n  private authService = inject(AuthService);\n  private destroyRef = inject(DestroyRef);\n\n  // Use a signal to hold the user state for the template\n  loggedInUser = signal&lt;User | null&gt;(null);\n\n  ngOnInit(): void {\n    // Subscribe to the service's Observable\n    this.authService.userLoginStatus$\n      .pipe(\n        // Automatically unsubscribe when the component is destroyed\n        takeUntilDestroyed(this.destroyRef)\n      )\n      .subscribe((user) =&gt; {\n        // Update the signal when a new status is broadcast by the Subject\n        console.log(\"UserProfileComponent received user status:\", user);\n        this.loggedInUser.set(user);\n      });\n  }\n}\n</code></pre> <p>4. App Component (Hosting the others)</p> <pre><code>import { Component } from \"@angular/core\";\nimport { HeaderComponent } from \"./header.component\"; // Adjust path\nimport { UserProfileComponent } from \"./user-profile.component\"; // Adjust path\n\n@Component({\n  selector: \"app-root\",\n  standalone: true,\n  imports: [HeaderComponent, UserProfileComponent], // Import components\n  template: `\n    &lt;h1&gt;RxJS Subject Demo&lt;/h1&gt;\n    &lt;app-header&gt;&lt;/app-header&gt;\n    &lt;app-user-profile&gt;&lt;/app-user-profile&gt;\n    &lt;!-- You could even add a second profile component instance --&gt;\n    &lt;!-- &lt;app-user-profile&gt;&lt;/app-user-profile&gt; --&gt;\n    &lt;!-- Both would update simultaneously! --&gt;\n  `,\n})\nexport class AppComponent {}\n</code></pre> <p>Explanation:</p> <ol> <li>The <code>AuthService</code> creates a <code>Subject</code> (<code>userLoginStatusSubject</code>) to manage the login state.</li> <li>It exposes only an <code>Observable</code> (<code>userLoginStatus$</code>) derived from the subject using <code>.asObservable()</code>. This is good practice \u2013 it prevents components from accidentally calling <code>next()</code> on the service's subject. Only the service itself controls when broadcasts happen.</li> <li>When <code>authService.login()</code> or <code>authService.logout()</code> is called (triggered by <code>HeaderComponent</code>), the service calls <code>this.userLoginStatusSubject.next(...)</code>, pushing the new user data (or <code>null</code>) into the Subject.</li> <li>The <code>UserProfileComponent</code> subscribes to <code>authService.userLoginStatus$</code> in its <code>ngOnInit</code>.</li> <li>Whenever the Subject broadcasts a new value, the subscription in <code>UserProfileComponent</code> receives it, and updates the <code>loggedInUser</code> signal, causing the component's template to reactively display the current status.</li> <li><code>takeUntilDestroyed</code> ensures the subscription is cleaned up when the <code>UserProfileComponent</code> is destroyed.</li> </ol> <p>This demonstrates how a Subject acts as a central hub (multicasting) to notify multiple interested parties (subscribers) about events happening elsewhere in the application.</p>"},{"location":"Operators/Transformation/concatMap/","title":"concatMap","text":"<p><code>concatMap()</code> is a higher-order mapping operator that maps each value from a source (outer) Observable to an inner Observable, subscribes to it, but waits for that inner Observable to complete before moving on to map and subscribe to the inner Observable generated by the next value from the source.</p> <p>Here's the flow:</p> <ol> <li>It takes the first value emitted by the source (outer) Observable.</li> <li>It uses that value and your project function to create the first inner Observable.</li> <li>It subscribes to this first inner Observable and emits its values.</li> <li>If the source Observable emits a second value while the first inner Observable is still running, <code>concatMap</code> holds onto that second value.</li> <li>Only when the first inner Observable completes does <code>concatMap</code> use the held second value to create and subscribe to the second inner Observable.</li> <li>This process continues, effectively creating a queue where inner Observables are executed one after another, strictly in the order dictated by the source Observable.</li> </ol> <p>Think of it as processing tasks in a single-file line: the next task only starts once the current one is completely finished.</p>"},{"location":"Operators/Transformation/concatMap/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Higher-Order Mapping: Maps values from an outer Observable to inner Observables.</li> <li>Sequential Execution: Runs inner Observables one at a time, in order.</li> <li>Waits for Completion: Does not subscribe to the next inner Observable until the previous one completes.</li> <li>Preserves Order: Guarantees that the output values maintain the order corresponding to the source emissions.</li> <li>Use Cases: Ideal when the order of operations is crucial, or when you need to ensure one asynchronous task finishes before the next begins (e.g., to avoid race conditions, maintain data integrity, or process items sequentially). Also useful for implicit rate-limiting when you don't want concurrent requests.</li> </ul>"},{"location":"Operators/Transformation/concatMap/#real-world-example-scenario","title":"Real-World Example Scenario","text":"<p>It's Tuesday afternoon here in Bengaluru (around 2:50 PM IST), and imagine you're building a feature where a user can trigger several updates that need to be applied to a database or configuration file in a specific order to maintain consistency.</p> <p>Scenario: A user is rapidly clicking buttons to add different items to a configuration profile (\"Add Feature A\", \"Enable Setting B\", \"Add User C\"). Each click triggers an API call to update the profile. If these updates happened concurrently (<code>mergeMap</code>), they might interfere with each other or lead to an inconsistent final state depending on server response times. If you used <code>switchMap</code>, clicking \"Enable Setting B\" might cancel the \"Add Feature A\" request if it was still pending.</p> <p>You want to ensure the updates are applied strictly in the order the user clicked:</p> <ol> <li>Wait for \"Add Feature A\" API call to complete successfully.</li> <li>Then execute the \"Enable Setting B\" API call and wait for it to complete.</li> <li>Then execute the \"Add User C\" API call.</li> </ol> <p><code>concatMap</code> enforces this sequential processing.</p>"},{"location":"Operators/Transformation/concatMap/#code-snippet-angular-component-sequential-updates","title":"Code Snippet (Angular Component - Sequential Updates)","text":"<pre><code>import { Component, OnDestroy } from \"@angular/core\";\nimport { HttpClient } from \"@angular/common/http\";\nimport { Subject, Subscription, Observable, of } from \"rxjs\";\nimport { concatMap, catchError, tap, delay } from \"rxjs/operators\"; // Import concatMap\n\ninterface UpdateAction {\n  id: string; // Unique identifier for the action\n  type: string;\n  payload: any;\n  apiUrl: string;\n}\n\ninterface UpdateResult {\n  actionId: string;\n  success: boolean;\n  message: string;\n}\n\n@Component({\n  selector: \"app-sequential-updates\",\n  template: `\n    &lt;h4&gt;Sequential Update Demo&lt;/h4&gt;\n    &lt;p&gt;\n      Rapidly click the buttons below. Updates will be processed one after\n      another.\n    &lt;/p&gt;\n    &lt;button\n      (click)=\"triggerUpdate('Add Feature A', '/api/features')\"\n      class=\"btn btn-info me-2\"\n    &gt;\n      Add Feature A\n    &lt;/button&gt;\n    &lt;button\n      (click)=\"triggerUpdate('Enable Setting B', '/api/settings/b')\"\n      class=\"btn btn-info me-2\"\n    &gt;\n      Enable Setting B\n    &lt;/button&gt;\n    &lt;button\n      (click)=\"triggerUpdate('Add User C', '/api/users')\"\n      class=\"btn btn-info me-2\"\n    &gt;\n      Add User C\n    &lt;/button&gt;\n\n    &lt;div class=\"mt-3\"&gt;\n      &lt;h5&gt;Processing Log:&lt;/h5&gt;\n      &lt;ul class=\"list-group\"&gt;\n        &lt;li\n          *ngFor=\"let log of processingLog\"\n          class=\"list-group-item small\"\n          [ngClass]=\"{\n            'list-group-item-success': log.includes('Success'),\n            'list-group-item-danger': log.includes('Failed'),\n            'list-group-item-secondary':\n              log.includes('Queueing') || log.includes('Starting')\n          }\"\n        &gt;\n          {{ log }}\n        &lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  `,\n})\nexport class SequentialUpdatesComponent implements OnDestroy {\n  processingLog: string[] = [];\n\n  // Use a Subject to push actions onto the stream when buttons are clicked\n  private actionSubject = new Subject&lt;UpdateAction&gt;();\n  private actionSubscription: Subscription;\n\n  constructor(private http: HttpClient) {\n    // Subscribe to the action stream and use concatMap for processing\n    this.actionSubscription = this.actionSubject\n      .pipe(\n        tap((action) =&gt; {\n          const logMsg = `[${new Date().toLocaleTimeString()}] Queueing: ${\n            action.type\n          } (ID: ${action.id})`;\n          console.log(logMsg);\n          this.processingLog.push(logMsg);\n        }),\n        // concatMap ensures the next action waits until the inner observable (API call) completes\n        concatMap((action: UpdateAction) =&gt; {\n          const startLogMsg = `[${new Date().toLocaleTimeString()}] Starting API call for: ${\n            action.type\n          } (ID: ${action.id})`;\n          console.log(`   ${startLogMsg}`);\n          this.processingLog.push(startLogMsg);\n\n          // Simulate API call - Replace with actual http.post/put\n          // Adding a delay to better visualize the sequential nature\n          const innerApiCall$ = of({\n            success: true,\n            received: action.payload,\n          }).pipe(\n            delay(1500 + Math.random() * 1000) // Simulate network latency (1.5 - 2.5 seconds)\n          );\n          // const innerApiCall$ = this.http.post&lt;any&gt;(action.apiUrl, action.payload)\n\n          return innerApiCall$.pipe(\n            // Map the successful result\n            map((response) =&gt; ({\n              actionId: action.id,\n              success: true,\n              message: `Success: ${action.type} (ID: ${action.id}) completed.`,\n            })),\n            // Catch errors for *this specific* API call\n            catchError((error) =&gt; {\n              console.error(\n                `Error processing ${action.type} (ID: ${action.id}):`,\n                error\n              );\n              // Return an Observable emitting the failure result\n              return of({\n                actionId: action.id,\n                success: false,\n                message: `Failed: ${action.type} (ID: ${action.id}) - ${\n                  error.message || \"Unknown error\"\n                }`,\n              });\n            })\n          ); // End of inner pipe\n        }) // End of concatMap\n      )\n      .subscribe({\n        next: (result: UpdateResult) =&gt; {\n          // This receives results one by one, *in order*, after each API call completes\n          const logMsg = `[${new Date().toLocaleTimeString()}] ${\n            result.message\n          }`;\n          console.log(logMsg);\n          this.processingLog.push(logMsg);\n        },\n        error: (err) =&gt; {\n          // Error in the main action stream (unlikely with Subject unless error pushed)\n          const logMsg = `[${new Date().toLocaleTimeString()}] Critical stream error: ${err}`;\n          console.error(logMsg);\n          this.processingLog.push(logMsg);\n        },\n        complete: () =&gt; {\n          // Only called if the actionSubject itself completes (not typical for button clicks)\n          const logMsg = `[${new Date().toLocaleTimeString()}] Action stream completed.`;\n          console.log(logMsg);\n          this.processingLog.push(logMsg);\n        },\n      });\n  }\n\n  triggerUpdate(type: string, apiUrl: string): void {\n    const action: UpdateAction = {\n      id: Math.random().toString(36).substring(2, 9), // Generate simple unique ID\n      type: type,\n      payload: { timestamp: new Date().toISOString() }, // Example payload\n      apiUrl: apiUrl,\n    };\n    console.log(\n      `[${new Date().toLocaleTimeString()}] Button clicked, pushing action: ${type} (ID: ${\n        action.id\n      })`\n    );\n    this.actionSubject.next(action); // Push the action onto the Subject stream\n  }\n\n  ngOnDestroy(): void {\n    // Clean up the subscription when the component is destroyed\n    if (this.actionSubscription) {\n      this.actionSubscription.unsubscribe();\n      console.log(\"Sequential updates subscription stopped.\");\n    }\n    this.actionSubject.complete(); // Also complete the subject\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>Subject&lt;UpdateAction&gt;</code>: We use a Subject (<code>actionSubject</code>) to act as the source Observable. Button clicks push <code>UpdateAction</code> objects onto this Subject using <code>actionSubject.next(action)</code>.</li> <li><code>concatMap((action: UpdateAction) =&gt; ...)</code>: This is the core.<ul> <li>When the <code>actionSubject</code> emits an action, <code>concatMap</code> takes it.</li> <li>It executes the inner function, which returns the inner Observable (<code>innerApiCall$</code>).</li> <li><code>concatMap</code> subscribes to <code>innerApiCall$</code>.</li> <li>Crucially: If another action is pushed onto <code>actionSubject</code> before <code>innerApiCall$</code> completes, <code>concatMap</code> waits. It doesn't execute the inner function for the new action yet.</li> <li>Only when the current <code>innerApiCall$</code> completes (either successfully maps to a result or is handled by <code>catchError</code>) does <code>concatMap</code> proceed to process the next queued action from <code>actionSubject</code>.</li> </ul> </li> <li><code>delay()</code>: Added inside the simulated API call to make the sequential waiting behavior obvious in the log.</li> <li>Logging: The console and UI logs will clearly show actions being queued, then starting, then completing one after another, even if the buttons are clicked very rapidly.</li> </ol>"},{"location":"Operators/Transformation/concatMap/#summary","title":"Summary","text":"<p>use <code>concatMap</code> when the order of execution matters and you need to ensure that asynchronous operations triggered by a stream of events happen sequentially, one completing before the next one begins. It's your tool for enforcing order in asynchronous workflows.</p>"},{"location":"Operators/Transformation/exhaustMap/","title":"exhaustMap","text":"<p><code>exhaustMap()</code> is a higher-order mapping operator. When it receives a value from the source (outer) Observable:</p> <ol> <li>It checks if it's already executing an inner Observable from a previous source value.</li> <li>If it's NOT busy: It uses the new source value and your project function to create a new inner Observable, subscribes to it, and starts emitting its values.</li> <li>If it IS busy (meaning the inner Observable from a previous source value hasn't completed yet): It completely ignores the new value from the source Observable. It just drops it and does nothing further with it.</li> <li>It will only listen for and process a new source value once its current inner Observable completes.</li> </ol> <p>Think of it like a busy worker who takes the first task assigned. While working on that task, they completely ignore anyone else trying to give them new tasks. Only when they finish the current task will they accept the next task that comes along. Any tasks attempted while they were busy are lost.</p>"},{"location":"Operators/Transformation/exhaustMap/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Higher-Order Mapping: Maps values from an outer Observable to inner Observables.</li> <li>Ignores While Busy: Discards incoming source values if an inner Observable is currently active.</li> <li>No Concurrency (Managed): Only ever handles one inner Observable at a time.</li> <li>No Cancellation: It doesn't cancel the active inner Observable; it lets it finish.</li> <li>Use Cases: Perfect for situations where you want to execute an action based on the first trigger in a potential burst of triggers, and then ignore all subsequent triggers until that action is fully complete. Common for preventing duplicate actions caused by rapid user input, like double-clicks.</li> </ul>"},{"location":"Operators/Transformation/exhaustMap/#real-world-example-scenario","title":"Real-World Example Scenario","text":"<p>It's Tuesday afternoon here in Bengaluru (just before 3 PM IST), and a classic scenario where <code>exhaustMap</code> shines is preventing double form submissions.</p> <p>Scenario: A user fills out a form in your Angular application and clicks the \"Submit\" button. This click should trigger an API call to save the data. However, users sometimes get impatient or accidentally double-click the button. If you used <code>mergeMap</code>, you might send the same data twice concurrently. If you used <code>concatMap</code>, the second click would be queued and executed after the first completes (still potentially undesirable). If you used <code>switchMap</code>, the second click might cancel the first save attempt (definitely not what you want!).</p> <p>You want the application to:</p> <ol> <li>Register the first click on \"Submit\".</li> <li>Start the API call (the inner Observable).</li> <li>Ignore any further clicks on the \"Submit\" button while that API call is in progress.</li> <li>Only after the first API call completes (successfully or with an error) should it listen for a new click again.</li> </ol> <p><code>exhaustMap</code> handles this perfectly.</p>"},{"location":"Operators/Transformation/exhaustMap/#code-snippet-angular-component-submit-button","title":"Code Snippet (Angular Component - Submit Button)","text":"<pre><code>import { Component, OnDestroy } from \"@angular/core\";\nimport { HttpClient } from \"@angular/common/http\";\nimport { Subject, Subscription, Observable, of, timer } from \"rxjs\";\nimport { exhaustMap, catchError, tap, delay } from \"rxjs/operators\"; // Import exhaustMap\n\ninterface SubmitPayload {\n  formData: any;\n  timestamp: string;\n}\n\ninterface SubmitResult {\n  success: boolean;\n  message: string;\n  payloadSent?: SubmitPayload;\n}\n\n@Component({\n  selector: \"app-submit-once\",\n  template: `\n    &lt;h4&gt;Submit Form Demo (Prevents Double Submit)&lt;/h4&gt;\n    &lt;p&gt;\n      Rapidly click the \"Submit\" button. Only the first click while not busy\n      will trigger the action.\n    &lt;/p&gt;\n    &lt;button\n      (click)=\"onSubmitClick()\"\n      class=\"btn btn-success\"\n      [disabled]=\"isSubmitting\"\n    &gt;\n      &lt;span\n        *ngIf=\"isSubmitting\"\n        class=\"spinner-border spinner-border-sm\"\n        role=\"status\"\n        aria-hidden=\"true\"\n      &gt;&lt;/span&gt;\n      {{ isSubmitting ? \" Submitting...\" : \"Submit Data\" }}\n    &lt;/button&gt;\n\n    &lt;div class=\"mt-3\"&gt;\n      &lt;h5&gt;Submission Log:&lt;/h5&gt;\n      &lt;ul class=\"list-group\"&gt;\n        &lt;li\n          *ngFor=\"let log of submissionLog\"\n          class=\"list-group-item small\"\n          [ngClass]=\"{\n            'list-group-item-info': log.includes('Ignoring'),\n            'list-group-item-warning': log.includes('Starting'),\n            'list-group-item-success': log.includes('Success'),\n            'list-group-item-danger': log.includes('Failed')\n          }\"\n        &gt;\n          {{ log }}\n        &lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  `,\n})\nexport class SubmitOnceComponent implements OnDestroy {\n  submissionLog: string[] = [];\n  isSubmitting = false;\n\n  // Use a Subject to stream click events\n  private submitSubject = new Subject&lt;SubmitPayload&gt;();\n  private submitSubscription: Subscription;\n\n  constructor(private http: HttpClient) {\n    this.submitSubscription = this.submitSubject\n      .pipe(\n        tap(() =&gt; {\n          // This tap happens *before* exhaustMap decides whether to proceed or ignore\n          // Useful for logging the intention, but not the actual start of the API call yet\n          console.log(\n            `[${new Date().toLocaleTimeString()}] Submit detected by Subject.`\n          );\n          // Note: We don't set isSubmitting = true here yet, only when exhaustMap *starts* the inner observable.\n        }),\n        // exhaustMap will ignore emissions from submitSubject if an inner observable is active\n        exhaustMap((payload: SubmitPayload) =&gt; {\n          // This inner function only runs if exhaustMap is NOT already busy.\n          this.isSubmitting = true; // Set loading state *now*\n          const startLog = `[${new Date().toLocaleTimeString()}] exhaustMap Starting API Call with payload from ${\n            payload.timestamp\n          }`;\n          console.log(startLog);\n          this.submissionLog.push(startLog);\n\n          // Simulate API call (replace with actual http.post)\n          // Add delay to simulate network time\n          const innerApiCall$ = of({\n            status: \"Saved\",\n            dataReceived: payload,\n          }).pipe(\n            delay(2500) // Simulate 2.5 second save operation\n          );\n          // const innerApiCall$ = this.http.post&lt;any&gt;('/api/formdata', payload)\n\n          return innerApiCall$.pipe(\n            map((response) =&gt; ({\n              success: true,\n              message: `Success: Submitted data from ${\n                payload.timestamp\n              }. Response: ${JSON.stringify(response)}`,\n              payloadSent: payload,\n            })),\n            catchError((error) =&gt; {\n              console.error(\"Submission Error:\", error);\n              return of({\n                // Return failure result Observable\n                success: false,\n                message: `Failed: Submission from ${\n                  payload.timestamp\n                }. Error: ${error.message || \"Unknown error\"}`,\n                payloadSent: payload,\n              });\n            }),\n            tap(() =&gt; {\n              this.isSubmitting = false; // Unset loading state when inner observable completes/errors\n              console.log(\n                `[${new Date().toLocaleTimeString()}] exhaustMap finished inner observable. Ready for next event.`\n              );\n            }) // Final tap ensures isSubmitting is reset\n          ); // End of inner pipe\n        }) // End of exhaustMap\n      )\n      .subscribe({\n        next: (result: SubmitResult) =&gt; {\n          // Receives the result only when an API call initiated by exhaustMap completes\n          const logMsg = `[${new Date().toLocaleTimeString()}] ${\n            result.message\n          }`;\n          console.log(logMsg);\n          this.submissionLog.push(logMsg);\n        },\n        error: (err) =&gt; {\n          // Error in the main submitSubject stream (rare for Subject)\n          const logMsg = `[${new Date().toLocaleTimeString()}] Critical stream error: ${err}`;\n          console.error(logMsg);\n          this.submissionLog.push(logMsg);\n          this.isSubmitting = false;\n        },\n      });\n\n    // Monitor the subject separately to show when clicks are ignored\n    this.submitSubject.subscribe(() =&gt; {\n      if (this.isSubmitting) {\n        const ignoreLog = `[${new Date().toLocaleTimeString()}] Ignoring click because submission is already in progress.`;\n        console.warn(ignoreLog);\n        // Optionally push to a different log or provide brief UI feedback\n        this.submissionLog.push(ignoreLog);\n      }\n    });\n  }\n\n  onSubmitClick(): void {\n    // Create payload (e.g., from form values)\n    const payload: SubmitPayload = {\n      formData: { name: \"Test User\", value: Math.random() },\n      timestamp: new Date().toLocaleTimeString(),\n    };\n    // Push the payload onto the subject stream\n    // exhaustMap will decide whether to process it or ignore it\n    this.submitSubject.next(payload);\n  }\n\n  ngOnDestroy(): void {\n    if (this.submitSubscription) {\n      this.submitSubscription.unsubscribe();\n      console.log(\"Submit subscription stopped.\");\n    }\n    this.submitSubject.complete();\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>Subject&lt;SubmitPayload&gt;</code>: A Subject (<code>submitSubject</code>) streams the payloads whenever the \"Submit Data\" button is clicked via <code>onSubmitClick()</code>.</li> <li><code>exhaustMap((payload: SubmitPayload) =&gt; ...)</code>: This is the key operator.<ul> <li>When <code>submitSubject.next(payload)</code> is called, <code>exhaustMap</code> receives the <code>payload</code>.</li> <li>It checks if its previous inner Observable (<code>innerApiCall$</code>) is still running.</li> <li>If NOT running: It executes the inner function, sets <code>isSubmitting = true</code>, logs the start, returns <code>innerApiCall$</code>, and subscribes to it.</li> <li>If IS running: It ignores the incoming <code>payload</code>. The inner function is not executed, no new API call is made, and the <code>isSubmitting</code> flag remains true from the ongoing operation. The separate subscription logging demonstrates this ignoring action.</li> </ul> </li> <li><code>innerApiCall$</code>: Represents the actual asynchronous work (simulated <code>http.post</code> with a <code>delay</code>).</li> <li>Inner <code>map</code>, <code>catchError</code>, <code>tap</code>: These handle the result of the API call and, importantly, the final <code>tap</code> sets <code>isSubmitting = false</code> only when the inner operation completes or errors. This signals to <code>exhaustMap</code> that it's no longer busy and can accept a new event from <code>submitSubject</code>.</li> <li><code>subscribe({...})</code>: Receives the <code>SubmitResult</code> only for those clicks that were not ignored by <code>exhaustMap</code> and whose corresponding API calls completed.</li> </ol>"},{"location":"Operators/Transformation/exhaustMap/#summary","title":"Summary","text":"<p>use <code>exhaustMap</code> when you want to ensure that an action triggered by an event stream only runs if it's not already running due to a previous trigger. It's the perfect tool for preventing duplicate submissions or actions caused by rapid, repeated events where only the first \"available\" trigger should be processed.</p>"},{"location":"Operators/Transformation/map/","title":"map","text":"<p>The <code>map()</code> operator is a transformation operator. Its job is to transform each value emitted by a source Observable into a new value based on a function you provide. It then emits this new, transformed value.</p> <p>Think of it exactly like the <code>Array.prototype.map()</code> method you use with JavaScript arrays, but applied to values arriving over time in an Observable stream. For every single item that comes out of the source Observable, <code>map</code> applies your function to it and sends the result downstream.</p>"},{"location":"Operators/Transformation/map/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Transforms Values: Changes the data passing through the stream.</li> <li>One-to-One Emission: For each value received from the source, it emits exactly one transformed value.</li> <li>Takes a Project Function: You provide a function <code>map(projectFn)</code> where <code>projectFn</code> takes the source value as input and returns the transformed value.</li> <li>Preserves Timing/Order: It doesn't delay emissions or change their order; it just modifies the data within each emission.</li> <li>Passes Through Errors/Completion: If the source Observable errors or completes, <code>map</code> simply passes those notifications along.</li> </ul>"},{"location":"Operators/Transformation/map/#real-world-example-scenario-very-common-in-angular","title":"Real-World Example Scenario (Very Common in Angular)","text":"<p>Imagine you're fetching data from an API using Angular's <code>HttpClient</code>. The API might return a complex object or an array of objects with many properties, but your component only needs a specific piece of that data, or needs it in a slightly different format.</p> <p>Scenario: Let's say you fetch a list of products from an API. The API returns an array of product objects, each looking like this:</p> <pre><code>{\n  \"productId\": \"XYZ-123\",\n  \"productName\": \"Super Widget\",\n  \"price\": {\n    \"amount\": 99.99,\n    \"currency\": \"USD\"\n  },\n  \"stock\": 50,\n  \"category\": \"Widgets\"\n}\n</code></pre> <p>Your component, however, only needs to display a simple list of product names (e.g., <code>[\"Super Widget\", \"Mega Gadget\"]</code>). You can use <code>map()</code> to transform the raw API response (array of complex objects) into the desired array of strings.</p>"},{"location":"Operators/Transformation/map/#code-snippet-angular-service-and-component","title":"Code Snippet (Angular Service and Component)","text":"<pre><code>// product.service.ts\nimport { Injectable } from \"@angular/core\";\nimport { HttpClient } from \"@angular/common/http\";\nimport { Observable } from \"rxjs\";\nimport { map } from \"rxjs/operators\"; // Import the map operator\n\n// Define an interface for the raw API response structure (good practice)\ninterface RawProduct {\n  productId: string;\n  productName: string;\n  price: {\n    amount: number;\n    currency: string;\n  };\n  stock: number;\n  category: string;\n}\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class ProductService {\n  private apiUrl = \"/api/products\"; // Your actual API endpoint\n\n  constructor(private http: HttpClient) {}\n\n  // Method to get only the product names as an Observable&lt;string[]&gt;\n  getProductNames(): Observable&lt;string[]&gt; {\n    console.log(\n      `Workspaceing products from API at ${new Date().toLocaleTimeString(\n        \"en-IN\",\n        { timeZone: \"Asia/Kolkata\" }\n      )} (IST)...`\n    );\n\n    return this.http.get&lt;RawProduct[]&gt;(this.apiUrl).pipe(\n      // Use the map operator to transform the response\n      map((products: RawProduct[]) =&gt; {\n        // This function is executed when the HTTP request succeeds\n        // 'products' here is the array of RawProduct objects from the API\n        console.log(\"API returned raw products:\", products);\n\n        // Use JavaScript's Array.map to transform the array internally\n        const names = products.map((product) =&gt; product.productName);\n\n        console.log(\"Transformed raw products into names:\", names);\n        // Return the transformed array of names\n        return names;\n      })\n      // You could chain other operators here if needed, like filter, catchError etc.\n    );\n  }\n\n  // Example of fetching slightly more complex transformed data\n  getActiveProductSummaries(): Observable&lt;{ name: string; price: number }[]&gt; {\n    return this.http.get&lt;RawProduct[]&gt;(this.apiUrl).pipe(\n      map((products) =&gt;\n        products\n          .filter((p) =&gt; p.stock &gt; 0) // First filter only active products\n          .map((p) =&gt; ({\n            // Then map to the desired summary object\n            name: p.productName.toUpperCase(), // Also transform name to uppercase\n            price: p.price.amount,\n          }))\n      )\n    );\n  }\n}\n\n// product-list.component.ts\nimport { Component, OnInit } from \"@angular/core\";\nimport { ProductService } from \"./product.service\";\nimport { Observable } from \"rxjs\";\n\n@Component({\n  selector: \"app-product-list\",\n  template: `\n    &lt;h4&gt;Product Names&lt;/h4&gt;\n    &lt;ul *ngIf=\"productNames$ | async as names; else loading\"&gt;\n      &lt;li *ngFor=\"let name of names\"&gt;{{ name }}&lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;ng-template #loading&gt;Loading product names...&lt;/ng-template&gt;\n\n    &lt;h4&gt;Active Product Summaries&lt;/h4&gt;\n    &lt;ul *ngIf=\"productSummaries$ | async as summaries; else loadingSummaries\"&gt;\n      &lt;li *ngFor=\"let summary of summaries\"&gt;\n        {{ summary.name }} - Price: {{ summary.price | currency : \"INR\" }}\n      &lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;ng-template #loadingSummaries&gt;Loading summaries...&lt;/ng-template&gt;\n  `,\n})\nexport class ProductListComponent implements OnInit {\n  productNames$: Observable&lt;string[]&gt; | undefined;\n  productSummaries$: Observable&lt;{ name: string; price: number }[]&gt; | undefined;\n\n  constructor(private productService: ProductService) {}\n\n  ngOnInit(): void {\n    // Get the observable stream of product names (already transformed by map in the service)\n    this.productNames$ = this.productService.getProductNames();\n    this.productSummaries$ = this.productService.getActiveProductSummaries();\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>import { map } from 'rxjs/operators';</code>: We import the <code>map</code> operator.</li> <li><code>this.http.get&lt;RawProduct[]&gt;(this.apiUrl).pipe(...)</code>: We make the HTTP request, which returns an <code>Observable&lt;RawProduct[]&gt;</code>. We use <code>.pipe()</code> to chain operators onto it.</li> <li><code>map((products: RawProduct[]) =&gt; { ... })</code>: We apply the <code>map</code> operator. The function inside <code>map</code> receives the emitted value from the source Observable \u2013 in this case, the array of <code>RawProduct</code> objects (<code>products</code>).</li> <li><code>products.map(product =&gt; product.productName)</code>: Inside the RxJS <code>map</code> function, we use the standard JavaScript <code>Array.map</code> method to iterate over the <code>products</code> array and pull out only the <code>productName</code> from each object.</li> <li><code>return names;</code>: The RxJS <code>map</code> operator takes the result of its inner function (the <code>names</code> array) and emits that as its own output value.</li> <li>Result: The <code>getProductNames()</code> method now returns an <code>Observable&lt;string[]&gt;</code>, which directly provides the data structure the component needs, thanks to the <code>map</code> operator doing the transformation in the service. The second example (<code>getActiveProductSummaries</code>) shows combining <code>filter</code> and <code>map</code> within the RxJS <code>map</code> operator's projection function for more complex transformations.</li> </ol>"},{"location":"Operators/Transformation/map/#summary","title":"Summary","text":"<p><code>map()</code> is your go-to tool whenever you need to change the shape or content of individual items flowing through your Observable stream without affecting the stream's overall timing or structure.</p>"},{"location":"Operators/Transformation/mergeMap/","title":"mergeMap","text":"<p><code>mergeMap()</code> is a higher-order mapping operator used to handle scenarios where each value emitted by a source (outer) Observable triggers an asynchronous operation that returns another Observable (an inner Observable).</p> <p>Here's how it works:</p> <ol> <li>It takes a value emitted by the source (outer) Observable.</li> <li>It uses that value and a function you provide to create a new inner Observable.</li> <li>It subscribes to this new inner Observable.</li> <li>Crucially (and unlike <code>switchMap</code>): If the source Observable emits a new value, <code>mergeMap</code> does not cancel or unsubscribe from any previous inner Observables that might still be running.</li> <li>It subscribes to the new inner Observable generated by the new source value and runs it concurrently with any other active inner Observables.</li> <li>It then merges the values emitted by all the active inner Observables into a single output stream. The order of the output values depends on when the inner Observables emit, not necessarily the order of the outer source emissions.</li> </ol> <p>Think of it as spawning multiple asynchronous tasks based on incoming triggers and collecting all their results together as they complete, without cancelling anything.</p>"},{"location":"Operators/Transformation/mergeMap/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Higher-Order Mapping: Maps values from an outer Observable to inner Observables.</li> <li>Concurrent Execution: Subscribes to and runs multiple inner Observables in parallel.</li> <li>Merging Output: Combines emissions from all active inner Observables into a single output stream.</li> <li>No Cancellation: Does not cancel previous inner operations when new outer values arrive.</li> <li>Use Cases: Ideal when you need to perform multiple asynchronous actions concurrently based on source emissions and want the results from all of them. Useful when the order of completion isn't strictly important, and parallel processing is beneficial.</li> </ul>"},{"location":"Operators/Transformation/mergeMap/#real-world-example-scenario","title":"Real-World Example Scenario","text":"<p>It's Monday evening here in Bengaluru (around 5:40 PM IST), and imagine you're working on a feature in an Angular application where a user can modify several pieces of data (e.g., multiple settings, or various documents in a list) and then click a single \"Save All\" button.</p> <ul> <li>The click event triggers an action.</li> <li>You get a list of items that need saving (e.g., <code>['settingA', 'settingB', 'documentX']</code>).</li> <li>For each item in the list, you need to make a separate API call (e.g., <code>http.put('/api/settings/settingA', ...)</code>, <code>http.put('/api/settings/settingB', ...)</code>, etc.).</li> <li>You want these save operations to happen in parallel to make it faster. You don't want to wait for 'settingA' to finish saving before starting the save for 'settingB'.</li> <li>You want to get feedback (like a success/error message) for each individual save operation as it completes.</li> </ul> <p><code>mergeMap</code> is perfect for this because it will take each item ID, trigger its corresponding API call (inner Observable), run all these API calls concurrently, and merge their results (e.g., success/error responses) into the output stream as they arrive.</p>"},{"location":"Operators/Transformation/mergeMap/#code-snippet-angular-component-save-all-example","title":"Code Snippet (Angular Component - Save All Example)","text":"<pre><code>import { Component } from \"@angular/core\";\nimport { HttpClient } from \"@angular/common/http\";\nimport { from, of, Observable } from \"rxjs\";\nimport { mergeMap, catchError, map, tap } from \"rxjs/operators\";\n\ninterface SaveItem {\n  id: string;\n  payload: any;\n  apiUrl: string;\n}\n\ninterface SaveResult {\n  id: string;\n  success: boolean;\n  message: string;\n  response?: any;\n}\n\n@Component({\n  selector: \"app-save-all-demo\",\n  template: `\n    &lt;h4&gt;Concurrent Save Demo&lt;/h4&gt;\n    &lt;button (click)=\"saveAll()\" class=\"btn btn-primary\" [disabled]=\"isSaving\"&gt;\n      {{ isSaving ? \"Saving...\" : \"Save All Changes\" }}\n    &lt;/button&gt;\n    &lt;ul class=\"list-group mt-2\"&gt;\n      &lt;li\n        *ngFor=\"let result of saveResults\"\n        class=\"list-group-item\"\n        [ngClass]=\"{\n          'list-group-item-success': result.success,\n          'list-group-item-danger': !result.success\n        }\"\n      &gt;\n        {{ result.message }}\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  `,\n})\nexport class SaveAllDemoComponent {\n  saveResults: SaveResult[] = [];\n  isSaving = false;\n\n  constructor(private http: HttpClient) {}\n\n  saveAll(): void {\n    this.isSaving = true;\n    this.saveResults = []; // Clear previous results\n\n    // 1. Define the items that need saving (could come from component state)\n    const itemsToSave: SaveItem[] = [\n      {\n        id: \"doc1\",\n        payload: { content: \"Updated content for Doc 1\" },\n        apiUrl: \"/api/documents/doc1\",\n      },\n      {\n        id: \"settingA\",\n        payload: { value: true },\n        apiUrl: \"/api/settings/settingA\",\n      },\n      {\n        id: \"userPrefX\",\n        payload: { theme: \"dark\" },\n        apiUrl: \"/api/preferences/userPrefX\",\n      },\n    ];\n\n    // 2. Create an Observable from the array of items\n    const itemsSource$ = from(itemsToSave);\n\n    // 3. Use mergeMap to process each item concurrently\n    itemsSource$\n      .pipe(\n        tap((item) =&gt;\n          console.log(\n            `Starting save process for: ${\n              item.id\n            } at ${new Date().toLocaleTimeString()}`\n          )\n        ),\n        mergeMap(\n          // This function is called for each item ('doc1', 'settingA', 'userPrefX')\n          (itemToSave: SaveItem) =&gt; {\n            console.log(\n              `   [mergeMap] Triggering API call for: ${itemToSave.id}`\n            );\n            // Return the inner Observable (the HTTP PUT/POST request) for this item\n            // mergeMap subscribes to this immediately and runs it concurrently with others.\n            return this.http\n              .put&lt;any&gt;(itemToSave.apiUrl, itemToSave.payload)\n              .pipe(\n                // Map the successful HTTP response to a SaveResult object\n                map((response) =&gt; ({\n                  id: itemToSave.id,\n                  success: true,\n                  message: `Successfully saved ${itemToSave.id}.`,\n                  response: response,\n                })),\n                // Catch errors specific to this *inner* HTTP request\n                catchError((error) =&gt; {\n                  console.error(`Error saving ${itemToSave.id}:`, error);\n                  // Return an Observable emitting a failure SaveResult\n                  // 'of()' creates an Observable that emits the value and completes.\n                  return of({\n                    id: itemToSave.id,\n                    success: false,\n                    message: `Failed to save ${itemToSave.id}: ${\n                      error.statusText || \"Unknown error\"\n                    }`,\n                  });\n                })\n              ); // End of inner http observable pipe\n          } // End of mergeMap project function\n        ) // End of outer pipe\n      )\n      .subscribe({\n        next: (result: SaveResult) =&gt; {\n          // This 'next' handler receives results from *any* of the inner HTTP calls\n          // as they complete. The order is not guaranteed.\n          console.log(`Received result: ${result.message}`);\n          this.saveResults.push(result);\n        },\n        error: (err) =&gt; {\n          // This catches errors in the outer stream (e.g., if 'from(itemsToSave)' failed)\n          // Errors from inner HTTP calls are caught by the inner catchError.\n          console.error(\"Outer stream error:\", err);\n          this.isSaving = false;\n          this.saveResults.push({\n            id: \"GLOBAL_ERROR\",\n            success: false,\n            message: \"An unexpected error occurred in the save process.\",\n          });\n        },\n        complete: () =&gt; {\n          // This is called only when the outer stream (itemsSource$) completes AND\n          // *all* inner Observables spawned by mergeMap have also completed.\n          console.log(\n            `All save operations finalized at ${new Date().toLocaleTimeString()}.`\n          );\n          this.isSaving = false;\n        },\n      });\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>from(itemsToSave)</code>: Creates the outer Observable, emitting each <code>SaveItem</code> object one by one.</li> <li><code>mergeMap((itemToSave: SaveItem) =&gt; ...)</code>: For each <code>SaveItem</code> emitted by <code>from()</code>:<ul> <li>It immediately calls the function provided.</li> <li>This function returns <code>this.http.put(...)</code>, which is the inner Observable representing the API call for that specific item.</li> <li><code>mergeMap</code> subscribes to this inner Observable without unsubscribing from any previous ones. If <code>from()</code> emits <code>item1</code>, <code>item2</code>, <code>item3</code> quickly, <code>mergeMap</code> will likely have three concurrent <code>http.put</code> requests running.</li> </ul> </li> <li>Inner <code>map</code> and <code>catchError</code>: These handle the result of each individual API call, transforming it into a standard <code>SaveResult</code> format whether it succeeds or fails. The <code>catchError</code> prevents a single failed save from stopping the processing of other saves.</li> <li><code>subscribe({...})</code>:<ul> <li>The <code>next</code> handler receives <code>SaveResult</code> objects as soon as any of the concurrent HTTP requests complete. The order might be different from the order in <code>itemsToSave</code> depending on server response times.</li> <li>The <code>complete</code> handler only fires when all items from the <code>from()</code> observable have been processed by <code>mergeMap</code>, and all the corresponding inner HTTP observables have completed.</li> </ul> </li> </ol>"},{"location":"Operators/Transformation/mergeMap/#summary","title":"Summary","text":"<p>use <code>mergeMap()</code> when you need to trigger multiple asynchronous operations based on incoming events/data and want them to run concurrently, collecting all their results as they finish. It's ideal for parallelism where cancellation of previous operations is not needed or desired.</p>"},{"location":"Operators/Transformation/switchMap-mergeMap-concatMap/","title":"switchMap Vs mergeMap Vs concatMap","text":"<p>Let's break down the theoretical differences between <code>switchMap</code>, <code>mergeMap</code>, and <code>concatMap</code>.</p> <p>All three are higher-order mapping operators in RxJS, meaning they map each value from a source (outer) Observable to a new (inner) Observable. The key difference lies in how they handle the subscription and emissions of these inner Observables, especially when the source Observable emits values rapidly.</p> <p>Here\u2019s a theoretical comparison:</p> <ol> <li> <p><code>switchMap</code></p> <ul> <li>Strategy: Cancellation / Focus on Latest.</li> <li>Behavior: When the source Observable emits a value, <code>switchMap</code> maps it to an inner Observable and subscribes. If the source emits a new value before the current inner Observable completes, <code>switchMap</code> will unsubscribe from the previous inner Observable (cancelling its ongoing work and discarding any potential future emissions from it) and then subscribe to the new inner Observable created from the latest source value.</li> <li>Concurrency: Only one inner Observable (the latest one) is active at any given time.</li> <li>Order: Output values come only from the most recent inner Observable. The order depends on that inner Observable, but older inner streams are cancelled entirely.</li> <li>Use When: You only care about the results corresponding to the most recent source emission. Useful for scenarios like type-ahead search suggestions where previous requests become irrelevant.</li> </ul> </li> <li> <p><code>mergeMap</code> (alias: <code>flatMap</code>)</p> <ul> <li>Strategy: Concurrency / Merging.</li> <li>Behavior: When the source Observable emits a value, <code>mergeMap</code> maps it to an inner Observable and subscribes. If the source emits a new value, <code>mergeMap</code> does not cancel any previous inner Observables. It simply creates and subscribes to the new inner Observable, allowing multiple inner Observables to run concurrently.</li> <li>Concurrency: Can have multiple inner Observables running in parallel. The level of concurrency can optionally be limited by passing a second argument to <code>mergeMap</code>.</li> <li>Order: Output values from all active inner Observables are merged into a single stream as they arrive. The order of output values is not guaranteed to match the order of source emissions; it depends on how quickly each inner Observable emits.</li> <li>Use When: You want to handle all source emissions by triggering potentially long-running operations and need them to run in parallel for efficiency. The order of completion doesn't matter as much as getting all the results eventually. Useful for making multiple concurrent API calls.</li> </ul> </li> <li> <p><code>concatMap</code></p> <ul> <li>Strategy: Sequential / Queueing.</li> <li>Behavior: When the source Observable emits a value, <code>concatMap</code> maps it to an inner Observable. It subscribes to this inner Observable. If the source emits a new value before the current inner Observable completes, <code>concatMap</code> will wait. It holds onto the new source value and only maps/subscribes to its corresponding inner Observable after the current one has finished completely.</li> <li>Concurrency: Only one inner Observable is active at any given time. Others are effectively queued.</li> <li>Order: Output values are guaranteed to be in the same order as the source emissions because each inner Observable is processed sequentially.</li> <li>Use When: The order of execution is critical. You need to ensure that the operation triggered by one source value completes fully before starting the operation for the next source value. Useful for sequential API updates or processing items in a strict order.</li> </ul> </li> </ol> <p>In a Nutshell:</p> Operator Inner Observable Handling Concurrency Order Analogy <code>switchMap</code> Cancels previous, switches to latest Only latest Latest matters Restless TV channel surfing <code>mergeMap</code> Runs all concurrently High (Parallel) Interleaved Opening many browser tabs <code>concatMap</code> Waits for completion, processes sequentially One at a time Strict Waiting in a single queue"},{"location":"Operators/Transformation/switchMap/","title":"switchMap","text":"<p><code>switchMap()</code> is a higher-order mapping operator. This means it does two things:</p> <ol> <li>It takes a value emitted by the source (outer) Observable.</li> <li>It uses that value to create and subscribe to a new inner Observable (using a function you provide).</li> </ol> <p>The crucial part is the \"switch\" behavior:</p> <ul> <li>If the source Observable emits a new value while a previous inner Observable (created from an earlier source value) is still active (hasn't completed), <code>switchMap</code> will immediately unsubscribe from that previous inner Observable.</li> <li>It then subscribes to the new inner Observable created from the latest source value.</li> </ul> <p>Essentially, <code>switchMap</code> cancels the previous ongoing inner operation and switches its focus entirely to the new one triggered by the most recent source emission. You only get values from the currently active inner Observable.</p>"},{"location":"Operators/Transformation/switchMap/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Higher-Order Mapping: Maps values from an outer Observable to inner Observables.</li> <li>Switching/Cancellation: Unsubscribes from the previous inner Observable when the outer source emits a new value.</li> <li>Focus on Latest: Only emissions from the most recent inner Observable are passed downstream.</li> <li>Use Cases: Ideal when you only care about the result corresponding to the latest trigger event and want to discard results from previous, potentially outdated triggers.</li> </ul>"},{"location":"Operators/Transformation/switchMap/#real-world-example-scenario-the-classic-use-case-type-ahead-search","title":"Real-World Example Scenario (The Classic Use Case): Type-Ahead Search","text":"<p>This is the quintessential example for <code>switchMap</code>. Imagine you have a search input field in your Angular application (perhaps you're building one right now, Monday evening here in Bengaluru!). As the user types, you want to make API calls to fetch search suggestions.</p> <ul> <li>User types \"a\" -&gt; Trigger API call for \"a\"</li> <li>User quickly types \"n\" (now input is \"an\") -&gt; Trigger API call for \"an\" -&gt; <code>switchMap</code> cancels the pending API call for \"a\"</li> <li>User quickly types \"g\" (now input is \"ang\") -&gt; Trigger API call for \"ang\" -&gt; <code>switchMap</code> cancels the pending API call for \"an\"</li> </ul> <p>You only care about the results for the latest search term (\"ang\"). <code>switchMap</code> ensures that you don't receive outdated results (like suggestions for \"a\" arriving after suggestions for \"ang\") and prevents unnecessary network requests from completing if they've already been superseded.</p>"},{"location":"Operators/Transformation/switchMap/#code-snippet","title":"Code Snippet","text":"<pre><code>import {\n  Component,\n  OnInit,\n  ViewChild,\n  ElementRef,\n  OnDestroy,\n} from \"@angular/core\";\nimport { HttpClient, HttpParams } from \"@angular/common/http\";\nimport { fromEvent, Observable, Subscription, of } from \"rxjs\";\nimport {\n  map,\n  debounceTime, // Wait for pauses in typing\n  distinctUntilChanged, // Only search if the term changes\n  switchMap, // Cancel previous requests, switch to new one\n  catchError, // Handle HTTP errors\n  tap, // For logging side-effects\n} from \"rxjs/operators\";\n\n@Component({\n  selector: \"app-typeahead-search\",\n  template: `\n    &lt;h4&gt;Live Search Example&lt;/h4&gt;\n    &lt;input\n      #searchInput\n      type=\"text\"\n      placeholder=\"Search Wikipedia...\"\n      class=\"form-control\"\n    /&gt;\n    &lt;div *ngIf=\"loading\" class=\"spinner-border spinner-border-sm\" role=\"status\"&gt;\n      &lt;span class=\"visually-hidden\"&gt;Loading...&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;ul class=\"list-group mt-2\" *ngIf=\"results$ | async as results\"&gt;\n      &lt;li *ngIf=\"results.length === 0 &amp;&amp; lastSearchTerm &amp;&amp; !loading\"&gt;\n        No results found for \"{{ lastSearchTerm }}\"\n      &lt;/li&gt;\n      &lt;li *ngFor=\"let result of results\" class=\"list-group-item\"&gt;\n        &lt;a [href]=\"result.link\" target=\"_blank\"&gt;{{ result.title }}&lt;/a&gt;\n        &lt;p&gt;{{ result.description }}&lt;/p&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;div *ngIf=\"searchError\" class=\"alert alert-danger mt-2\"&gt;\n      Error: {{ searchError }}\n    &lt;/div&gt;\n  `,\n})\nexport class TypeaheadSearchComponent implements OnInit, OnDestroy {\n  @ViewChild(\"searchInput\", { static: true }) searchInput:\n    | ElementRef\n    | undefined;\n\n  results$: Observable&lt;any[]&gt; | undefined;\n  loading = false;\n  searchError: string | null = null;\n  lastSearchTerm: string | null = null;\n\n  private searchSubscription: Subscription | undefined;\n\n  // Using Wikipedia's public API for demonstration\n  private WIKI_API_URL = \"https://en.wikipedia.org/w/api.php\";\n\n  constructor(private http: HttpClient) {}\n\n  ngOnInit(): void {\n    if (!this.searchInput) return;\n\n    // 1. Get the stream of input events from the input element\n    const inputEvents$ = fromEvent&lt;InputEvent&gt;(\n      this.searchInput.nativeElement,\n      \"input\"\n    );\n\n    this.results$ = inputEvents$.pipe(\n      // 2. Get the trimmed value from the input event\n      map((event) =&gt; (event.target as HTMLInputElement).value.trim()),\n\n      // 3. Wait for 400ms pause in typing before proceeding\n      debounceTime(400),\n\n      // 4. Only proceed if the value has actually changed from the last time\n      distinctUntilChanged(),\n\n      // 5. Show loading indicator and log the term\n      tap((term) =&gt; {\n        console.log(\n          `Searching for: \"${term}\" at ${new Date().toLocaleTimeString()}`\n        );\n        this.loading = term.length &gt; 0; // Show loading only if there's a term\n        this.searchError = null; // Clear previous errors\n        this.lastSearchTerm = term; // Keep track of the term searched\n        if (!term) {\n          // Clear results immediately if input is empty, without API call\n          return of([]); // Need to return an observable for switchMap\n        }\n        return undefined; // Continue the main pipe if term exists\n      }),\n\n      // 6. The core: switchMap! Map the search term to an HTTP request Observable\n      switchMap((term) =&gt; {\n        if (term.length === 0) {\n          // If term is empty after debounce/distinct, return observable of empty array\n          this.loading = false;\n          return of([]); // 'of' creates an Observable that emits [] and completes\n        }\n\n        // Prepare parameters for Wikipedia API call\n        const params = new HttpParams()\n          .set(\"action\", \"opensearch\")\n          .set(\"search\", term)\n          .set(\"limit\", \"10\") // Limit results\n          .set(\"namespace\", \"0\")\n          .set(\"format\", \"json\")\n          .set(\"origin\", \"*\"); // Needed for CORS in browser\n\n        // Return the inner Observable (the HTTP GET request)\n        // If a new term arrives quickly, switchMap will cancel this HTTP request\n        // if it's still pending, and start a new one for the new term.\n        return this.http.get&lt;any[]&gt;(this.WIKI_API_URL, { params }).pipe(\n          map((response) =&gt; {\n            // Wikipedia API returns [searchTerm, [titles], [descriptions], [links]]\n            // Let's transform this into a more usable array of objects\n            const titles = response[1] || [];\n            const descriptions = response[2] || [];\n            const links = response[3] || [];\n            return titles.map((title: string, index: number) =&gt; ({\n              title: title,\n              description: descriptions[index],\n              link: links[index],\n            }));\n          }),\n          catchError((err) =&gt; {\n            console.error(\"API Error:\", err);\n            this.searchError = `Failed to fetch results (${\n              err.message || \"Unknown error\"\n            })`;\n            this.loading = false;\n            return of([]); // Return an empty array Observable on error to keep the stream alive\n          })\n        );\n      }),\n\n      // 7. Hide loading indicator after results arrive or error handled\n      tap(() =&gt; (this.loading = false))\n    );\n\n    // We can let the async pipe handle the subscription in the template\n    // this.searchSubscription = this.results$.subscribe(); // Manual subscription not needed for display with async pipe\n  }\n\n  ngOnDestroy(): void {\n    // Although switchMap handles inner subscriptions, if the component itself\n    // is destroyed, we should clean up the main subscription to fromEvent\n    // (if we were subscribing manually). AsyncPipe handles this automatically.\n    // if (this.searchSubscription) {\n    //   this.searchSubscription.unsubscribe();\n    // }\n    console.log(\"Typeahead search component destroyed.\");\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li><code>fromEvent</code>: Creates the outer Observable from input events.</li> <li><code>map</code>: Extracts the text value.</li> <li><code>debounceTime(400)</code>: Waits for the user to pause typing for 400ms before emitting the term.</li> <li><code>distinctUntilChanged()</code>: Prevents searching if the term hasn't changed (e.g., typing \"a\", deleting \"a\", typing \"a\" again quickly).</li> <li><code>tap</code>: Used for side effects like logging and setting the <code>loading</code> flag.</li> <li><code>switchMap(term =&gt; ...)</code>: This is the key part.<ul> <li>It receives the debounced, distinct search <code>term</code>.</li> <li>If the <code>term</code> is empty, it returns <code>of([])</code> (an Observable that emits an empty array and completes) to clear results.</li> <li>If the <code>term</code> exists, it returns <code>this.http.get(...)</code> which is the inner Observable.</li> <li>If a new <code>term</code> arrives from <code>distinctUntilChanged</code> before the <code>http.get</code> for the previous <code>term</code> completes, <code>switchMap</code> cancels that pending HTTP request and starts a new one for the new <code>term</code>.</li> </ul> </li> <li><code>catchError</code>: Handles potential errors during the HTTP request inside <code>switchMap</code> so that an API failure doesn't kill the entire input event stream.</li> <li><code>async</code> pipe: In the template (<code>*ngIf=\"results$ | async as results\"</code>), the <code>async</code> pipe subscribes to <code>results$</code> and automatically handles updates and unsubscription when the component is destroyed.</li> </ol>"},{"location":"Operators/Transformation/switchMap/#summary","title":"Summary","text":"<p><code>switchMap</code> is your go-to operator when you need to map an event or value to an inner asynchronous operation (like an API call) and you only care about the results of the latest operation, wanting to cancel any previous, now-irrelevant operations.</p>"},{"location":"Operators/Utility/delay/","title":"delay","text":"<p>The <code>delay</code> operator simply shifts the emission of each notification (<code>next</code>, <code>error</code>, <code>complete</code>) from its source Observable forward in time by a specified duration.</p> <p>Think of it like scheduled mail delivery:</p> <ul> <li>The source Observable \"drops a letter in the mailbox\" (<code>next</code> emission occurs).</li> <li>The <code>delay</code> operator picks it up but holds onto it.</li> <li>It waits for the specified time (e.g., 500 milliseconds).</li> <li>Then, it delivers the letter (emits the <code>next</code> value) downstream.</li> </ul> <p>The same happens for <code>error</code> and <code>complete</code> signals \u2013 they are also held for the specified duration before being passed on.</p>"},{"location":"Operators/Utility/delay/#key-points","title":"Key Points","text":"<ol> <li>Delays Emissions: It delays when the values/signals are sent to the next operator or subscriber.</li> <li>Doesn't Delay Subscription: The subscription to the source happens immediately; only the emissions are postponed.</li> <li>Applies to All Notifications: It delays <code>next</code>, <code>error</code>, and <code>complete</code>.</li> <li>Input: Takes a duration in milliseconds (e.g., <code>delay(500)</code>) or a specific future <code>Date</code>.</li> </ol>"},{"location":"Operators/Utility/delay/#why-use-delay","title":"Why Use <code>delay</code>?","text":"<ol> <li>UI Polish: Simulate a minimum processing time. For example, if saving data is extremely fast, a \"Saving...\" message might just flash on and off. Using <code>delay</code> can ensure the message stays visible for at least, say, half a second, providing better user feedback.</li> <li>Testing/Debugging: Introduce artificial latency into streams to test how your application handles timing issues or loading states.</li> <li>Simple Sequencing (Less Common): Ensure a small pause before an action occurs after an event (though more complex sequencing often uses other operators).</li> </ol>"},{"location":"Operators/Utility/delay/#real-world-example-minimum-display-time-for-a-saved-message","title":"Real-World Example: Minimum Display Time for a \"Saved\" Message","text":"<p>Imagine clicking a \"Save\" button. The backend operation might be incredibly fast (e.g., 50ms). If you immediately show and then hide a \"Saved!\" confirmation, the user might not even register it. Let's ensure the \"Saved!\" message stays visible for at least 750ms.</p>"},{"location":"Operators/Utility/delay/#code-snippet","title":"Code Snippet","text":"<pre><code>import {\n  Component,\n  inject,\n  signal,\n  ChangeDetectionStrategy,\n  DestroyRef,\n} from \"@angular/core\";\nimport { CommonModule } from \"@angular/common\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\nimport { Observable, of, timer } from \"rxjs\"; // Import 'of' and 'timer'\nimport { delay, switchMap, tap, finalize, catchError } from \"rxjs/operators\";\nimport { EMPTY } from \"rxjs\"; // Import EMPTY\n\n// Mock Service Function (simulates a quick backend save)\nfunction mockSaveOperation(): Observable&lt;{\n  success: boolean;\n  timestamp: number;\n}&gt; {\n  console.log(\"Backend: Starting simulated save...\");\n  const saveSuccess = Math.random() &gt; 0.2; // Simulate occasional failure\n  return of(saveSuccess).pipe(\n    delay(100), // Simulate VERY FAST network/backend time (100ms)\n    tap((success) =&gt;\n      console.log(\n        `Backend: Simulated save ${success ? \"successful\" : \"failed\"}.`\n      )\n    ),\n    switchMap((success) =&gt; {\n      if (success) {\n        return of({ success: true, timestamp: Date.now() });\n      } else {\n        // Simulate an error being returned from backend\n        return timer(50).pipe(\n          switchMap(() =&gt; {\n            throw new Error(\"Save failed due to backend validation.\");\n          })\n        );\n      }\n    })\n  );\n}\n\n@Component({\n  selector: \"app-save-status\",\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    &lt;div&gt;\n      &lt;h4&gt;Save Example with Delay&lt;/h4&gt;\n      &lt;button (click)=\"saveData()\" [disabled]=\"saving()\"&gt;Save Data&lt;/button&gt;\n\n      @if (saving()) {\n      &lt;p class=\"status saving\"&gt;Saving...&lt;/p&gt;\n      } @else if (statusMessage()) {\n      &lt;p\n        class=\"status\"\n        [class.success]=\"isSuccess()\"\n        [class.error]=\"!isSuccess()\"\n      &gt;\n        {{ statusMessage() }}\n      &lt;/p&gt;\n      }\n    &lt;/div&gt;\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class SaveStatusComponent {\n  private destroyRef = inject(DestroyRef);\n\n  // --- State Signals ---\n  saving = signal&lt;boolean&gt;(false);\n  statusMessage = signal&lt;string | null&gt;(null);\n  isSuccess = signal&lt;boolean&gt;(false);\n\n  saveData(): void {\n    if (this.saving()) return; // Prevent multiple saves\n\n    this.saving.set(true);\n    this.statusMessage.set(null); // Clear previous status\n    console.log('UI: Save initiated, showing \"Saving...\"');\n\n    const minimumDisplayTime = 750; // Ensure feedback shows for at least 750ms\n\n    mockSaveOperation()\n      .pipe(\n        tap({\n          next: (result) =&gt;\n            console.log(\"UI Stream: Save operation successful (before delay)\"),\n          error: (err) =&gt;\n            console.error(\"UI Stream: Save operation failed (before delay)\"),\n        }),\n\n        // --- Apply the delay ---\n        // Delay the NEXT or ERROR notification by minimumDisplayTime\n        delay(minimumDisplayTime),\n        // ---------------------\n\n        catchError((err: Error) =&gt; {\n          // Handle the error AFTER the delay\n          console.error(\"UI: Handling error after delay:\", err.message);\n          this.isSuccess.set(false);\n          this.statusMessage.set(`Error: ${err.message}`);\n          // Return EMPTY to gracefully complete the stream for finalize\n          return EMPTY;\n        }),\n        // finalize runs after delay + next/error/complete\n        finalize(() =&gt; {\n          console.log('UI: Finalizing save operation (hiding \"Saving...\")');\n          this.saving.set(false);\n        }),\n        // Automatically unsubscribe when the component is destroyed\n        takeUntilDestroyed(this.destroyRef)\n      )\n      .subscribe({\n        next: (result) =&gt; {\n          // Handle success AFTER the delay\n          console.log(`UI: Displaying success message after delay.`);\n          this.isSuccess.set(true);\n          this.statusMessage.set(\n            `Saved successfully at ${new Date(\n              result.timestamp\n            ).toLocaleTimeString()}`\n          );\n        },\n        // Error is handled in catchError\n        // Complete isn't strictly needed here as finalize covers the loading state change\n      });\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li>When <code>saveData()</code> is called, <code>saving</code> is set to <code>true</code>, showing the \"Saving...\" message immediately.</li> <li><code>mockSaveOperation()</code> is called. It simulates a quick backend response (completes in ~100ms) using <code>of(...)</code> and <code>delay(100)</code>.</li> <li>The result (or error) from <code>mockSaveOperation</code> flows into the component's RxJS pipe.</li> <li>The first <code>tap</code> logs the immediate result from the \"backend\".</li> <li><code>delay(minimumDisplayTime)</code>: This is the key part. If the backend responded successfully (<code>next</code>), <code>delay</code> holds that success notification for 750ms before passing it on. If the backend responded with an error, <code>delay</code> holds that error notification for 750ms.</li> <li>After the 750ms delay:<ul> <li>If successful: The <code>next</code> notification proceeds to the <code>subscribe</code> block's <code>next</code> handler. The success message is displayed.</li> <li>If an error occurred: The <code>error</code> notification proceeds to the <code>catchError</code> operator. The error message is displayed.</li> </ul> </li> <li><code>finalize</code>: This runs after the delayed <code>next</code> or <code>error</code> has been processed (or if the stream completes/unsubscribes). It sets <code>saving</code> to <code>false</code>, hiding the \"Saving...\" message.</li> <li><code>takeUntilDestroyed</code>: Standard cleanup.</li> </ol> <p>Because of <code>delay(750)</code>, even though the backend might respond in 100ms, the UI won't update with the final \"Saved!\" or \"Error...\" message, and the \"Saving...\" indicator won't disappear, until at least 750ms have passed since the backend responded. This gives the user time to perceive the feedback.</p>"},{"location":"Operators/Utility/finalize/","title":"finalize","text":"<p>The <code>finalize</code> operator lets you specify a callback function that will be executed when the source Observable terminates. Termination happens in one of three ways:</p> <ol> <li>The Observable completes successfully (sends its last value and the <code>complete</code> notification).</li> <li>The Observable emits an error notification.</li> <li>The subscription to the Observable is unsubscribed (e.g., manually, or automatically via operators like <code>take</code>, <code>takeUntil</code>, or <code>takeUntilDestroyed</code>).</li> </ol> <p>Think of it like the <code>finally</code> block in a traditional <code>try...catch...finally</code> statement. The code inside <code>finalize</code> is guaranteed to run after the Observable finishes its work or is stopped, regardless of why it stopped (success, error, or unsubscription).</p>"},{"location":"Operators/Utility/finalize/#key-points","title":"Key Points","text":"<ol> <li>Guaranteed Execution on Termination: Runs whether the stream succeeds, fails, or is unsubscribed.</li> <li>No Arguments: The callback function you provide to <code>finalize</code> receives no arguments. It doesn't know if an error occurred or what the last value was; it just knows the stream is done.</li> <li>Side Effects Only: Like <code>tap</code>, <code>finalize</code> is purely for side effects. It doesn't affect the values, errors, or completion signals passing through the stream (because it runs after them).</li> <li>Ideal for Cleanup: Its primary purpose is resource cleanup or actions that must happen when an operation is finished.</li> </ol>"},{"location":"Operators/Utility/finalize/#why-use-finalize","title":"Why Use <code>finalize</code>?","text":"<p>The most common and important use case is managing loading states.</p> <ul> <li>You start an operation (e.g., HTTP request).</li> <li>You set a <code>loading</code> flag/signal to <code>true</code>.</li> <li>The operation might succeed or fail.</li> <li>You need to ensure the <code>loading</code> flag/signal is always set back to <code>false</code> when the operation is finished, no matter the outcome. <code>finalize</code> is perfect for this.</li> </ul> <p>Other uses include:</p> <ul> <li>Closing connections (though often handled by unsubscription itself).</li> <li>Logging the end of an operation.</li> <li>Releasing any temporary resources acquired at the start of the subscription.</li> </ul>"},{"location":"Operators/Utility/finalize/#real-world-example-managing-loading-state-for-data-fetching","title":"Real-World Example: Managing Loading State for Data Fetching","text":"<p>This is the classic example. We fetch data, show a loading indicator, and use <code>finalize</code> to hide the indicator when the fetch completes or fails.</p>"},{"location":"Operators/Utility/finalize/#code-snippet","title":"Code Snippet","text":"<pre><code>import {\n  Component,\n  inject,\n  signal,\n  ChangeDetectionStrategy,\n  DestroyRef,\n} from \"@angular/core\";\nimport { CommonModule } from \"@angular/common\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\nimport { Observable, of, timer } from \"rxjs\";\nimport { delay, switchMap, tap, catchError, finalize } from \"rxjs/operators\";\nimport { EMPTY } from \"rxjs\"; // Import EMPTY\n\n// --- Mock Data Service ---\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n}\n\nfunction mockFetchProducts(\n  failRequest: boolean = false\n): Observable&lt;Product[]&gt; {\n  console.log(\"Backend: Starting simulated product fetch...\");\n  if (failRequest) {\n    // Simulate a delayed error\n    return timer(1200).pipe(\n      tap(() =&gt; console.log(\"Backend: Simulating network error...\")),\n      switchMap(() =&gt; {\n        throw new Error(\"Network Error: Failed to connect to server.\");\n      })\n    );\n  } else {\n    // Simulate a successful response with delay\n    const products: Product[] = [\n      { id: 101, name: \"Super Widget\", price: 19.99 },\n      { id: 102, name: \"Mega Gadget\", price: 29.95 },\n    ];\n    return of(products).pipe(\n      delay(1500), // Simulate network latency\n      tap(() =&gt; console.log(\"Backend: Simulated fetch successful.\"))\n    );\n  }\n}\n// --- End Mock Data Service ---\n\n@Component({\n  selector: \"app-product-list\",\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    &lt;div&gt;\n      &lt;h4&gt;Product List (Finalize Example)&lt;/h4&gt;\n      &lt;button (click)=\"loadProducts(false)\" [disabled]=\"loading()\"&gt;\n        Load Products\n      &lt;/button&gt;\n      &lt;button (click)=\"loadProducts(true)\" [disabled]=\"loading()\"&gt;\n        Load Products (Simulate Error)\n      &lt;/button&gt;\n\n      @if (loading()) {\n      &lt;p class=\"status loading\"&gt;Loading products...&lt;/p&gt;\n      } @if (errorMessage()) {\n      &lt;p class=\"status error\"&gt;Error: {{ errorMessage() }}&lt;/p&gt;\n      } @if (products().length &gt; 0 &amp;&amp; !loading()) {\n      &lt;ul&gt;\n        @for(product of products(); track product.id) {\n        &lt;li&gt;{{ product.name }} - {{ product.price | currency }}&lt;/li&gt;\n        }\n      &lt;/ul&gt;\n      } @else if (!loading() &amp;&amp; !errorMessage()) {\n      &lt;p&gt;Click button to load.&lt;/p&gt;\n      }\n    &lt;/div&gt;\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class ProductListComponent {\n  private destroyRef = inject(DestroyRef);\n\n  // --- State Signals ---\n  loading = signal&lt;boolean&gt;(false);\n  products = signal&lt;Product[]&gt;([]);\n  errorMessage = signal&lt;string | null&gt;(null);\n\n  loadProducts(simulateError: boolean = false): void {\n    if (this.loading()) return; // Don't load if already loading\n\n    this.loading.set(true); // &lt;-- Start Loading Indicator\n    this.products.set([]);\n    this.errorMessage.set(null);\n    console.log(\"UI: Fetch initiated, showing loading state.\");\n\n    mockFetchProducts(simulateError)\n      .pipe(\n        tap((data) =&gt;\n          console.log(\"UI Stream: Received product data (before finalize)\")\n        ),\n        catchError((err: Error) =&gt; {\n          console.error(\"UI Stream: Error caught:\", err.message);\n          this.errorMessage.set(err.message || \"Could not load products.\");\n          // Return EMPTY to allow finalize to run after error handling\n          return EMPTY;\n        }),\n        // --- Key Operator ---\n        // This block runs AFTER success (tap), OR AFTER error (catchError),\n        // OR if the subscription is cancelled (e.g., by takeUntilDestroyed).\n        finalize(() =&gt; {\n          this.loading.set(false); // &lt;-- Stop Loading Indicator\n          console.log(\n            \"UI: Finalize block executed - Loading state set to false.\"\n          );\n        }),\n        // --------------------\n        takeUntilDestroyed(this.destroyRef) // Ensure unsubscription on destroy\n      )\n      .subscribe({\n        next: (data) =&gt; {\n          console.log(\"UI: Subscribe next - updating product list.\");\n          this.products.set(data);\n        },\n        // Error already handled by catchError\n        error: (err) =&gt; {\n          /* No need for code here usually if catchError handles UI state */\n        },\n        // Complete isn't needed for loading state because finalize covers it\n        complete: () =&gt; {\n          console.log(\"UI: Subscribe complete.\");\n        },\n      });\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li>When <code>loadProducts</code> is called, <code>loading</code> is immediately set to <code>true</code>, displaying the \"Loading products...\" message.</li> <li><code>mockFetchProducts</code> returns an Observable that simulates either success or failure after a delay.</li> <li>The <code>pipe</code> chain processes the result:<ul> <li><code>tap</code>: Logs successful data receipt (only runs on success).</li> <li><code>catchError</code>: Catches any error from the source. It sets the <code>errorMessage</code> signal and returns <code>EMPTY</code>. Returning <code>EMPTY</code> makes the stream complete gracefully after the error, ensuring <code>finalize</code> still runs.</li> <li><code>finalize(() =&gt; { this.loading.set(false); })</code>: This is the crucial part. This callback function is registered to run when the stream terminates.</li> <li>If <code>mockFetchProducts</code> succeeds, the <code>next</code> value passes through <code>tap</code>, then the stream completes. <code>finalize</code> runs, setting <code>loading</code> to <code>false</code>.</li> <li>If <code>mockFetchProducts</code> fails, the error goes to <code>catchError</code>. <code>catchError</code> handles it and returns <code>EMPTY</code>, which immediately completes the stream. <code>finalize</code> runs, setting <code>loading</code> to <code>false</code>.</li> <li>If the component is destroyed while the fetch is in progress, <code>takeUntilDestroyed</code> triggers unsubscription. <code>finalize</code> runs, setting <code>loading</code> to <code>false</code>.</li> <li><code>takeUntilDestroyed</code>: Handles automatic unsubscription.</li> </ul> </li> <li>The <code>subscribe</code> block's <code>next</code> handler updates the <code>products</code> signal only on success.</li> </ol> <p>No matter what happens \u2013 success, failure, or component destruction \u2013 the <code>finalize</code> block ensures that <code>this.loading.set(false)</code> is called, correctly cleaning up the UI loading state. This makes it much more reliable than trying to manage the loading flag in both the <code>error</code> and <code>complete</code>/<code>next</code> handlers of the <code>subscribe</code> block.</p>"},{"location":"Operators/Utility/tap/","title":"tap","text":"<p>The <code>tap</code> operator lets you perform side effects for notifications (<code>next</code>, <code>error</code>, <code>complete</code>) emitted by an Observable. A \"side effect\" is an action that doesn't directly modify the value passing through the stream itself.</p> <p>Think of it like this: Data is flowing down a pipe (your Observable stream). <code>tap</code> allows you to attach a sensor to the side of the pipe. This sensor can:</p> <ol> <li>Look at the data flowing past (<code>next</code> notification).</li> <li>React if something goes wrong (an <code>error</code> notification occurs).</li> <li>Notice when the flow stops (<code>complete</code> notification).</li> </ol> <p>Crucially, the sensor ( <code>tap</code> ) does not change the data flowing through the pipe. The same value that comes into <code>tap</code> goes out of <code>tap</code> to the next operator in the chain.</p>"},{"location":"Operators/Utility/tap/#why-use-tap","title":"Why Use <code>tap</code>?","text":"<p>Its primary purpose is performing actions that aren't part of the main data transformation logic:</p> <ol> <li>Logging: The most common use! Log values as they pass through a specific point in your stream to understand what's happening.</li> <li>Debugging: Temporarily insert <code>tap(console.log)</code> to inspect values during development.</li> <li>Updating External State (with caution): You could use <code>tap</code> to update things outside the stream, like setting a loading flag or updating a Signal. However, be mindful \u2013 complex state logic is often better handled directly in the <code>subscribe</code> block or using dedicated state management patterns. The <code>finalize</code> operator is often preferred for cleanup actions like stopping loading indicators.</li> <li>Triggering Other Actions: Maybe start a notification or trigger some non-critical background task based on an emission.</li> </ol>"},{"location":"Operators/Utility/tap/#real-world-example-logging-and-updating-loading-state-during-data-fetch","title":"Real-World Example: Logging and Updating Loading State During Data Fetch","text":"<p>Let's fetch some user data and use <code>tap</code> to log the progress and potentially update a loading state (though we'll use <code>finalize</code> for stopping the loading, as it's more robust).</p>"},{"location":"Operators/Utility/tap/#code-snippets","title":"Code Snippets","text":"<p>1. Simple Data Service (<code>user-data.service.ts</code>)</p> <pre><code>import { Injectable, inject } from \"@angular/core\";\nimport { HttpClient } from \"@angular/common/http\";\nimport { Observable, delay, of } from \"rxjs\"; // Import 'delay' and 'of' for simulation\n\nexport interface SimpleUser {\n  id: number;\n  name: string;\n}\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class UserDataService {\n  private http = inject(HttpClient);\n  private apiUrl = \"https://jsonplaceholder.typicode.com/users/\"; // Fake API\n\n  getUser(id: number): Observable&lt;SimpleUser&gt; {\n    console.log(`UserDataService: Requesting user with ID: ${id}`);\n    // In a real app, use http.get:\n    // return this.http.get&lt;SimpleUser&gt;(`${this.apiUrl}${id}`);\n\n    // --- Simulation for predictable example ---\n    const fakeUser: SimpleUser = { id: id, name: `User ${id}` };\n    return of(fakeUser).pipe(delay(1500)); // Simulate network delay\n    // --- End Simulation ---\n  }\n}\n</code></pre> <p>2. User Profile Component (<code>user-profile.component.ts</code>) - Uses <code>tap</code></p> <pre><code>import {\n  Component,\n  inject,\n  signal,\n  ChangeDetectionStrategy,\n  OnInit,\n  DestroyRef,\n} from \"@angular/core\";\nimport { CommonModule } from \"@angular/common\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\nimport { UserDataService, SimpleUser } from \"./user-data.service\"; // Adjust path\nimport { tap, catchError, finalize } from \"rxjs/operators\";\nimport { EMPTY, Observable } from \"rxjs\"; // Import EMPTY\n\n@Component({\n  selector: \"app-user-profile\",\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    &lt;h3&gt;User Profile (Tap Example)&lt;/h3&gt;\n    &lt;button (click)=\"loadUser(1)\" [disabled]=\"loading()\"&gt;Load User 1&lt;/button&gt;\n    &lt;button (click)=\"loadUser(5)\" [disabled]=\"loading()\"&gt;Load User 5&lt;/button&gt;\n    &lt;button (click)=\"loadUser(999)\" [disabled]=\"loading()\"&gt;\n      Load User 999 (Will Error)\n    &lt;/button&gt;\n\n    @if (loading()) {\n    &lt;p&gt;Loading user data...&lt;/p&gt;\n    } @else if (errorMessage()) {\n    &lt;p style=\"color: red;\"&gt;Error: {{ errorMessage() }}&lt;/p&gt;\n    } @else if (user()) {\n    &lt;div&gt;\n      &lt;h4&gt;{{ user()?.name }}&lt;/h4&gt;\n      &lt;p&gt;ID: {{ user()?.id }}&lt;/p&gt;\n    &lt;/div&gt;\n    } @else {\n    &lt;p&gt;Click a button to load user data.&lt;/p&gt;\n    }\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class UserProfileComponent {\n  private userDataService = inject(UserDataService);\n  private destroyRef = inject(DestroyRef);\n\n  // --- State Signals ---\n  user = signal&lt;SimpleUser | null&gt;(null);\n  loading = signal&lt;boolean&gt;(false);\n  errorMessage = signal&lt;string | null&gt;(null);\n\n  loadUser(id: number): void {\n    this.loading.set(true);\n    this.errorMessage.set(null);\n    this.user.set(null);\n    console.log(`UserProfileComponent: Starting to load user ${id}`);\n\n    // --- Modify service call to handle potential error ---\n    let user$: Observable&lt;SimpleUser&gt;;\n    if (id === 999) {\n      // Simulate an error case\n      user$ = new Observable((observer) =&gt;\n        observer.error(new Error(`User with ID ${id} not found`))\n      ).pipe(delay(500)); // Simulate delay before error\n    } else {\n      user$ = this.userDataService.getUser(id);\n    }\n    // --- End modification ---\n\n    user$\n      .pipe(\n        // --- Using tap ---\n        tap({\n          // Side effect for NEXT notification (successful data emission)\n          next: (userData) =&gt; {\n            console.log(\n              \"%c tap: Received user data in stream:\",\n              \"color: blue\",\n              userData\n            );\n            // You could do other things here, like trigger analytics maybe.\n            // BUT: Notice we don't modify 'userData' here.\n          },\n          // Side effect for ERROR notification\n          error: (err) =&gt; {\n            console.error(\n              \"%c tap: Encountered an error in stream:\",\n              \"color: red\",\n              err.message\n            );\n            // We can log the error here, but handling (like setting UI state)\n            // is often better done in catchError or subscribe's error handler.\n          },\n          // Side effect for COMPLETE notification\n          // (Note: finalize is often more reliable for cleanup)\n          complete: () =&gt; {\n            console.log(\n              \"%c tap: Stream completed (no more values expected).\",\n              \"color: green\"\n            );\n          },\n        }),\n        // -----------------\n        // Handle errors properly. catchError stops the error from killing the stream\n        // and allows finalize to run.\n        catchError((err: Error) =&gt; {\n          this.errorMessage.set(err.message || \"Failed to load user.\");\n          // Return EMPTY or another observable to gracefully complete the stream\n          return EMPTY;\n        }),\n        // finalize runs when the observable completes OR errors (guaranteed cleanup)\n        finalize(() =&gt; {\n          this.loading.set(false);\n          console.log(\n            `UserProfileComponent: Finished loading attempt for user ${id}.`\n          );\n        }),\n        // Automatically unsubscribe when the component is destroyed\n        takeUntilDestroyed(this.destroyRef)\n      )\n      .subscribe({\n        next: (data) =&gt; {\n          // Update the main state in subscribe's next handler\n          this.user.set(data);\n        },\n        // Error handling primarily done in catchError now\n        error: (err) =&gt; {\n          /* Already caught and handled */\n        },\n        // Complete handler (optional, finalize often covers cleanup)\n        complete: () =&gt; {\n          console.log(\"UserProfileComponent: Subscribe detected completion.\");\n        },\n      });\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li>When <code>loadUser()</code> is called, we set the <code>loading</code> signal to <code>true</code>.</li> <li>We call the (modified) <code>userDataService.getUser(id)</code> which returns an Observable.</li> <li>We <code>pipe</code> this Observable through several operators:<ul> <li><code>tap({...})</code>:</li> <li>The <code>next</code> function inside <code>tap</code> logs the received <code>userData</code> when (and if) the <code>getUser</code> Observable successfully emits data. It doesn't change the <code>userData</code>.</li> <li>The <code>error</code> function logs the error if the <code>getUser</code> Observable fails.</li> <li>The <code>complete</code> function logs when the stream finishes normally.</li> <li><code>catchError(...)</code>: This properly handles potential errors. It catches the error from the stream (or from <code>tap</code>'s error handler if it threw one), sets the <code>errorMessage</code> signal, and returns <code>EMPTY</code> so the stream terminates gracefully without crashing the application and allows <code>finalize</code> to run.</li> <li><code>finalize(...)</code>: This is crucial for cleanup. It sets <code>loading</code> back to <code>false</code> regardless of whether the stream completed successfully (<code>next</code> + <code>complete</code>) or errored out (<code>error</code>). This is generally safer than using <code>tap({ complete: ... })</code> for UI state cleanup.</li> <li><code>takeUntilDestroyed(...)</code>: Standard practice for preventing memory leaks by unsubscribing when the component is destroyed.</li> </ul> </li> <li>Finally, <code>.subscribe({...})</code> is called to activate the entire chain.<ul> <li>The <code>next</code> handler in <code>subscribe</code> is the primary place to update the component's main data state (the <code>user</code> signal).</li> <li>The <code>error</code> and <code>complete</code> handlers in <code>subscribe</code> are less critical here because <code>catchError</code> and <code>finalize</code> are handling those aspects for UI state updates.</li> </ul> </li> </ol> <p>Run this code, click the buttons, and watch the console. You'll see the <code>tap</code> logs appearing before the final state updates in the <code>subscribe</code> or <code>finalize</code> blocks, demonstrating how <code>tap</code> lets you observe the stream's events without interfering with the main data flow or error handling logic.</p>"},{"location":"Operators/Utility/timeout/","title":"timeout","text":"<p>The <code>timeout</code> operator sets a time limit. If the source Observable doesn't emit its first value or complete within that specified duration, the <code>timeout</code> operator will cause the stream to emit a <code>TimeoutError</code> and terminate.</p> <p>Think of it like setting an egg timer for an operation:</p> <ul> <li>You start an operation (subscribe to the source Observable).</li> <li>You start the timer (<code>timeout</code> operator).</li> <li>If the operation finishes (emits a value or completes) before the timer goes off, everything is fine.</li> <li>If the timer goes off before the operation finishes, the timer rings loudly (<code>TimeoutError</code> is emitted), and you stop waiting for the original operation.</li> </ul>"},{"location":"Operators/Utility/timeout/#key-configurations-behaviors","title":"Key Configurations &amp; Behaviors","text":"<p>You can configure <code>timeout</code> with a duration (milliseconds) or a specific Date. More advanced configurations allow specifying different timeouts for the first emission versus subsequent emissions, but the most common use is a single duration for the overall operation.</p> <ul> <li><code>timeout(5000)</code>: Throws <code>TimeoutError</code> if the first emission doesn't arrive within 5 seconds of subscription.</li> <li><code>timeout({ first: 5000, each: 1000 })</code>: Throws if the first emission takes longer than 5s, OR if the time between any two subsequent emissions exceeds 1s. (Less common).</li> <li><code>timeout({ each: 10000 })</code>: Allows the first emission to take any amount of time, but throws if subsequent emissions are more than 10s apart.</li> </ul>"},{"location":"Operators/Utility/timeout/#why-use-timeout","title":"Why Use <code>timeout</code>?","text":"<ol> <li>Preventing Indefinite Waits: Protects your application from hanging if a backend service or other asynchronous source becomes unresponsive.</li> <li>Improving User Experience: Provides timely feedback (an error message) to the user instead of leaving them staring at a loading spinner forever.</li> <li>Resource Management: Can help release resources tied up in waiting for a response that may never come.</li> </ol>"},{"location":"Operators/Utility/timeout/#real-world-example-setting-a-timeout-for-an-api-request","title":"Real-World Example: Setting a Timeout for an API Request","text":"<p>A common scenario is fetching data from an external API. Sometimes, the network might be slow, or the API server itself might be experiencing issues. We want to limit how long we wait for a response before giving up.</p>"},{"location":"Operators/Utility/timeout/#code-snippet","title":"Code Snippet","text":"<p>1. Mock Data Service (Simulates Slow/Fast Responses)</p> <pre><code>import { Injectable } from \"@angular/core\";\nimport { Observable, of, timer } from \"rxjs\";\nimport { delay, switchMap, tap } from \"rxjs/operators\";\n\nexport interface ExternalData {\n  id: string;\n  value: number;\n}\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class SlowDataService {\n  fetchData(id: string, responseTimeMs: number): Observable&lt;ExternalData&gt; {\n    console.log(\n      `Backend: Request received for ID ${id}. Will respond in ${responseTimeMs}ms.`\n    );\n    const data: ExternalData = { id: id, value: Math.random() * 100 };\n\n    // Simulate the delay\n    return of(data).pipe(\n      delay(responseTimeMs),\n      tap(() =&gt; console.log(`Backend: Responding for ID ${id}.`))\n    );\n  }\n}\n</code></pre> <p>2. Data Fetching Component (Applies <code>timeout</code>)</p> <pre><code>import {\n  Component,\n  inject,\n  signal,\n  ChangeDetectionStrategy,\n  DestroyRef,\n} from \"@angular/core\";\nimport { CommonModule } from \"@angular/common\";\nimport { takeUntilDestroyed } from \"@angular/core/rxjs-interop\";\nimport { SlowDataService, ExternalData } from \"./slow-data.service\"; // Adjust path\nimport { tap, timeout, catchError, finalize } from \"rxjs/operators\";\nimport { EMPTY, TimeoutError } from \"rxjs\"; // Import TimeoutError and EMPTY\n\n@Component({\n  selector: \"app-data-fetcher\",\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    &lt;div&gt;\n      &lt;h4&gt;Data Fetcher with Timeout&lt;/h4&gt;\n      &lt;button (click)=\"getData(500)\" [disabled]=\"loading()\"&gt;\n        Fetch Fast Data (500ms)\n      &lt;/button&gt;\n      &lt;button (click)=\"getData(6000)\" [disabled]=\"loading()\"&gt;\n        Fetch Slow Data (6000ms)\n      &lt;/button&gt;\n\n      @if (loading()) {\n      &lt;p class=\"status loading\"&gt;Loading data (Timeout set to 5s)...&lt;/p&gt;\n      } @if (errorMessage()) {\n      &lt;p class=\"status error\"&gt;Error: {{ errorMessage() }}&lt;/p&gt;\n      } @if (fetchedData()) {\n      &lt;div class=\"data\"&gt;\n        &lt;p&gt;Data Received:&lt;/p&gt;\n        &lt;pre&gt;{{ fetchedData() | json }}&lt;/pre&gt;\n      &lt;/div&gt;\n      }\n    &lt;/div&gt;\n  `,\n  // No 'styles' section as per previous request\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class DataFetcherComponent {\n  private dataService = inject(SlowDataService);\n  private destroyRef = inject(DestroyRef);\n\n  // --- State Signals ---\n  loading = signal&lt;boolean&gt;(false);\n  fetchedData = signal&lt;ExternalData | null&gt;(null);\n  errorMessage = signal&lt;string | null&gt;(null);\n\n  private readonly apiTimeoutMs = 5000; // Set timeout to 5 seconds\n\n  getData(responseTimeMs: number): void {\n    if (this.loading()) return;\n\n    this.loading.set(true);\n    this.fetchedData.set(null);\n    this.errorMessage.set(null);\n    console.log(\n      `UI: Initiating fetch. Response expected in ${responseTimeMs}ms. Timeout is ${this.apiTimeoutMs}ms.`\n    );\n\n    this.dataService\n      .fetchData(\"item123\", responseTimeMs)\n      .pipe(\n        tap((data) =&gt;\n          console.log(\n            \"UI Stream: Data received (before timeout check completed)\"\n          )\n        ),\n\n        // --- Apply the timeout ---\n        timeout(this.apiTimeoutMs), // If no 'next' within 5000ms, throw TimeoutError\n        // -----------------------\n\n        catchError((err) =&gt; {\n          console.error(\"UI Stream: Error caught.\");\n          // --- Check specifically for TimeoutError ---\n          if (err instanceof TimeoutError) {\n            console.error(\"Error Type: TimeoutError\");\n            this.errorMessage.set(\n              `Operation timed out after ${this.apiTimeoutMs / 1000} seconds.`\n            );\n          } else {\n            console.error(\"Error Type: Other\", err);\n            this.errorMessage.set(\n              `An unexpected error occurred: ${err.message || err}`\n            );\n          }\n          // Return EMPTY to allow finalize to run\n          return EMPTY;\n        }),\n        finalize(() =&gt; {\n          this.loading.set(false);\n          console.log(\n            \"UI: Finalize block executed - Loading state set to false.\"\n          );\n        }),\n        takeUntilDestroyed(this.destroyRef)\n      )\n      .subscribe({\n        next: (data) =&gt; {\n          console.log(\"UI: Subscribe next - updating data signal.\");\n          this.fetchedData.set(data);\n        },\n        // Error handled by catchError\n        error: (err) =&gt; {\n          /* Already handled */\n        },\n        complete: () =&gt; {\n          console.log(\"UI: Subscribe complete.\");\n        },\n      });\n  }\n}\n</code></pre> <p>Explanation:</p> <ol> <li>When <code>getData()</code> is called, <code>loading</code> is set to <code>true</code>.</li> <li>The <code>SlowDataService.fetchData</code> method is called, which returns an Observable that will emit data after the specified <code>responseTimeMs</code>.</li> <li><code>timeout(this.apiTimeoutMs)</code>: This operator starts its internal timer (5000ms). It waits for the <code>fetchData</code> Observable to emit a <code>next</code> notification.<ul> <li>Scenario 1 (Fetch Fast Data - 500ms): The <code>fetchData</code> Observable emits data after 500ms. This is well within the 5000ms timeout. <code>timeout</code> sees the emission, cancels its internal timer, and passes the data along the stream. The data is displayed.</li> <li>Scenario 2 (Fetch Slow Data - 6000ms): The <code>fetchData</code> Observable is set to respond after 6000ms. The <code>timeout</code> operator's timer reaches 5000ms before <code>fetchData</code> emits anything. <code>timeout</code> stops waiting, throws a <code>TimeoutError</code>, and terminates the source subscription.</li> </ul> </li> <li><code>catchError((err) =&gt; ...)</code>: This catches any error, including the <code>TimeoutError</code>.<ul> <li>We use <code>instanceof TimeoutError</code> to specifically check if the error was due to the timeout.</li> <li>We set an appropriate <code>errorMessage</code> based on the error type.</li> <li>We return <code>EMPTY</code> to ensure the stream completes gracefully for <code>finalize</code>.</li> </ul> </li> <li><code>finalize(() =&gt; { this.loading.set(false); })</code>: This runs reliably after the stream terminates (either successfully after <code>next</code>, or after <code>catchError</code> handles the <code>TimeoutError</code> or any other error), ensuring the loading indicator is hidden.</li> <li><code>takeUntilDestroyed</code>: Standard automatic unsubscription.</li> <li>The <code>subscribe</code> block updates the <code>fetchedData</code> signal only if the operation completed successfully within the timeout period.</li> </ol> <p>By using <code>timeout</code>, you make your data fetching more robust against unresponsive services, leading to a better user experience.</p>"}]}